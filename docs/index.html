<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>lathecode editor</title>
  <link rel="icon" href="data:,">
  <script type="module" crossorigin>
var ul=Object.defineProperty;var pl=(s,t,e)=>t in s?ul(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var Tt=(s,t,e)=>(pl(s,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))n(a);new MutationObserver(a=>{for(const i of a)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&n(r)}).observe(document,{childList:!0,subtree:!0});function e(a){const i={};return a.integrity&&(i.integrity=a.integrity),a.referrerPolicy&&(i.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?i.credentials="include":a.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(a){if(a.ep)return;a.ep=!0;const i=e(a);fetch(a.href,i)}})();/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Ra="153",$n={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},ti={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},ml=0,Ha=1,bl=2,Mr=1,xr=2,xn=3,zn=0,Ne=1,nn=2,Cn=0,xi=1,Fa=2,_a=3,Ua=4,fl=5,yi=100,yl=101,Ml=102,ka=103,Da=104,xl=200,Gl=201,Xl=202,Ll=203,Gr=204,Xr=205,Sl=206,gl=207,Tl=208,Zl=209,Rl=210,Wl=0,Cl=1,vl=2,fa=3,zl=4,Nl=5,Il=6,Vl=7,Lr=0,Kl=1,wl=2,Xn=0,El=1,Pl=2,Yl=3,Hl=4,Fl=5,Sr=300,Xi=301,Li=302,ya=303,Ma=304,Zs=306,xa=1e3,$e=1001,Ga=1002,ve=1003,Aa=1004,Ks=1005,Ue=1006,_l=1007,Yi=1008,vn=1009,Ul=1010,kl=1011,Wa=1012,gr=1013,Rn=1014,Wn=1015,Hi=1016,Tr=1017,Zr=1018,Hn=1020,Dl=1021,tn=1023,Al=1024,Jl=1025,Fn=1026,Si=1027,Bl=1028,Rr=1029,Ol=1030,Wr=1031,Cr=1033,ws=33776,Es=33777,Ps=33778,Ys=33779,Ja=35840,Ba=35841,Oa=35842,ja=35843,jl=36196,Qa=37492,qa=37496,$a=37808,to=37809,eo=37810,no=37811,io=37812,so=37813,ao=37814,oo=37815,ro=37816,lo=37817,co=37818,ho=37819,uo=37820,po=37821,Hs=36492,Ql=36283,mo=36284,bo=36285,fo=36286,vr=3e3,_n=3001,ql=3200,$l=3201,zr=0,tc=1,Un="",Ut="srgb",on="srgb-linear",Nr="display-p3",Fs=7680,ec=519,nc=512,ic=513,sc=514,ac=515,oc=516,rc=517,lc=518,cc=519,yo=35044,Mo="300 es",Xa=1035,Gn=2e3,Ss=2001;class Bn{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const a=this._listeners[t];if(a!==void 0){const i=a.indexOf(e);i!==-1&&a.splice(i,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const a=n.slice(0);for(let i=0,r=a.length;i<r;i++)a[i].call(this,t);t.target=null}}}const Se=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],_s=Math.PI/180,La=180/Math.PI;function Fi(){const s=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Se[s&255]+Se[s>>8&255]+Se[s>>16&255]+Se[s>>24&255]+"-"+Se[t&255]+Se[t>>8&255]+"-"+Se[t>>16&15|64]+Se[t>>24&255]+"-"+Se[e&63|128]+Se[e>>8&255]+"-"+Se[e>>16&255]+Se[e>>24&255]+Se[n&255]+Se[n>>8&255]+Se[n>>16&255]+Se[n>>24&255]).toLowerCase()}function Te(s,t,e){return Math.max(t,Math.min(e,s))}function dc(s,t){return(s%t+t)%t}function Us(s,t,e){return(1-e)*s+e*t}function xo(s){return(s&s-1)===0&&s!==0}function Sa(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function $i(s,t){switch(t.constructor){case Float32Array:return s;case Uint32Array:return s/4294967295;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int32Array:return Math.max(s/2147483647,-1);case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}function Ke(s,t){switch(t.constructor){case Float32Array:return s;case Uint32Array:return Math.round(s*4294967295);case Uint16Array:return Math.round(s*65535);case Uint8Array:return Math.round(s*255);case Int32Array:return Math.round(s*2147483647);case Int16Array:return Math.round(s*32767);case Int8Array:return Math.round(s*127);default:throw new Error("Invalid component type.")}}class Kt{constructor(t=0,e=0){Kt.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,a=t.elements;return this.x=a[0]*e+a[3]*n+a[6],this.y=a[1]*e+a[4]*n+a[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Te(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),a=Math.sin(e),i=this.x-t.x,r=this.y-t.y;return this.x=i*n-r*a+t.x,this.y=i*a+r*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Jt{constructor(t,e,n,a,i,r,o,l,c){Jt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,n,a,i,r,o,l,c)}set(t,e,n,a,i,r,o,l,c){const h=this.elements;return h[0]=t,h[1]=a,h[2]=o,h[3]=e,h[4]=i,h[5]=l,h[6]=n,h[7]=r,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,a=e.elements,i=this.elements,r=n[0],o=n[3],l=n[6],c=n[1],h=n[4],p=n[7],u=n[2],b=n[5],x=n[8],y=a[0],m=a[3],d=a[6],Z=a[1],L=a[4],T=a[7],g=a[2],v=a[5],N=a[8];return i[0]=r*y+o*Z+l*g,i[3]=r*m+o*L+l*v,i[6]=r*d+o*T+l*N,i[1]=c*y+h*Z+p*g,i[4]=c*m+h*L+p*v,i[7]=c*d+h*T+p*N,i[2]=u*y+b*Z+x*g,i[5]=u*m+b*L+x*v,i[8]=u*d+b*T+x*N,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],a=t[2],i=t[3],r=t[4],o=t[5],l=t[6],c=t[7],h=t[8];return e*r*h-e*o*c-n*i*h+n*o*l+a*i*c-a*r*l}invert(){const t=this.elements,e=t[0],n=t[1],a=t[2],i=t[3],r=t[4],o=t[5],l=t[6],c=t[7],h=t[8],p=h*r-o*c,u=o*l-h*i,b=c*i-r*l,x=e*p+n*u+a*b;if(x===0)return this.set(0,0,0,0,0,0,0,0,0);const y=1/x;return t[0]=p*y,t[1]=(a*c-h*n)*y,t[2]=(o*n-a*r)*y,t[3]=u*y,t[4]=(h*e-a*l)*y,t[5]=(a*i-o*e)*y,t[6]=b*y,t[7]=(n*l-c*e)*y,t[8]=(r*e-n*i)*y,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,a,i,r,o){const l=Math.cos(i),c=Math.sin(i);return this.set(n*l,n*c,-n*(l*r+c*o)+r+t,-a*c,a*l,-a*(-c*r+l*o)+o+e,0,0,1),this}scale(t,e){return this.premultiply(ks.makeScale(t,e)),this}rotate(t){return this.premultiply(ks.makeRotation(-t)),this}translate(t,e){return this.premultiply(ks.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let a=0;a<9;a++)if(e[a]!==n[a])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const ks=new Jt;function Ir(s){for(let t=s.length-1;t>=0;--t)if(s[t]>=65535)return!0;return!1}function gs(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}const Go={};function Pi(s){s in Go||(Go[s]=!0,console.warn(s))}function Gi(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function Ds(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}const hc=new Jt().fromArray([.8224621,.0331941,.0170827,.177538,.9668058,.0723974,-1e-7,1e-7,.9105199]),uc=new Jt().fromArray([1.2249401,-.0420569,-.0196376,-.2249404,1.0420571,-.0786361,1e-7,0,1.0982735]);function pc(s){return s.convertSRGBToLinear().applyMatrix3(uc)}function mc(s){return s.applyMatrix3(hc).convertLinearToSRGB()}const bc={[on]:s=>s,[Ut]:s=>s.convertSRGBToLinear(),[Nr]:pc},fc={[on]:s=>s,[Ut]:s=>s.convertLinearToSRGB(),[Nr]:mc},Je={enabled:!0,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(s){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!s},get workingColorSpace(){return on},set workingColorSpace(s){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(s,t,e){if(this.enabled===!1||t===e||!t||!e)return s;const n=bc[t],a=fc[e];if(n===void 0||a===void 0)throw new Error(`Unsupported color space conversion, "${t}" to "${e}".`);return a(n(s))},fromWorkingColorSpace:function(s,t){return this.convert(s,this.workingColorSpace,t)},toWorkingColorSpace:function(s,t){return this.convert(s,t,this.workingColorSpace)}};let ei;class Vr{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{ei===void 0&&(ei=gs("canvas")),ei.width=t.width,ei.height=t.height;const n=ei.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=ei}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=gs("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const a=n.getImageData(0,0,t.width,t.height),i=a.data;for(let r=0;r<i.length;r++)i[r]=Gi(i[r]/255)*255;return n.putImageData(a,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor(Gi(e[n]/255)*255):e[n]=Gi(e[n]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let yc=0;class Kr{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:yc++}),this.uuid=Fi(),this.data=t,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},a=this.data;if(a!==null){let i;if(Array.isArray(a)){i=[];for(let r=0,o=a.length;r<o;r++)a[r].isDataTexture?i.push(As(a[r].image)):i.push(As(a[r]))}else i=As(a);n.url=i}return e||(t.images[this.uuid]=n),n}}function As(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?Vr.getDataURL(s):s.data?{data:Array.from(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Mc=0;class Pe extends Bn{constructor(t=Pe.DEFAULT_IMAGE,e=Pe.DEFAULT_MAPPING,n=$e,a=$e,i=Ue,r=Yi,o=tn,l=vn,c=Pe.DEFAULT_ANISOTROPY,h=Un){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Mc++}),this.uuid=Fi(),this.name="",this.source=new Kr(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=a,this.magFilter=i,this.minFilter=r,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Kt(0,0),this.repeat=new Kt(1,1),this.center=new Kt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Jt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof h=="string"?this.colorSpace=h:(Pi("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=h===_n?Ut:Un),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Sr)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case xa:t.x=t.x-Math.floor(t.x);break;case $e:t.x=t.x<0?0:1;break;case Ga:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case xa:t.y=t.y-Math.floor(t.y);break;case $e:t.y=t.y<0?0:1;break;case Ga:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return Pi("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===Ut?_n:vr}set encoding(t){Pi("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=t===_n?Ut:Un}}Pe.DEFAULT_IMAGE=null;Pe.DEFAULT_MAPPING=Sr;Pe.DEFAULT_ANISOTROPY=1;class Ge{constructor(t=0,e=0,n=0,a=1){Ge.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=a}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,a){return this.x=t,this.y=e,this.z=n,this.w=a,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,a=this.z,i=this.w,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*a+r[12]*i,this.y=r[1]*e+r[5]*n+r[9]*a+r[13]*i,this.z=r[2]*e+r[6]*n+r[10]*a+r[14]*i,this.w=r[3]*e+r[7]*n+r[11]*a+r[15]*i,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,a,i;const l=t.elements,c=l[0],h=l[4],p=l[8],u=l[1],b=l[5],x=l[9],y=l[2],m=l[6],d=l[10];if(Math.abs(h-u)<.01&&Math.abs(p-y)<.01&&Math.abs(x-m)<.01){if(Math.abs(h+u)<.1&&Math.abs(p+y)<.1&&Math.abs(x+m)<.1&&Math.abs(c+b+d-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const L=(c+1)/2,T=(b+1)/2,g=(d+1)/2,v=(h+u)/4,N=(p+y)/4,K=(x+m)/4;return L>T&&L>g?L<.01?(n=0,a=.707106781,i=.707106781):(n=Math.sqrt(L),a=v/n,i=N/n):T>g?T<.01?(n=.707106781,a=0,i=.707106781):(a=Math.sqrt(T),n=v/a,i=K/a):g<.01?(n=.707106781,a=.707106781,i=0):(i=Math.sqrt(g),n=N/i,a=K/i),this.set(n,a,i,e),this}let Z=Math.sqrt((m-x)*(m-x)+(p-y)*(p-y)+(u-h)*(u-h));return Math.abs(Z)<.001&&(Z=1),this.x=(m-x)/Z,this.y=(p-y)/Z,this.z=(u-h)/Z,this.w=Math.acos((c+b+d-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class kn extends Bn{constructor(t=1,e=1,n={}){super(),this.isWebGLRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new Ge(0,0,t,e),this.scissorTest=!1,this.viewport=new Ge(0,0,t,e);const a={width:t,height:e,depth:1};n.encoding!==void 0&&(Pi("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),n.colorSpace=n.encoding===_n?Ut:Un),this.texture=new Pe(a,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Ue,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Kr(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class wr extends Pe{constructor(t=null,e=1,n=1,a=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:a},this.magFilter=ve,this.minFilter=ve,this.wrapR=$e,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class xc extends Pe{constructor(t=null,e=1,n=1,a=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:a},this.magFilter=ve,this.minFilter=ve,this.wrapR=$e,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Dn{constructor(t=0,e=0,n=0,a=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=a}static slerpFlat(t,e,n,a,i,r,o){let l=n[a+0],c=n[a+1],h=n[a+2],p=n[a+3];const u=i[r+0],b=i[r+1],x=i[r+2],y=i[r+3];if(o===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=p;return}if(o===1){t[e+0]=u,t[e+1]=b,t[e+2]=x,t[e+3]=y;return}if(p!==y||l!==u||c!==b||h!==x){let m=1-o;const d=l*u+c*b+h*x+p*y,Z=d>=0?1:-1,L=1-d*d;if(L>Number.EPSILON){const g=Math.sqrt(L),v=Math.atan2(g,d*Z);m=Math.sin(m*v)/g,o=Math.sin(o*v)/g}const T=o*Z;if(l=l*m+u*T,c=c*m+b*T,h=h*m+x*T,p=p*m+y*T,m===1-o){const g=1/Math.sqrt(l*l+c*c+h*h+p*p);l*=g,c*=g,h*=g,p*=g}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=p}static multiplyQuaternionsFlat(t,e,n,a,i,r){const o=n[a],l=n[a+1],c=n[a+2],h=n[a+3],p=i[r],u=i[r+1],b=i[r+2],x=i[r+3];return t[e]=o*x+h*p+l*b-c*u,t[e+1]=l*x+h*u+c*p-o*b,t[e+2]=c*x+h*b+o*u-l*p,t[e+3]=h*x-o*p-l*u-c*b,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,a){return this._x=t,this._y=e,this._z=n,this._w=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){const n=t._x,a=t._y,i=t._z,r=t._order,o=Math.cos,l=Math.sin,c=o(n/2),h=o(a/2),p=o(i/2),u=l(n/2),b=l(a/2),x=l(i/2);switch(r){case"XYZ":this._x=u*h*p+c*b*x,this._y=c*b*p-u*h*x,this._z=c*h*x+u*b*p,this._w=c*h*p-u*b*x;break;case"YXZ":this._x=u*h*p+c*b*x,this._y=c*b*p-u*h*x,this._z=c*h*x-u*b*p,this._w=c*h*p+u*b*x;break;case"ZXY":this._x=u*h*p-c*b*x,this._y=c*b*p+u*h*x,this._z=c*h*x+u*b*p,this._w=c*h*p-u*b*x;break;case"ZYX":this._x=u*h*p-c*b*x,this._y=c*b*p+u*h*x,this._z=c*h*x-u*b*p,this._w=c*h*p+u*b*x;break;case"YZX":this._x=u*h*p+c*b*x,this._y=c*b*p+u*h*x,this._z=c*h*x-u*b*p,this._w=c*h*p-u*b*x;break;case"XZY":this._x=u*h*p-c*b*x,this._y=c*b*p-u*h*x,this._z=c*h*x+u*b*p,this._w=c*h*p+u*b*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,a=Math.sin(n);return this._x=t.x*a,this._y=t.y*a,this._z=t.z*a,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],a=e[4],i=e[8],r=e[1],o=e[5],l=e[9],c=e[2],h=e[6],p=e[10],u=n+o+p;if(u>0){const b=.5/Math.sqrt(u+1);this._w=.25/b,this._x=(h-l)*b,this._y=(i-c)*b,this._z=(r-a)*b}else if(n>o&&n>p){const b=2*Math.sqrt(1+n-o-p);this._w=(h-l)/b,this._x=.25*b,this._y=(a+r)/b,this._z=(i+c)/b}else if(o>p){const b=2*Math.sqrt(1+o-n-p);this._w=(i-c)/b,this._x=(a+r)/b,this._y=.25*b,this._z=(l+h)/b}else{const b=2*Math.sqrt(1+p-n-o);this._w=(r-a)/b,this._x=(i+c)/b,this._y=(l+h)/b,this._z=.25*b}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Te(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const a=Math.min(1,e/n);return this.slerp(t,a),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,a=t._y,i=t._z,r=t._w,o=e._x,l=e._y,c=e._z,h=e._w;return this._x=n*h+r*o+a*c-i*l,this._y=a*h+r*l+i*o-n*c,this._z=i*h+r*c+n*l-a*o,this._w=r*h-n*o-a*l-i*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,a=this._y,i=this._z,r=this._w;let o=r*t._w+n*t._x+a*t._y+i*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=r,this._x=n,this._y=a,this._z=i,this;const l=1-o*o;if(l<=Number.EPSILON){const b=1-e;return this._w=b*r+e*this._w,this._x=b*n+e*this._x,this._y=b*a+e*this._y,this._z=b*i+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,o),p=Math.sin((1-e)*h)/c,u=Math.sin(e*h)/c;return this._w=r*p+this._w*u,this._x=n*p+this._x*u,this._y=a*p+this._y*u,this._z=i*p+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),a=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(e*Math.cos(a),n*Math.sin(i),n*Math.cos(i),e*Math.sin(a))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class V{constructor(t=0,e=0,n=0){V.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(Xo.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Xo.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,a=this.z,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6]*a,this.y=i[1]*e+i[4]*n+i[7]*a,this.z=i[2]*e+i[5]*n+i[8]*a,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,a=this.z,i=t.elements,r=1/(i[3]*e+i[7]*n+i[11]*a+i[15]);return this.x=(i[0]*e+i[4]*n+i[8]*a+i[12])*r,this.y=(i[1]*e+i[5]*n+i[9]*a+i[13])*r,this.z=(i[2]*e+i[6]*n+i[10]*a+i[14])*r,this}applyQuaternion(t){const e=this.x,n=this.y,a=this.z,i=t.x,r=t.y,o=t.z,l=t.w,c=l*e+r*a-o*n,h=l*n+o*e-i*a,p=l*a+i*n-r*e,u=-i*e-r*n-o*a;return this.x=c*l+u*-i+h*-o-p*-r,this.y=h*l+u*-r+p*-i-c*-o,this.z=p*l+u*-o+c*-r-h*-i,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,a=this.z,i=t.elements;return this.x=i[0]*e+i[4]*n+i[8]*a,this.y=i[1]*e+i[5]*n+i[9]*a,this.z=i[2]*e+i[6]*n+i[10]*a,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,a=t.y,i=t.z,r=e.x,o=e.y,l=e.z;return this.x=a*l-i*o,this.y=i*r-n*l,this.z=n*o-a*r,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Js.copy(this).projectOnVector(t),this.sub(Js)}reflect(t){return this.sub(Js.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Te(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,a=this.z-t.z;return e*e+n*n+a*a}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const a=Math.sin(e)*t;return this.x=a*Math.sin(n),this.y=Math.cos(e)*t,this.z=a*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),a=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=a,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Js=new V,Xo=new Dn;class On{constructor(t=new V(1/0,1/0,1/0),e=new V(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(mn.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(mn.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=mn.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){if(t.updateWorldMatrix(!1,!1),t.boundingBox!==void 0)t.boundingBox===null&&t.computeBoundingBox(),ni.copy(t.boundingBox),ni.applyMatrix4(t.matrixWorld),this.union(ni);else{const a=t.geometry;if(a!==void 0)if(e&&a.attributes!==void 0&&a.attributes.position!==void 0){const i=a.attributes.position;for(let r=0,o=i.count;r<o;r++)mn.fromBufferAttribute(i,r).applyMatrix4(t.matrixWorld),this.expandByPoint(mn)}else a.boundingBox===null&&a.computeBoundingBox(),ni.copy(a.boundingBox),ni.applyMatrix4(t.matrixWorld),this.union(ni)}const n=t.children;for(let a=0,i=n.length;a<i;a++)this.expandByObject(n[a],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,mn),mn.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Ii),ts.subVectors(this.max,Ii),ii.subVectors(t.a,Ii),si.subVectors(t.b,Ii),ai.subVectors(t.c,Ii),Sn.subVectors(si,ii),gn.subVectors(ai,si),In.subVectors(ii,ai);let e=[0,-Sn.z,Sn.y,0,-gn.z,gn.y,0,-In.z,In.y,Sn.z,0,-Sn.x,gn.z,0,-gn.x,In.z,0,-In.x,-Sn.y,Sn.x,0,-gn.y,gn.x,0,-In.y,In.x,0];return!Bs(e,ii,si,ai,ts)||(e=[1,0,0,0,1,0,0,0,1],!Bs(e,ii,si,ai,ts))?!1:(es.crossVectors(Sn,gn),e=[es.x,es.y,es.z],Bs(e,ii,si,ai,ts))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,mn).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(mn).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(pn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),pn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),pn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),pn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),pn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),pn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),pn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),pn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(pn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const pn=[new V,new V,new V,new V,new V,new V,new V,new V],mn=new V,ni=new On,ii=new V,si=new V,ai=new V,Sn=new V,gn=new V,In=new V,Ii=new V,ts=new V,es=new V,Vn=new V;function Bs(s,t,e,n,a){for(let i=0,r=s.length-3;i<=r;i+=3){Vn.fromArray(s,i);const o=a.x*Math.abs(Vn.x)+a.y*Math.abs(Vn.y)+a.z*Math.abs(Vn.z),l=t.dot(Vn),c=e.dot(Vn),h=n.dot(Vn);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>o)return!1}return!0}const Gc=new On,Vi=new V,Os=new V;class Ca{constructor(t=new V,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Gc.setFromPoints(t).getCenter(n);let a=0;for(let i=0,r=t.length;i<r;i++)a=Math.max(a,n.distanceToSquared(t[i]));return this.radius=Math.sqrt(a),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Vi.subVectors(t,this.center);const e=Vi.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),a=(n-this.radius)*.5;this.center.addScaledVector(Vi,a/n),this.radius+=a}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(Os.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Vi.copy(t.center).add(Os)),this.expandByPoint(Vi.copy(t.center).sub(Os))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const bn=new V,js=new V,ns=new V,Tn=new V,Qs=new V,is=new V,qs=new V;class Xc{constructor(t=new V,e=new V(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,bn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=bn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(bn.copy(this.origin).addScaledVector(this.direction,e),bn.distanceToSquared(t))}distanceSqToSegment(t,e,n,a){js.copy(t).add(e).multiplyScalar(.5),ns.copy(e).sub(t).normalize(),Tn.copy(this.origin).sub(js);const i=t.distanceTo(e)*.5,r=-this.direction.dot(ns),o=Tn.dot(this.direction),l=-Tn.dot(ns),c=Tn.lengthSq(),h=Math.abs(1-r*r);let p,u,b,x;if(h>0)if(p=r*l-o,u=r*o-l,x=i*h,p>=0)if(u>=-x)if(u<=x){const y=1/h;p*=y,u*=y,b=p*(p+r*u+2*o)+u*(r*p+u+2*l)+c}else u=i,p=Math.max(0,-(r*u+o)),b=-p*p+u*(u+2*l)+c;else u=-i,p=Math.max(0,-(r*u+o)),b=-p*p+u*(u+2*l)+c;else u<=-x?(p=Math.max(0,-(-r*i+o)),u=p>0?-i:Math.min(Math.max(-i,-l),i),b=-p*p+u*(u+2*l)+c):u<=x?(p=0,u=Math.min(Math.max(-i,-l),i),b=u*(u+2*l)+c):(p=Math.max(0,-(r*i+o)),u=p>0?i:Math.min(Math.max(-i,-l),i),b=-p*p+u*(u+2*l)+c);else u=r>0?-i:i,p=Math.max(0,-(r*u+o)),b=-p*p+u*(u+2*l)+c;return n&&n.copy(this.origin).addScaledVector(this.direction,p),a&&a.copy(js).addScaledVector(ns,u),b}intersectSphere(t,e){bn.subVectors(t.center,this.origin);const n=bn.dot(this.direction),a=bn.dot(bn)-n*n,i=t.radius*t.radius;if(a>i)return null;const r=Math.sqrt(i-a),o=n-r,l=n+r;return l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,a,i,r,o,l;const c=1/this.direction.x,h=1/this.direction.y,p=1/this.direction.z,u=this.origin;return c>=0?(n=(t.min.x-u.x)*c,a=(t.max.x-u.x)*c):(n=(t.max.x-u.x)*c,a=(t.min.x-u.x)*c),h>=0?(i=(t.min.y-u.y)*h,r=(t.max.y-u.y)*h):(i=(t.max.y-u.y)*h,r=(t.min.y-u.y)*h),n>r||i>a||((i>n||isNaN(n))&&(n=i),(r<a||isNaN(a))&&(a=r),p>=0?(o=(t.min.z-u.z)*p,l=(t.max.z-u.z)*p):(o=(t.max.z-u.z)*p,l=(t.min.z-u.z)*p),n>l||o>a)||((o>n||n!==n)&&(n=o),(l<a||a!==a)&&(a=l),a<0)?null:this.at(n>=0?n:a,e)}intersectsBox(t){return this.intersectBox(t,bn)!==null}intersectTriangle(t,e,n,a,i){Qs.subVectors(e,t),is.subVectors(n,t),qs.crossVectors(Qs,is);let r=this.direction.dot(qs),o;if(r>0){if(a)return null;o=1}else if(r<0)o=-1,r=-r;else return null;Tn.subVectors(this.origin,t);const l=o*this.direction.dot(is.crossVectors(Tn,is));if(l<0)return null;const c=o*this.direction.dot(Qs.cross(Tn));if(c<0||l+c>r)return null;const h=-o*Tn.dot(qs);return h<0?null:this.at(h/r,i)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class me{constructor(t,e,n,a,i,r,o,l,c,h,p,u,b,x,y,m){me.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,n,a,i,r,o,l,c,h,p,u,b,x,y,m)}set(t,e,n,a,i,r,o,l,c,h,p,u,b,x,y,m){const d=this.elements;return d[0]=t,d[4]=e,d[8]=n,d[12]=a,d[1]=i,d[5]=r,d[9]=o,d[13]=l,d[2]=c,d[6]=h,d[10]=p,d[14]=u,d[3]=b,d[7]=x,d[11]=y,d[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new me().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,a=1/oi.setFromMatrixColumn(t,0).length(),i=1/oi.setFromMatrixColumn(t,1).length(),r=1/oi.setFromMatrixColumn(t,2).length();return e[0]=n[0]*a,e[1]=n[1]*a,e[2]=n[2]*a,e[3]=0,e[4]=n[4]*i,e[5]=n[5]*i,e[6]=n[6]*i,e[7]=0,e[8]=n[8]*r,e[9]=n[9]*r,e[10]=n[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,a=t.y,i=t.z,r=Math.cos(n),o=Math.sin(n),l=Math.cos(a),c=Math.sin(a),h=Math.cos(i),p=Math.sin(i);if(t.order==="XYZ"){const u=r*h,b=r*p,x=o*h,y=o*p;e[0]=l*h,e[4]=-l*p,e[8]=c,e[1]=b+x*c,e[5]=u-y*c,e[9]=-o*l,e[2]=y-u*c,e[6]=x+b*c,e[10]=r*l}else if(t.order==="YXZ"){const u=l*h,b=l*p,x=c*h,y=c*p;e[0]=u+y*o,e[4]=x*o-b,e[8]=r*c,e[1]=r*p,e[5]=r*h,e[9]=-o,e[2]=b*o-x,e[6]=y+u*o,e[10]=r*l}else if(t.order==="ZXY"){const u=l*h,b=l*p,x=c*h,y=c*p;e[0]=u-y*o,e[4]=-r*p,e[8]=x+b*o,e[1]=b+x*o,e[5]=r*h,e[9]=y-u*o,e[2]=-r*c,e[6]=o,e[10]=r*l}else if(t.order==="ZYX"){const u=r*h,b=r*p,x=o*h,y=o*p;e[0]=l*h,e[4]=x*c-b,e[8]=u*c+y,e[1]=l*p,e[5]=y*c+u,e[9]=b*c-x,e[2]=-c,e[6]=o*l,e[10]=r*l}else if(t.order==="YZX"){const u=r*l,b=r*c,x=o*l,y=o*c;e[0]=l*h,e[4]=y-u*p,e[8]=x*p+b,e[1]=p,e[5]=r*h,e[9]=-o*h,e[2]=-c*h,e[6]=b*p+x,e[10]=u-y*p}else if(t.order==="XZY"){const u=r*l,b=r*c,x=o*l,y=o*c;e[0]=l*h,e[4]=-p,e[8]=c*h,e[1]=u*p+y,e[5]=r*h,e[9]=b*p-x,e[2]=x*p-b,e[6]=o*h,e[10]=y*p+u}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Lc,t,Sc)}lookAt(t,e,n){const a=this.elements;return we.subVectors(t,e),we.lengthSq()===0&&(we.z=1),we.normalize(),Zn.crossVectors(n,we),Zn.lengthSq()===0&&(Math.abs(n.z)===1?we.x+=1e-4:we.z+=1e-4,we.normalize(),Zn.crossVectors(n,we)),Zn.normalize(),ss.crossVectors(we,Zn),a[0]=Zn.x,a[4]=ss.x,a[8]=we.x,a[1]=Zn.y,a[5]=ss.y,a[9]=we.y,a[2]=Zn.z,a[6]=ss.z,a[10]=we.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,a=e.elements,i=this.elements,r=n[0],o=n[4],l=n[8],c=n[12],h=n[1],p=n[5],u=n[9],b=n[13],x=n[2],y=n[6],m=n[10],d=n[14],Z=n[3],L=n[7],T=n[11],g=n[15],v=a[0],N=a[4],K=a[8],G=a[12],W=a[1],Q=a[5],$=a[9],Y=a[13],U=a[2],A=a[6],nt=a[10],j=a[14],q=a[3],lt=a[7],et=a[11],St=a[15];return i[0]=r*v+o*W+l*U+c*q,i[4]=r*N+o*Q+l*A+c*lt,i[8]=r*K+o*$+l*nt+c*et,i[12]=r*G+o*Y+l*j+c*St,i[1]=h*v+p*W+u*U+b*q,i[5]=h*N+p*Q+u*A+b*lt,i[9]=h*K+p*$+u*nt+b*et,i[13]=h*G+p*Y+u*j+b*St,i[2]=x*v+y*W+m*U+d*q,i[6]=x*N+y*Q+m*A+d*lt,i[10]=x*K+y*$+m*nt+d*et,i[14]=x*G+y*Y+m*j+d*St,i[3]=Z*v+L*W+T*U+g*q,i[7]=Z*N+L*Q+T*A+g*lt,i[11]=Z*K+L*$+T*nt+g*et,i[15]=Z*G+L*Y+T*j+g*St,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],a=t[8],i=t[12],r=t[1],o=t[5],l=t[9],c=t[13],h=t[2],p=t[6],u=t[10],b=t[14],x=t[3],y=t[7],m=t[11],d=t[15];return x*(+i*l*p-a*c*p-i*o*u+n*c*u+a*o*b-n*l*b)+y*(+e*l*b-e*c*u+i*r*u-a*r*b+a*c*h-i*l*h)+m*(+e*c*p-e*o*b-i*r*p+n*r*b+i*o*h-n*c*h)+d*(-a*o*h-e*l*p+e*o*u+a*r*p-n*r*u+n*l*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const a=this.elements;return t.isVector3?(a[12]=t.x,a[13]=t.y,a[14]=t.z):(a[12]=t,a[13]=e,a[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],a=t[2],i=t[3],r=t[4],o=t[5],l=t[6],c=t[7],h=t[8],p=t[9],u=t[10],b=t[11],x=t[12],y=t[13],m=t[14],d=t[15],Z=p*m*c-y*u*c+y*l*b-o*m*b-p*l*d+o*u*d,L=x*u*c-h*m*c-x*l*b+r*m*b+h*l*d-r*u*d,T=h*y*c-x*p*c+x*o*b-r*y*b-h*o*d+r*p*d,g=x*p*l-h*y*l-x*o*u+r*y*u+h*o*m-r*p*m,v=e*Z+n*L+a*T+i*g;if(v===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const N=1/v;return t[0]=Z*N,t[1]=(y*u*i-p*m*i-y*a*b+n*m*b+p*a*d-n*u*d)*N,t[2]=(o*m*i-y*l*i+y*a*c-n*m*c-o*a*d+n*l*d)*N,t[3]=(p*l*i-o*u*i-p*a*c+n*u*c+o*a*b-n*l*b)*N,t[4]=L*N,t[5]=(h*m*i-x*u*i+x*a*b-e*m*b-h*a*d+e*u*d)*N,t[6]=(x*l*i-r*m*i-x*a*c+e*m*c+r*a*d-e*l*d)*N,t[7]=(r*u*i-h*l*i+h*a*c-e*u*c-r*a*b+e*l*b)*N,t[8]=T*N,t[9]=(x*p*i-h*y*i-x*n*b+e*y*b+h*n*d-e*p*d)*N,t[10]=(r*y*i-x*o*i+x*n*c-e*y*c-r*n*d+e*o*d)*N,t[11]=(h*o*i-r*p*i-h*n*c+e*p*c+r*n*b-e*o*b)*N,t[12]=g*N,t[13]=(h*y*a-x*p*a+x*n*u-e*y*u-h*n*m+e*p*m)*N,t[14]=(x*o*a-r*y*a-x*n*l+e*y*l+r*n*m-e*o*m)*N,t[15]=(r*p*a-h*o*a+h*n*l-e*p*l-r*n*u+e*o*u)*N,this}scale(t){const e=this.elements,n=t.x,a=t.y,i=t.z;return e[0]*=n,e[4]*=a,e[8]*=i,e[1]*=n,e[5]*=a,e[9]*=i,e[2]*=n,e[6]*=a,e[10]*=i,e[3]*=n,e[7]*=a,e[11]*=i,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],a=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,a))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),a=Math.sin(e),i=1-n,r=t.x,o=t.y,l=t.z,c=i*r,h=i*o;return this.set(c*r+n,c*o-a*l,c*l+a*o,0,c*o+a*l,h*o+n,h*l-a*r,0,c*l-a*o,h*l+a*r,i*l*l+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,a,i,r){return this.set(1,n,i,0,t,1,r,0,e,a,1,0,0,0,0,1),this}compose(t,e,n){const a=this.elements,i=e._x,r=e._y,o=e._z,l=e._w,c=i+i,h=r+r,p=o+o,u=i*c,b=i*h,x=i*p,y=r*h,m=r*p,d=o*p,Z=l*c,L=l*h,T=l*p,g=n.x,v=n.y,N=n.z;return a[0]=(1-(y+d))*g,a[1]=(b+T)*g,a[2]=(x-L)*g,a[3]=0,a[4]=(b-T)*v,a[5]=(1-(u+d))*v,a[6]=(m+Z)*v,a[7]=0,a[8]=(x+L)*N,a[9]=(m-Z)*N,a[10]=(1-(u+y))*N,a[11]=0,a[12]=t.x,a[13]=t.y,a[14]=t.z,a[15]=1,this}decompose(t,e,n){const a=this.elements;let i=oi.set(a[0],a[1],a[2]).length();const r=oi.set(a[4],a[5],a[6]).length(),o=oi.set(a[8],a[9],a[10]).length();this.determinant()<0&&(i=-i),t.x=a[12],t.y=a[13],t.z=a[14],Be.copy(this);const c=1/i,h=1/r,p=1/o;return Be.elements[0]*=c,Be.elements[1]*=c,Be.elements[2]*=c,Be.elements[4]*=h,Be.elements[5]*=h,Be.elements[6]*=h,Be.elements[8]*=p,Be.elements[9]*=p,Be.elements[10]*=p,e.setFromRotationMatrix(Be),n.x=i,n.y=r,n.z=o,this}makePerspective(t,e,n,a,i,r,o=Gn){const l=this.elements,c=2*i/(e-t),h=2*i/(n-a),p=(e+t)/(e-t),u=(n+a)/(n-a);let b,x;if(o===Gn)b=-(r+i)/(r-i),x=-2*r*i/(r-i);else if(o===Ss)b=-r/(r-i),x=-r*i/(r-i);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return l[0]=c,l[4]=0,l[8]=p,l[12]=0,l[1]=0,l[5]=h,l[9]=u,l[13]=0,l[2]=0,l[6]=0,l[10]=b,l[14]=x,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(t,e,n,a,i,r,o=Gn){const l=this.elements,c=1/(e-t),h=1/(n-a),p=1/(r-i),u=(e+t)*c,b=(n+a)*h;let x,y;if(o===Gn)x=(r+i)*p,y=-2*p;else if(o===Ss)x=i*p,y=-1*p;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-u,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-b,l[2]=0,l[6]=0,l[10]=y,l[14]=-x,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let a=0;a<16;a++)if(e[a]!==n[a])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const oi=new V,Be=new me,Lc=new V(0,0,0),Sc=new V(1,1,1),Zn=new V,ss=new V,we=new V,Lo=new me,So=new Dn;class Rs{constructor(t=0,e=0,n=0,a=Rs.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=a}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,a=this._order){return this._x=t,this._y=e,this._z=n,this._order=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const a=t.elements,i=a[0],r=a[4],o=a[8],l=a[1],c=a[5],h=a[9],p=a[2],u=a[6],b=a[10];switch(e){case"XYZ":this._y=Math.asin(Te(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,b),this._z=Math.atan2(-r,i)):(this._x=Math.atan2(u,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Te(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(o,b),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-p,i),this._z=0);break;case"ZXY":this._x=Math.asin(Te(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-p,b),this._z=Math.atan2(-r,c)):(this._y=0,this._z=Math.atan2(l,i));break;case"ZYX":this._y=Math.asin(-Te(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(u,b),this._z=Math.atan2(l,i)):(this._x=0,this._z=Math.atan2(-r,c));break;case"YZX":this._z=Math.asin(Te(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-p,i)):(this._x=0,this._y=Math.atan2(o,b));break;case"XZY":this._z=Math.asin(-Te(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(u,c),this._y=Math.atan2(o,i)):(this._x=Math.atan2(-h,b),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Lo.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Lo,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return So.setFromEuler(this),this.setFromQuaternion(So,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Rs.DEFAULT_ORDER="XYZ";class Er{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let gc=0;const go=new V,ri=new Dn,fn=new me,as=new V,Ki=new V,Tc=new V,Zc=new Dn,To=new V(1,0,0),Zo=new V(0,1,0),Ro=new V(0,0,1),Rc={type:"added"},Wo={type:"removed"};class Ze extends Bn{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:gc++}),this.uuid=Fi(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ze.DEFAULT_UP.clone();const t=new V,e=new Rs,n=new Dn,a=new V(1,1,1);function i(){n.setFromEuler(e,!1)}function r(){e.setFromQuaternion(n,void 0,!1)}e._onChange(i),n._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:a},modelViewMatrix:{value:new me},normalMatrix:{value:new Jt}}),this.matrix=new me,this.matrixWorld=new me,this.matrixAutoUpdate=Ze.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=Ze.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new Er,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ri.setFromAxisAngle(t,e),this.quaternion.multiply(ri),this}rotateOnWorldAxis(t,e){return ri.setFromAxisAngle(t,e),this.quaternion.premultiply(ri),this}rotateX(t){return this.rotateOnAxis(To,t)}rotateY(t){return this.rotateOnAxis(Zo,t)}rotateZ(t){return this.rotateOnAxis(Ro,t)}translateOnAxis(t,e){return go.copy(t).applyQuaternion(this.quaternion),this.position.add(go.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(To,t)}translateY(t){return this.translateOnAxis(Zo,t)}translateZ(t){return this.translateOnAxis(Ro,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(fn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?as.copy(t):as.set(t,e,n);const a=this.parent;this.updateWorldMatrix(!0,!1),Ki.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?fn.lookAt(Ki,as,this.up):fn.lookAt(as,Ki,this.up),this.quaternion.setFromRotationMatrix(fn),a&&(fn.extractRotation(a.matrixWorld),ri.setFromRotationMatrix(fn),this.quaternion.premultiply(ri.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Rc)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Wo)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Wo)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),fn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),fn.multiply(t.parent.matrixWorld)),t.applyMatrix4(fn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,a=this.children.length;n<a;n++){const r=this.children[n].getObjectByProperty(t,e);if(r!==void 0)return r}}getObjectsByProperty(t,e){let n=[];this[t]===e&&n.push(this);for(let a=0,i=this.children.length;a<i;a++){const r=this.children[a].getObjectsByProperty(t,e);r.length>0&&(n=n.concat(r))}return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ki,t,Tc),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ki,Zc,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,a=e.length;n<a;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,a=e.length;n<a;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,a=e.length;n<a;n++){const i=e[n];(i.matrixWorldAutoUpdate===!0||t===!0)&&i.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.matrixWorldAutoUpdate===!0&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const a=this.children;for(let i=0,r=a.length;i<r;i++){const o=a[i];o.matrixWorldAutoUpdate===!0&&o.updateWorldMatrix(!1,!0)}}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const a={};a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),this.castShadow===!0&&(a.castShadow=!0),this.receiveShadow===!0&&(a.receiveShadow=!0),this.visible===!1&&(a.visible=!1),this.frustumCulled===!1&&(a.frustumCulled=!1),this.renderOrder!==0&&(a.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(a.userData=this.userData),a.layers=this.layers.mask,a.matrix=this.matrix.toArray(),a.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(a.matrixAutoUpdate=!1),this.isInstancedMesh&&(a.type="InstancedMesh",a.count=this.count,a.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(a.instanceColor=this.instanceColor.toJSON()));function i(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?a.background=this.background.toJSON():this.background.isTexture&&(a.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(a.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){a.geometry=i(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const p=l[c];i(t.shapes,p)}else i(t.shapes,l)}}if(this.isSkinnedMesh&&(a.bindMode=this.bindMode,a.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(t.skeletons,this.skeleton),a.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(i(t.materials,this.material[l]));a.material=o}else a.material=i(t.materials,this.material);if(this.children.length>0){a.children=[];for(let o=0;o<this.children.length;o++)a.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){a.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];a.animations.push(i(t.animations,l))}}if(e){const o=r(t.geometries),l=r(t.materials),c=r(t.textures),h=r(t.images),p=r(t.shapes),u=r(t.skeletons),b=r(t.animations),x=r(t.nodes);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),p.length>0&&(n.shapes=p),u.length>0&&(n.skeletons=u),b.length>0&&(n.animations=b),x.length>0&&(n.nodes=x)}return n.object=a,n;function r(o){const l=[];for(const c in o){const h=o[c];delete h.metadata,l.push(h)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const a=t.children[n];this.add(a.clone())}return this}}Ze.DEFAULT_UP=new V(0,1,0);Ze.DEFAULT_MATRIX_AUTO_UPDATE=!0;Ze.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Oe=new V,yn=new V,$s=new V,Mn=new V,li=new V,ci=new V,Co=new V,ta=new V,ea=new V,na=new V;let os=!1;class Qe{constructor(t=new V,e=new V,n=new V){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,a){a.subVectors(n,e),Oe.subVectors(t,e),a.cross(Oe);const i=a.lengthSq();return i>0?a.multiplyScalar(1/Math.sqrt(i)):a.set(0,0,0)}static getBarycoord(t,e,n,a,i){Oe.subVectors(a,e),yn.subVectors(n,e),$s.subVectors(t,e);const r=Oe.dot(Oe),o=Oe.dot(yn),l=Oe.dot($s),c=yn.dot(yn),h=yn.dot($s),p=r*c-o*o;if(p===0)return i.set(-2,-1,-1);const u=1/p,b=(c*l-o*h)*u,x=(r*h-o*l)*u;return i.set(1-b-x,x,b)}static containsPoint(t,e,n,a){return this.getBarycoord(t,e,n,a,Mn),Mn.x>=0&&Mn.y>=0&&Mn.x+Mn.y<=1}static getUV(t,e,n,a,i,r,o,l){return os===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),os=!0),this.getInterpolation(t,e,n,a,i,r,o,l)}static getInterpolation(t,e,n,a,i,r,o,l){return this.getBarycoord(t,e,n,a,Mn),l.setScalar(0),l.addScaledVector(i,Mn.x),l.addScaledVector(r,Mn.y),l.addScaledVector(o,Mn.z),l}static isFrontFacing(t,e,n,a){return Oe.subVectors(n,e),yn.subVectors(t,e),Oe.cross(yn).dot(a)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,a){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[a]),this}setFromAttributeAndIndices(t,e,n,a){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,a),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Oe.subVectors(this.c,this.b),yn.subVectors(this.a,this.b),Oe.cross(yn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Qe.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Qe.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,a,i){return os===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),os=!0),Qe.getInterpolation(t,this.a,this.b,this.c,e,n,a,i)}getInterpolation(t,e,n,a,i){return Qe.getInterpolation(t,this.a,this.b,this.c,e,n,a,i)}containsPoint(t){return Qe.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Qe.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,a=this.b,i=this.c;let r,o;li.subVectors(a,n),ci.subVectors(i,n),ta.subVectors(t,n);const l=li.dot(ta),c=ci.dot(ta);if(l<=0&&c<=0)return e.copy(n);ea.subVectors(t,a);const h=li.dot(ea),p=ci.dot(ea);if(h>=0&&p<=h)return e.copy(a);const u=l*p-h*c;if(u<=0&&l>=0&&h<=0)return r=l/(l-h),e.copy(n).addScaledVector(li,r);na.subVectors(t,i);const b=li.dot(na),x=ci.dot(na);if(x>=0&&b<=x)return e.copy(i);const y=b*c-l*x;if(y<=0&&c>=0&&x<=0)return o=c/(c-x),e.copy(n).addScaledVector(ci,o);const m=h*x-b*p;if(m<=0&&p-h>=0&&b-x>=0)return Co.subVectors(i,a),o=(p-h)/(p-h+(b-x)),e.copy(a).addScaledVector(Co,o);const d=1/(m+y+u);return r=y*d,o=u*d,e.copy(n).addScaledVector(li,r).addScaledVector(ci,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Wc=0;class _i extends Bn{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Wc++}),this.uuid=Fi(),this.name="",this.type="Material",this.blending=xi,this.side=zn,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Gr,this.blendDst=Xr,this.blendEquation=yi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=fa,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=ec,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Fs,this.stencilZFail=Fs,this.stencilZPass=Fs,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const a=this[e];if(a===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}a&&a.isColor?a.set(n):a&&a.isVector3&&n&&n.isVector3?a.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==xi&&(n.blending=this.blending),this.side!==zn&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.forceSinglePass===!0&&(n.forceSinglePass=this.forceSinglePass),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function a(i){const r=[];for(const o in i){const l=i[o];delete l.metadata,r.push(l)}return r}if(e){const i=a(t.textures),r=a(t.images);i.length>0&&(n.textures=i),r.length>0&&(n.images=r)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const a=e.length;n=new Array(a);for(let i=0;i!==a;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}const Pr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},je={h:0,s:0,l:0},rs={h:0,s:0,l:0};function ia(s,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?s+(t-s)*6*e:e<1/2?t:e<2/3?s+(t-s)*6*(2/3-e):s}class $t{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(e===void 0&&n===void 0){const a=t;a&&a.isColor?this.copy(a):typeof a=="number"?this.setHex(a):typeof a=="string"&&this.setStyle(a)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Ut){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,Je.toWorkingColorSpace(this,e),this}setRGB(t,e,n,a=Je.workingColorSpace){return this.r=t,this.g=e,this.b=n,Je.toWorkingColorSpace(this,a),this}setHSL(t,e,n,a=Je.workingColorSpace){if(t=dc(t,1),e=Te(e,0,1),n=Te(n,0,1),e===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=ia(r,i,t+1/3),this.g=ia(r,i,t),this.b=ia(r,i,t-1/3)}return Je.toWorkingColorSpace(this,a),this}setStyle(t,e=Ut){function n(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let a;if(a=/^(\w+)\(([^\)]*)\)/.exec(t)){let i;const r=a[1],o=a[2];switch(r){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,e);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,e);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(a=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=a[1],r=i.length;if(r===3)return this.setRGB(parseInt(i.charAt(0),16)/15,parseInt(i.charAt(1),16)/15,parseInt(i.charAt(2),16)/15,e);if(r===6)return this.setHex(parseInt(i,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Ut){const n=Pr[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Gi(t.r),this.g=Gi(t.g),this.b=Gi(t.b),this}copyLinearToSRGB(t){return this.r=Ds(t.r),this.g=Ds(t.g),this.b=Ds(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Ut){return Je.fromWorkingColorSpace(ge.copy(this),t),Math.round(Te(ge.r*255,0,255))*65536+Math.round(Te(ge.g*255,0,255))*256+Math.round(Te(ge.b*255,0,255))}getHexString(t=Ut){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Je.workingColorSpace){Je.fromWorkingColorSpace(ge.copy(this),e);const n=ge.r,a=ge.g,i=ge.b,r=Math.max(n,a,i),o=Math.min(n,a,i);let l,c;const h=(o+r)/2;if(o===r)l=0,c=0;else{const p=r-o;switch(c=h<=.5?p/(r+o):p/(2-r-o),r){case n:l=(a-i)/p+(a<i?6:0);break;case a:l=(i-n)/p+2;break;case i:l=(n-a)/p+4;break}l/=6}return t.h=l,t.s=c,t.l=h,t}getRGB(t,e=Je.workingColorSpace){return Je.fromWorkingColorSpace(ge.copy(this),e),t.r=ge.r,t.g=ge.g,t.b=ge.b,t}getStyle(t=Ut){Je.fromWorkingColorSpace(ge.copy(this),t);const e=ge.r,n=ge.g,a=ge.b;return t!==Ut?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${a.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(n*255)},${Math.round(a*255)})`}offsetHSL(t,e,n){return this.getHSL(je),je.h+=t,je.s+=e,je.l+=n,this.setHSL(je.h,je.s,je.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(je),t.getHSL(rs);const n=Us(je.h,rs.h,e),a=Us(je.s,rs.s,e),i=Us(je.l,rs.l,e);return this.setHSL(n,a,i),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,a=this.b,i=t.elements;return this.r=i[0]*e+i[3]*n+i[6]*a,this.g=i[1]*e+i[4]*n+i[7]*a,this.b=i[2]*e+i[5]*n+i[8]*a,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ge=new $t;$t.NAMES=Pr;class va extends _i{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new $t(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Lr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const pe=new V,ls=new Kt;class an{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n,this.usage=yo,this.updateRange={offset:0,count:-1},this.gpuType=Wn,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let a=0,i=this.itemSize;a<i;a++)this.array[t+a]=e.array[n+a];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)ls.fromBufferAttribute(this,e),ls.applyMatrix3(t),this.setXY(e,ls.x,ls.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)pe.fromBufferAttribute(this,e),pe.applyMatrix3(t),this.setXYZ(e,pe.x,pe.y,pe.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)pe.fromBufferAttribute(this,e),pe.applyMatrix4(t),this.setXYZ(e,pe.x,pe.y,pe.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)pe.fromBufferAttribute(this,e),pe.applyNormalMatrix(t),this.setXYZ(e,pe.x,pe.y,pe.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)pe.fromBufferAttribute(this,e),pe.transformDirection(t),this.setXYZ(e,pe.x,pe.y,pe.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=$i(e,this.array)),e}setX(t,e){return this.normalized&&(e=Ke(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=$i(e,this.array)),e}setY(t,e){return this.normalized&&(e=Ke(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=$i(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Ke(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=$i(e,this.array)),e}setW(t,e){return this.normalized&&(e=Ke(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Ke(e,this.array),n=Ke(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,a){return t*=this.itemSize,this.normalized&&(e=Ke(e,this.array),n=Ke(n,this.array),a=Ke(a,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=a,this}setXYZW(t,e,n,a,i){return t*=this.itemSize,this.normalized&&(e=Ke(e,this.array),n=Ke(n,this.array),a=Ke(a,this.array),i=Ke(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=a,this.array[t+3]=i,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==yo&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class Yr extends an{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Hr extends an{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Ye extends an{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Cc=0;const _e=new me,sa=new Ze,di=new V,Ee=new On,wi=new On,Me=new V;class Ln extends Bn{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Cc++}),this.uuid=Fi(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Ir(t)?Hr:Yr)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const i=new Jt().getNormalMatrix(t);n.applyNormalMatrix(i),n.needsUpdate=!0}const a=this.attributes.tangent;return a!==void 0&&(a.transformDirection(t),a.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return _e.makeRotationFromQuaternion(t),this.applyMatrix4(_e),this}rotateX(t){return _e.makeRotationX(t),this.applyMatrix4(_e),this}rotateY(t){return _e.makeRotationY(t),this.applyMatrix4(_e),this}rotateZ(t){return _e.makeRotationZ(t),this.applyMatrix4(_e),this}translate(t,e,n){return _e.makeTranslation(t,e,n),this.applyMatrix4(_e),this}scale(t,e,n){return _e.makeScale(t,e,n),this.applyMatrix4(_e),this}lookAt(t){return sa.lookAt(t),sa.updateMatrix(),this.applyMatrix4(sa.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(di).negate(),this.translate(di.x,di.y,di.z),this}setFromPoints(t){const e=[];for(let n=0,a=t.length;n<a;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Ye(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new On);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new V(-1/0,-1/0,-1/0),new V(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,a=e.length;n<a;n++){const i=e[n];Ee.setFromBufferAttribute(i),this.morphTargetsRelative?(Me.addVectors(this.boundingBox.min,Ee.min),this.boundingBox.expandByPoint(Me),Me.addVectors(this.boundingBox.max,Ee.max),this.boundingBox.expandByPoint(Me)):(this.boundingBox.expandByPoint(Ee.min),this.boundingBox.expandByPoint(Ee.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ca);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new V,1/0);return}if(t){const n=this.boundingSphere.center;if(Ee.setFromBufferAttribute(t),e)for(let i=0,r=e.length;i<r;i++){const o=e[i];wi.setFromBufferAttribute(o),this.morphTargetsRelative?(Me.addVectors(Ee.min,wi.min),Ee.expandByPoint(Me),Me.addVectors(Ee.max,wi.max),Ee.expandByPoint(Me)):(Ee.expandByPoint(wi.min),Ee.expandByPoint(wi.max))}Ee.getCenter(n);let a=0;for(let i=0,r=t.count;i<r;i++)Me.fromBufferAttribute(t,i),a=Math.max(a,n.distanceToSquared(Me));if(e)for(let i=0,r=e.length;i<r;i++){const o=e[i],l=this.morphTargetsRelative;for(let c=0,h=o.count;c<h;c++)Me.fromBufferAttribute(o,c),l&&(di.fromBufferAttribute(t,c),Me.add(di)),a=Math.max(a,n.distanceToSquared(Me))}this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,a=e.position.array,i=e.normal.array,r=e.uv.array,o=a.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new an(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,c=[],h=[];for(let W=0;W<o;W++)c[W]=new V,h[W]=new V;const p=new V,u=new V,b=new V,x=new Kt,y=new Kt,m=new Kt,d=new V,Z=new V;function L(W,Q,$){p.fromArray(a,W*3),u.fromArray(a,Q*3),b.fromArray(a,$*3),x.fromArray(r,W*2),y.fromArray(r,Q*2),m.fromArray(r,$*2),u.sub(p),b.sub(p),y.sub(x),m.sub(x);const Y=1/(y.x*m.y-m.x*y.y);isFinite(Y)&&(d.copy(u).multiplyScalar(m.y).addScaledVector(b,-y.y).multiplyScalar(Y),Z.copy(b).multiplyScalar(y.x).addScaledVector(u,-m.x).multiplyScalar(Y),c[W].add(d),c[Q].add(d),c[$].add(d),h[W].add(Z),h[Q].add(Z),h[$].add(Z))}let T=this.groups;T.length===0&&(T=[{start:0,count:n.length}]);for(let W=0,Q=T.length;W<Q;++W){const $=T[W],Y=$.start,U=$.count;for(let A=Y,nt=Y+U;A<nt;A+=3)L(n[A+0],n[A+1],n[A+2])}const g=new V,v=new V,N=new V,K=new V;function G(W){N.fromArray(i,W*3),K.copy(N);const Q=c[W];g.copy(Q),g.sub(N.multiplyScalar(N.dot(Q))).normalize(),v.crossVectors(K,Q);const Y=v.dot(h[W])<0?-1:1;l[W*4]=g.x,l[W*4+1]=g.y,l[W*4+2]=g.z,l[W*4+3]=Y}for(let W=0,Q=T.length;W<Q;++W){const $=T[W],Y=$.start,U=$.count;for(let A=Y,nt=Y+U;A<nt;A+=3)G(n[A+0]),G(n[A+1]),G(n[A+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new an(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let u=0,b=n.count;u<b;u++)n.setXYZ(u,0,0,0);const a=new V,i=new V,r=new V,o=new V,l=new V,c=new V,h=new V,p=new V;if(t)for(let u=0,b=t.count;u<b;u+=3){const x=t.getX(u+0),y=t.getX(u+1),m=t.getX(u+2);a.fromBufferAttribute(e,x),i.fromBufferAttribute(e,y),r.fromBufferAttribute(e,m),h.subVectors(r,i),p.subVectors(a,i),h.cross(p),o.fromBufferAttribute(n,x),l.fromBufferAttribute(n,y),c.fromBufferAttribute(n,m),o.add(h),l.add(h),c.add(h),n.setXYZ(x,o.x,o.y,o.z),n.setXYZ(y,l.x,l.y,l.z),n.setXYZ(m,c.x,c.y,c.z)}else for(let u=0,b=e.count;u<b;u+=3)a.fromBufferAttribute(e,u+0),i.fromBufferAttribute(e,u+1),r.fromBufferAttribute(e,u+2),h.subVectors(r,i),p.subVectors(a,i),h.cross(p),n.setXYZ(u+0,h.x,h.y,h.z),n.setXYZ(u+1,h.x,h.y,h.z),n.setXYZ(u+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."),this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Me.fromBufferAttribute(t,e),Me.normalize(),t.setXYZ(e,Me.x,Me.y,Me.z)}toNonIndexed(){function t(o,l){const c=o.array,h=o.itemSize,p=o.normalized,u=new c.constructor(l.length*h);let b=0,x=0;for(let y=0,m=l.length;y<m;y++){o.isInterleavedBufferAttribute?b=l[y]*o.data.stride+o.offset:b=l[y]*h;for(let d=0;d<h;d++)u[x++]=c[b++]}return new an(u,h,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ln,n=this.index.array,a=this.attributes;for(const o in a){const l=a[o],c=t(l,n);e.setAttribute(o,c)}const i=this.morphAttributes;for(const o in i){const l=[],c=i[o];for(let h=0,p=c.length;h<p;h++){const u=c[h],b=t(u,n);l.push(b)}e.morphAttributes[o]=l}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let o=0,l=r.length;o<l;o++){const c=r[o];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(t[c]=l[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const l in n){const c=n[l];t.data.attributes[l]=c.toJSON(t.data)}const a={};let i=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let p=0,u=c.length;p<u;p++){const b=c[p];h.push(b.toJSON(t.data))}h.length>0&&(a[l]=h,i=!0)}i&&(t.data.morphAttributes=a,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const a=t.attributes;for(const c in a){const h=a[c];this.setAttribute(c,h.clone(e))}const i=t.morphAttributes;for(const c in i){const h=[],p=i[c];for(let u=0,b=p.length;u<b;u++)h.push(p[u].clone(e));this.morphAttributes[c]=h}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let c=0,h=r.length;c<h;c++){const p=r[c];this.addGroup(p.start,p.count,p.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const vo=new me,Kn=new Xc,cs=new Ca,zo=new V,hi=new V,ui=new V,pi=new V,aa=new V,ds=new V,hs=new Kt,us=new Kt,ps=new Kt,No=new V,Io=new V,Vo=new V,ms=new V,bs=new V;class sn extends Ze{constructor(t=new Ln,e=new va){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const a=e[n[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,r=a.length;i<r;i++){const o=a[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=i}}}}getVertexPosition(t,e){const n=this.geometry,a=n.attributes.position,i=n.morphAttributes.position,r=n.morphTargetsRelative;e.fromBufferAttribute(a,t);const o=this.morphTargetInfluences;if(i&&o){ds.set(0,0,0);for(let l=0,c=i.length;l<c;l++){const h=o[l],p=i[l];h!==0&&(aa.fromBufferAttribute(p,t),r?ds.addScaledVector(aa,h):ds.addScaledVector(aa.sub(e),h))}e.add(ds)}return e}raycast(t,e){const n=this.geometry,a=this.material,i=this.matrixWorld;a!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),cs.copy(n.boundingSphere),cs.applyMatrix4(i),Kn.copy(t.ray).recast(t.near),!(cs.containsPoint(Kn.origin)===!1&&(Kn.intersectSphere(cs,zo)===null||Kn.origin.distanceToSquared(zo)>(t.far-t.near)**2))&&(vo.copy(i).invert(),Kn.copy(t.ray).applyMatrix4(vo),!(n.boundingBox!==null&&Kn.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(t,e,Kn)))}_computeIntersections(t,e,n){let a;const i=this.geometry,r=this.material,o=i.index,l=i.attributes.position,c=i.attributes.uv,h=i.attributes.uv1,p=i.attributes.normal,u=i.groups,b=i.drawRange;if(o!==null)if(Array.isArray(r))for(let x=0,y=u.length;x<y;x++){const m=u[x],d=r[m.materialIndex],Z=Math.max(m.start,b.start),L=Math.min(o.count,Math.min(m.start+m.count,b.start+b.count));for(let T=Z,g=L;T<g;T+=3){const v=o.getX(T),N=o.getX(T+1),K=o.getX(T+2);a=fs(this,d,t,n,c,h,p,v,N,K),a&&(a.faceIndex=Math.floor(T/3),a.face.materialIndex=m.materialIndex,e.push(a))}}else{const x=Math.max(0,b.start),y=Math.min(o.count,b.start+b.count);for(let m=x,d=y;m<d;m+=3){const Z=o.getX(m),L=o.getX(m+1),T=o.getX(m+2);a=fs(this,r,t,n,c,h,p,Z,L,T),a&&(a.faceIndex=Math.floor(m/3),e.push(a))}}else if(l!==void 0)if(Array.isArray(r))for(let x=0,y=u.length;x<y;x++){const m=u[x],d=r[m.materialIndex],Z=Math.max(m.start,b.start),L=Math.min(l.count,Math.min(m.start+m.count,b.start+b.count));for(let T=Z,g=L;T<g;T+=3){const v=T,N=T+1,K=T+2;a=fs(this,d,t,n,c,h,p,v,N,K),a&&(a.faceIndex=Math.floor(T/3),a.face.materialIndex=m.materialIndex,e.push(a))}}else{const x=Math.max(0,b.start),y=Math.min(l.count,b.start+b.count);for(let m=x,d=y;m<d;m+=3){const Z=m,L=m+1,T=m+2;a=fs(this,r,t,n,c,h,p,Z,L,T),a&&(a.faceIndex=Math.floor(m/3),e.push(a))}}}}function vc(s,t,e,n,a,i,r,o){let l;if(t.side===Ne?l=n.intersectTriangle(r,i,a,!0,o):l=n.intersectTriangle(a,i,r,t.side===zn,o),l===null)return null;bs.copy(o),bs.applyMatrix4(s.matrixWorld);const c=e.ray.origin.distanceTo(bs);return c<e.near||c>e.far?null:{distance:c,point:bs.clone(),object:s}}function fs(s,t,e,n,a,i,r,o,l,c){s.getVertexPosition(o,hi),s.getVertexPosition(l,ui),s.getVertexPosition(c,pi);const h=vc(s,t,e,n,hi,ui,pi,ms);if(h){a&&(hs.fromBufferAttribute(a,o),us.fromBufferAttribute(a,l),ps.fromBufferAttribute(a,c),h.uv=Qe.getInterpolation(ms,hi,ui,pi,hs,us,ps,new Kt)),i&&(hs.fromBufferAttribute(i,o),us.fromBufferAttribute(i,l),ps.fromBufferAttribute(i,c),h.uv1=Qe.getInterpolation(ms,hi,ui,pi,hs,us,ps,new Kt),h.uv2=h.uv1),r&&(No.fromBufferAttribute(r,o),Io.fromBufferAttribute(r,l),Vo.fromBufferAttribute(r,c),h.normal=Qe.getInterpolation(ms,hi,ui,pi,No,Io,Vo,new V),h.normal.dot(n.direction)>0&&h.normal.multiplyScalar(-1));const p={a:o,b:l,c,normal:new V,materialIndex:0};Qe.getNormal(hi,ui,pi,p.normal),h.face=p}return h}class Ui extends Ln{constructor(t=1,e=1,n=1,a=1,i=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:a,heightSegments:i,depthSegments:r};const o=this;a=Math.floor(a),i=Math.floor(i),r=Math.floor(r);const l=[],c=[],h=[],p=[];let u=0,b=0;x("z","y","x",-1,-1,n,e,t,r,i,0),x("z","y","x",1,-1,n,e,-t,r,i,1),x("x","z","y",1,1,t,n,e,a,r,2),x("x","z","y",1,-1,t,n,-e,a,r,3),x("x","y","z",1,-1,t,e,n,a,i,4),x("x","y","z",-1,-1,t,e,-n,a,i,5),this.setIndex(l),this.setAttribute("position",new Ye(c,3)),this.setAttribute("normal",new Ye(h,3)),this.setAttribute("uv",new Ye(p,2));function x(y,m,d,Z,L,T,g,v,N,K,G){const W=T/N,Q=g/K,$=T/2,Y=g/2,U=v/2,A=N+1,nt=K+1;let j=0,q=0;const lt=new V;for(let et=0;et<nt;et++){const St=et*Q-Y;for(let F=0;F<A;F++){const st=F*W-$;lt[y]=st*Z,lt[m]=St*L,lt[d]=U,c.push(lt.x,lt.y,lt.z),lt[y]=0,lt[m]=0,lt[d]=v>0?1:-1,h.push(lt.x,lt.y,lt.z),p.push(F/N),p.push(1-et/K),j+=1}}for(let et=0;et<K;et++)for(let St=0;St<N;St++){const F=u+St+A*et,st=u+St+A*(et+1),at=u+(St+1)+A*(et+1),ft=u+(St+1)+A*et;l.push(F,st,ft),l.push(st,at,ft),q+=6}o.addGroup(b,q,G),b+=q,u+=j}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ui(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function gi(s){const t={};for(const e in s){t[e]={};for(const n in s[e]){const a=s[e][n];a&&(a.isColor||a.isMatrix3||a.isMatrix4||a.isVector2||a.isVector3||a.isVector4||a.isTexture||a.isQuaternion)?a.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][n]=null):t[e][n]=a.clone():Array.isArray(a)?t[e][n]=a.slice():t[e][n]=a}}return t}function Ce(s){const t={};for(let e=0;e<s.length;e++){const n=gi(s[e]);for(const a in n)t[a]=n[a]}return t}function zc(s){const t=[];for(let e=0;e<s.length;e++)t.push(s[e].clone());return t}function Fr(s){return s.getRenderTarget()===null?s.outputColorSpace:on}const Nc={clone:gi,merge:Ce};var Ic=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Vc=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class An extends _i{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=Ic,this.fragmentShader=Vc,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=gi(t.uniforms),this.uniformsGroups=zc(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const a in this.uniforms){const r=this.uniforms[a].value;r&&r.isTexture?e.uniforms[a]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[a]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[a]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[a]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[a]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[a]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[a]={type:"m4",value:r.toArray()}:e.uniforms[a]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const a in this.extensions)this.extensions[a]===!0&&(n[a]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class _r extends Ze{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new me,this.projectionMatrix=new me,this.projectionMatrixInverse=new me,this.coordinateSystem=Gn}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class qe extends _r{constructor(t=50,e=1,n=.1,a=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=a,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=La*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(_s*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return La*2*Math.atan(Math.tan(_s*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,a,i,r){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=a,this.view.width=i,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(_s*.5*this.fov)/this.zoom,n=2*e,a=this.aspect*n,i=-.5*a;const r=this.view;if(this.view!==null&&this.view.enabled){const l=r.fullWidth,c=r.fullHeight;i+=r.offsetX*a/l,e-=r.offsetY*n/c,a*=r.width/l,n*=r.height/c}const o=this.filmOffset;o!==0&&(i+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+a,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const mi=-90,bi=1;class Kc extends Ze{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null;const a=new qe(mi,bi,t,e);a.layers=this.layers,this.add(a);const i=new qe(mi,bi,t,e);i.layers=this.layers,this.add(i);const r=new qe(mi,bi,t,e);r.layers=this.layers,this.add(r);const o=new qe(mi,bi,t,e);o.layers=this.layers,this.add(o);const l=new qe(mi,bi,t,e);l.layers=this.layers,this.add(l);const c=new qe(mi,bi,t,e);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,a,i,r,o,l]=e;for(const c of e)this.remove(c);if(t===Gn)n.up.set(0,1,0),n.lookAt(1,0,0),a.up.set(0,1,0),a.lookAt(-1,0,0),i.up.set(0,0,-1),i.lookAt(0,1,0),r.up.set(0,0,1),r.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(t===Ss)n.up.set(0,-1,0),n.lookAt(-1,0,0),a.up.set(0,-1,0),a.lookAt(1,0,0),i.up.set(0,0,1),i.lookAt(0,1,0),r.up.set(0,0,-1),r.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);for(const c of e)this.add(c),c.updateMatrixWorld()}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[a,i,r,o,l,c]=this.children,h=t.getRenderTarget(),p=t.toneMapping,u=t.xr.enabled;t.toneMapping=Xn,t.xr.enabled=!1;const b=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,a),t.setRenderTarget(n,1),t.render(e,i),t.setRenderTarget(n,2),t.render(e,r),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,l),n.texture.generateMipmaps=b,t.setRenderTarget(n,5),t.render(e,c),t.setRenderTarget(h),t.toneMapping=p,t.xr.enabled=u,n.texture.needsPMREMUpdate=!0}}class Ur extends Pe{constructor(t,e,n,a,i,r,o,l,c,h){t=t!==void 0?t:[],e=e!==void 0?e:Xi,super(t,e,n,a,i,r,o,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class wc extends kn{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},a=[n,n,n,n,n,n];e.encoding!==void 0&&(Pi("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),e.colorSpace=e.encoding===_n?Ut:Un),this.texture=new Ur(a,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Ue}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},a=new Ui(5,5,5),i=new An({name:"CubemapFromEquirect",uniforms:gi(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Ne,blending:Cn});i.uniforms.tEquirect.value=e;const r=new sn(a,i),o=e.minFilter;return e.minFilter===Yi&&(e.minFilter=Ue),new Kc(1,10,this).update(t,r),e.minFilter=o,r.geometry.dispose(),r.material.dispose(),this}clear(t,e,n,a){const i=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,a);t.setRenderTarget(i)}}const oa=new V,Ec=new V,Pc=new Jt;class En{constructor(t=new V(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,a){return this.normal.set(t,e,n),this.constant=a,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const a=oa.subVectors(n,e).cross(Ec.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(a,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(oa),a=this.normal.dot(n);if(a===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const i=-(t.start.dot(this.normal)+this.constant)/a;return i<0||i>1?null:e.copy(t.start).addScaledVector(n,i)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||Pc.getNormalMatrix(t),a=this.coplanarPoint(oa).applyMatrix4(t),i=this.normal.applyMatrix3(n).normalize();return this.constant=-a.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const wn=new Ca,ys=new V;class za{constructor(t=new En,e=new En,n=new En,a=new En,i=new En,r=new En){this.planes=[t,e,n,a,i,r]}set(t,e,n,a,i,r){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(a),o[4].copy(i),o[5].copy(r),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=Gn){const n=this.planes,a=t.elements,i=a[0],r=a[1],o=a[2],l=a[3],c=a[4],h=a[5],p=a[6],u=a[7],b=a[8],x=a[9],y=a[10],m=a[11],d=a[12],Z=a[13],L=a[14],T=a[15];if(n[0].setComponents(l-i,u-c,m-b,T-d).normalize(),n[1].setComponents(l+i,u+c,m+b,T+d).normalize(),n[2].setComponents(l+r,u+h,m+x,T+Z).normalize(),n[3].setComponents(l-r,u-h,m-x,T-Z).normalize(),n[4].setComponents(l-o,u-p,m-y,T-L).normalize(),e===Gn)n[5].setComponents(l+o,u+p,m+y,T+L).normalize();else if(e===Ss)n[5].setComponents(o,p,y,L).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),wn.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),wn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(wn)}intersectsSprite(t){return wn.center.set(0,0,0),wn.radius=.7071067811865476,wn.applyMatrix4(t.matrixWorld),this.intersectsSphere(wn)}intersectsSphere(t){const e=this.planes,n=t.center,a=-t.radius;for(let i=0;i<6;i++)if(e[i].distanceToPoint(n)<a)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const a=e[n];if(ys.x=a.normal.x>0?t.max.x:t.min.x,ys.y=a.normal.y>0?t.max.y:t.min.y,ys.z=a.normal.z>0?t.max.z:t.min.z,a.distanceToPoint(ys)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function kr(){let s=null,t=!1,e=null,n=null;function a(i,r){e(i,r),n=s.requestAnimationFrame(a)}return{start:function(){t!==!0&&e!==null&&(n=s.requestAnimationFrame(a),t=!0)},stop:function(){s.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(i){e=i},setContext:function(i){s=i}}}function Yc(s,t){const e=t.isWebGL2,n=new WeakMap;function a(c,h){const p=c.array,u=c.usage,b=s.createBuffer();s.bindBuffer(h,b),s.bufferData(h,p,u),c.onUploadCallback();let x;if(p instanceof Float32Array)x=s.FLOAT;else if(p instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(e)x=s.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else x=s.UNSIGNED_SHORT;else if(p instanceof Int16Array)x=s.SHORT;else if(p instanceof Uint32Array)x=s.UNSIGNED_INT;else if(p instanceof Int32Array)x=s.INT;else if(p instanceof Int8Array)x=s.BYTE;else if(p instanceof Uint8Array)x=s.UNSIGNED_BYTE;else if(p instanceof Uint8ClampedArray)x=s.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+p);return{buffer:b,type:x,bytesPerElement:p.BYTES_PER_ELEMENT,version:c.version}}function i(c,h,p){const u=h.array,b=h.updateRange;s.bindBuffer(p,c),b.count===-1?s.bufferSubData(p,0,u):(e?s.bufferSubData(p,b.offset*u.BYTES_PER_ELEMENT,u,b.offset,b.count):s.bufferSubData(p,b.offset*u.BYTES_PER_ELEMENT,u.subarray(b.offset,b.offset+b.count)),b.count=-1),h.onUploadCallback()}function r(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h&&(s.deleteBuffer(h.buffer),n.delete(c))}function l(c,h){if(c.isGLBufferAttribute){const u=n.get(c);(!u||u.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const p=n.get(c);p===void 0?n.set(c,a(c,h)):p.version<c.version&&(i(p.buffer,c,h),p.version=c.version)}return{get:r,remove:o,update:l}}class Na extends Ln{constructor(t=1,e=1,n=1,a=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:a};const i=t/2,r=e/2,o=Math.floor(n),l=Math.floor(a),c=o+1,h=l+1,p=t/o,u=e/l,b=[],x=[],y=[],m=[];for(let d=0;d<h;d++){const Z=d*u-r;for(let L=0;L<c;L++){const T=L*p-i;x.push(T,-Z,0),y.push(0,0,1),m.push(L/o),m.push(1-d/l)}}for(let d=0;d<l;d++)for(let Z=0;Z<o;Z++){const L=Z+c*d,T=Z+c*(d+1),g=Z+1+c*(d+1),v=Z+1+c*d;b.push(L,T,v),b.push(T,g,v)}this.setIndex(b),this.setAttribute("position",new Ye(x,3)),this.setAttribute("normal",new Ye(y,3)),this.setAttribute("uv",new Ye(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Na(t.width,t.height,t.widthSegments,t.heightSegments)}}var Hc=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,Fc=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,_c=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,Uc=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,kc=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,Dc=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Ac="vec3 transformed = vec3( position );",Jc=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Bc=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,Oc=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,jc=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Qc=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,qc=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,$c=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,td=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,ed=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,nd=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,id=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,sd=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,ad=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,od=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,rd=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,ld=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,cd=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,dd=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,hd=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,ud="gl_FragColor = linearToOutputTexel( gl_FragColor );",pd=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,md=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,bd=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,fd=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,yd=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Md=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,xd=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Gd=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Xd=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Ld=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Sd=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,gd=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Td=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Zd=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Rd=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Wd=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Cd=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,vd=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,zd=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Nd=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Id=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,Vd=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,Kd=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,wd=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,Ed=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Pd=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Yd=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Hd=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Fd=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,_d=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Ud=`#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,kd=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Dd=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Ad=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Jd=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Bd=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Od=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,jd=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,Qd=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,qd=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,$d=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,th=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,eh=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,nh=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,ih=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,sh=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,ah=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,oh=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,rh=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,lh=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,ch=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,dh=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,hh=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,uh=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,ph=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,mh=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,bh=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,fh=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,yh=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Mh=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,xh=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,Gh=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Xh=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Lh=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,Sh=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,gh=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Th=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Zh=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Rh=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Wh=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Ch=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,vh=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,zh=`#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Nh=`#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Ih=`#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,Vh=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Kh=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,wh=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Eh=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Ph=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Yh=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Hh=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Fh=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,_h=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Uh=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,kh=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Dh=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Ah=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Jh=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Bh=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Oh=`#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,jh=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Qh=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,qh=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,$h=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,tu=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,eu=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,nu=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,iu=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,su=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,au=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,ou=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ru=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,lu=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,cu=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,du=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,hu=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,uu=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,pu=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,mu=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,At={alphamap_fragment:Hc,alphamap_pars_fragment:Fc,alphatest_fragment:_c,alphatest_pars_fragment:Uc,aomap_fragment:kc,aomap_pars_fragment:Dc,begin_vertex:Ac,beginnormal_vertex:Jc,bsdfs:Bc,iridescence_fragment:Oc,bumpmap_pars_fragment:jc,clipping_planes_fragment:Qc,clipping_planes_pars_fragment:qc,clipping_planes_pars_vertex:$c,clipping_planes_vertex:td,color_fragment:ed,color_pars_fragment:nd,color_pars_vertex:id,color_vertex:sd,common:ad,cube_uv_reflection_fragment:od,defaultnormal_vertex:rd,displacementmap_pars_vertex:ld,displacementmap_vertex:cd,emissivemap_fragment:dd,emissivemap_pars_fragment:hd,encodings_fragment:ud,encodings_pars_fragment:pd,envmap_fragment:md,envmap_common_pars_fragment:bd,envmap_pars_fragment:fd,envmap_pars_vertex:yd,envmap_physical_pars_fragment:Cd,envmap_vertex:Md,fog_vertex:xd,fog_pars_vertex:Gd,fog_fragment:Xd,fog_pars_fragment:Ld,gradientmap_pars_fragment:Sd,lightmap_fragment:gd,lightmap_pars_fragment:Td,lights_lambert_fragment:Zd,lights_lambert_pars_fragment:Rd,lights_pars_begin:Wd,lights_toon_fragment:vd,lights_toon_pars_fragment:zd,lights_phong_fragment:Nd,lights_phong_pars_fragment:Id,lights_physical_fragment:Vd,lights_physical_pars_fragment:Kd,lights_fragment_begin:wd,lights_fragment_maps:Ed,lights_fragment_end:Pd,logdepthbuf_fragment:Yd,logdepthbuf_pars_fragment:Hd,logdepthbuf_pars_vertex:Fd,logdepthbuf_vertex:_d,map_fragment:Ud,map_pars_fragment:kd,map_particle_fragment:Dd,map_particle_pars_fragment:Ad,metalnessmap_fragment:Jd,metalnessmap_pars_fragment:Bd,morphcolor_vertex:Od,morphnormal_vertex:jd,morphtarget_pars_vertex:Qd,morphtarget_vertex:qd,normal_fragment_begin:$d,normal_fragment_maps:th,normal_pars_fragment:eh,normal_pars_vertex:nh,normal_vertex:ih,normalmap_pars_fragment:sh,clearcoat_normal_fragment_begin:ah,clearcoat_normal_fragment_maps:oh,clearcoat_pars_fragment:rh,iridescence_pars_fragment:lh,output_fragment:ch,packing:dh,premultiplied_alpha_fragment:hh,project_vertex:uh,dithering_fragment:ph,dithering_pars_fragment:mh,roughnessmap_fragment:bh,roughnessmap_pars_fragment:fh,shadowmap_pars_fragment:yh,shadowmap_pars_vertex:Mh,shadowmap_vertex:xh,shadowmask_pars_fragment:Gh,skinbase_vertex:Xh,skinning_pars_vertex:Lh,skinning_vertex:Sh,skinnormal_vertex:gh,specularmap_fragment:Th,specularmap_pars_fragment:Zh,tonemapping_fragment:Rh,tonemapping_pars_fragment:Wh,transmission_fragment:Ch,transmission_pars_fragment:vh,uv_pars_fragment:zh,uv_pars_vertex:Nh,uv_vertex:Ih,worldpos_vertex:Vh,background_vert:Kh,background_frag:wh,backgroundCube_vert:Eh,backgroundCube_frag:Ph,cube_vert:Yh,cube_frag:Hh,depth_vert:Fh,depth_frag:_h,distanceRGBA_vert:Uh,distanceRGBA_frag:kh,equirect_vert:Dh,equirect_frag:Ah,linedashed_vert:Jh,linedashed_frag:Bh,meshbasic_vert:Oh,meshbasic_frag:jh,meshlambert_vert:Qh,meshlambert_frag:qh,meshmatcap_vert:$h,meshmatcap_frag:tu,meshnormal_vert:eu,meshnormal_frag:nu,meshphong_vert:iu,meshphong_frag:su,meshphysical_vert:au,meshphysical_frag:ou,meshtoon_vert:ru,meshtoon_frag:lu,points_vert:cu,points_frag:du,shadow_vert:hu,shadow_frag:uu,sprite_vert:pu,sprite_frag:mu},ut={common:{diffuse:{value:new $t(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Jt},alphaMap:{value:null},alphaMapTransform:{value:new Jt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Jt}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Jt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Jt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Jt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Jt},normalScale:{value:new Kt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Jt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Jt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Jt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Jt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new $t(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new $t(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Jt},alphaTest:{value:0},uvTransform:{value:new Jt}},sprite:{diffuse:{value:new $t(16777215)},opacity:{value:1},center:{value:new Kt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Jt},alphaMap:{value:null},alphaMapTransform:{value:new Jt},alphaTest:{value:0}}},en={basic:{uniforms:Ce([ut.common,ut.specularmap,ut.envmap,ut.aomap,ut.lightmap,ut.fog]),vertexShader:At.meshbasic_vert,fragmentShader:At.meshbasic_frag},lambert:{uniforms:Ce([ut.common,ut.specularmap,ut.envmap,ut.aomap,ut.lightmap,ut.emissivemap,ut.bumpmap,ut.normalmap,ut.displacementmap,ut.fog,ut.lights,{emissive:{value:new $t(0)}}]),vertexShader:At.meshlambert_vert,fragmentShader:At.meshlambert_frag},phong:{uniforms:Ce([ut.common,ut.specularmap,ut.envmap,ut.aomap,ut.lightmap,ut.emissivemap,ut.bumpmap,ut.normalmap,ut.displacementmap,ut.fog,ut.lights,{emissive:{value:new $t(0)},specular:{value:new $t(1118481)},shininess:{value:30}}]),vertexShader:At.meshphong_vert,fragmentShader:At.meshphong_frag},standard:{uniforms:Ce([ut.common,ut.envmap,ut.aomap,ut.lightmap,ut.emissivemap,ut.bumpmap,ut.normalmap,ut.displacementmap,ut.roughnessmap,ut.metalnessmap,ut.fog,ut.lights,{emissive:{value:new $t(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:At.meshphysical_vert,fragmentShader:At.meshphysical_frag},toon:{uniforms:Ce([ut.common,ut.aomap,ut.lightmap,ut.emissivemap,ut.bumpmap,ut.normalmap,ut.displacementmap,ut.gradientmap,ut.fog,ut.lights,{emissive:{value:new $t(0)}}]),vertexShader:At.meshtoon_vert,fragmentShader:At.meshtoon_frag},matcap:{uniforms:Ce([ut.common,ut.bumpmap,ut.normalmap,ut.displacementmap,ut.fog,{matcap:{value:null}}]),vertexShader:At.meshmatcap_vert,fragmentShader:At.meshmatcap_frag},points:{uniforms:Ce([ut.points,ut.fog]),vertexShader:At.points_vert,fragmentShader:At.points_frag},dashed:{uniforms:Ce([ut.common,ut.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:At.linedashed_vert,fragmentShader:At.linedashed_frag},depth:{uniforms:Ce([ut.common,ut.displacementmap]),vertexShader:At.depth_vert,fragmentShader:At.depth_frag},normal:{uniforms:Ce([ut.common,ut.bumpmap,ut.normalmap,ut.displacementmap,{opacity:{value:1}}]),vertexShader:At.meshnormal_vert,fragmentShader:At.meshnormal_frag},sprite:{uniforms:Ce([ut.sprite,ut.fog]),vertexShader:At.sprite_vert,fragmentShader:At.sprite_frag},background:{uniforms:{uvTransform:{value:new Jt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:At.background_vert,fragmentShader:At.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:At.backgroundCube_vert,fragmentShader:At.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:At.cube_vert,fragmentShader:At.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:At.equirect_vert,fragmentShader:At.equirect_frag},distanceRGBA:{uniforms:Ce([ut.common,ut.displacementmap,{referencePosition:{value:new V},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:At.distanceRGBA_vert,fragmentShader:At.distanceRGBA_frag},shadow:{uniforms:Ce([ut.lights,ut.fog,{color:{value:new $t(0)},opacity:{value:1}}]),vertexShader:At.shadow_vert,fragmentShader:At.shadow_frag}};en.physical={uniforms:Ce([en.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Jt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Jt},clearcoatNormalScale:{value:new Kt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Jt},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Jt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Jt},sheen:{value:0},sheenColor:{value:new $t(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Jt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Jt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Jt},transmissionSamplerSize:{value:new Kt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Jt},attenuationDistance:{value:0},attenuationColor:{value:new $t(0)},specularColor:{value:new $t(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Jt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Jt},anisotropyVector:{value:new Kt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Jt}}]),vertexShader:At.meshphysical_vert,fragmentShader:At.meshphysical_frag};const Ms={r:0,b:0,g:0};function bu(s,t,e,n,a,i,r){const o=new $t(0);let l=i===!0?0:1,c,h,p=null,u=0,b=null;function x(m,d){let Z=!1,L=d.isScene===!0?d.background:null;switch(L&&L.isTexture&&(L=(d.backgroundBlurriness>0?e:t).get(L)),L===null?y(o,l):L&&L.isColor&&(y(L,1),Z=!0),s.xr.getEnvironmentBlendMode()){case"opaque":Z=!0;break;case"additive":n.buffers.color.setClear(0,0,0,1,r),Z=!0;break;case"alpha-blend":n.buffers.color.setClear(0,0,0,0,r),Z=!0;break}(s.autoClear||Z)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),L&&(L.isCubeTexture||L.mapping===Zs)?(h===void 0&&(h=new sn(new Ui(1,1,1),new An({name:"BackgroundCubeMaterial",uniforms:gi(en.backgroundCube.uniforms),vertexShader:en.backgroundCube.vertexShader,fragmentShader:en.backgroundCube.fragmentShader,side:Ne,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(v,N,K){this.matrixWorld.copyPosition(K.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),a.update(h)),h.material.uniforms.envMap.value=L,h.material.uniforms.flipEnvMap.value=L.isCubeTexture&&L.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=d.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=d.backgroundIntensity,h.material.toneMapped=L.colorSpace!==Ut,(p!==L||u!==L.version||b!==s.toneMapping)&&(h.material.needsUpdate=!0,p=L,u=L.version,b=s.toneMapping),h.layers.enableAll(),m.unshift(h,h.geometry,h.material,0,0,null)):L&&L.isTexture&&(c===void 0&&(c=new sn(new Na(2,2),new An({name:"BackgroundMaterial",uniforms:gi(en.background.uniforms),vertexShader:en.background.vertexShader,fragmentShader:en.background.fragmentShader,side:zn,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),a.update(c)),c.material.uniforms.t2D.value=L,c.material.uniforms.backgroundIntensity.value=d.backgroundIntensity,c.material.toneMapped=L.colorSpace!==Ut,L.matrixAutoUpdate===!0&&L.updateMatrix(),c.material.uniforms.uvTransform.value.copy(L.matrix),(p!==L||u!==L.version||b!==s.toneMapping)&&(c.material.needsUpdate=!0,p=L,u=L.version,b=s.toneMapping),c.layers.enableAll(),m.unshift(c,c.geometry,c.material,0,0,null))}function y(m,d){m.getRGB(Ms,Fr(s)),n.buffers.color.setClear(Ms.r,Ms.g,Ms.b,d,r)}return{getClearColor:function(){return o},setClearColor:function(m,d=1){o.set(m),l=d,y(o,l)},getClearAlpha:function(){return l},setClearAlpha:function(m){l=m,y(o,l)},render:x}}function fu(s,t,e,n){const a=s.getParameter(s.MAX_VERTEX_ATTRIBS),i=n.isWebGL2?null:t.get("OES_vertex_array_object"),r=n.isWebGL2||i!==null,o={},l=m(null);let c=l,h=!1;function p(U,A,nt,j,q){let lt=!1;if(r){const et=y(j,nt,A);c!==et&&(c=et,b(c.object)),lt=d(U,j,nt,q),lt&&Z(U,j,nt,q)}else{const et=A.wireframe===!0;(c.geometry!==j.id||c.program!==nt.id||c.wireframe!==et)&&(c.geometry=j.id,c.program=nt.id,c.wireframe=et,lt=!0)}q!==null&&e.update(q,s.ELEMENT_ARRAY_BUFFER),(lt||h)&&(h=!1,K(U,A,nt,j),q!==null&&s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,e.get(q).buffer))}function u(){return n.isWebGL2?s.createVertexArray():i.createVertexArrayOES()}function b(U){return n.isWebGL2?s.bindVertexArray(U):i.bindVertexArrayOES(U)}function x(U){return n.isWebGL2?s.deleteVertexArray(U):i.deleteVertexArrayOES(U)}function y(U,A,nt){const j=nt.wireframe===!0;let q=o[U.id];q===void 0&&(q={},o[U.id]=q);let lt=q[A.id];lt===void 0&&(lt={},q[A.id]=lt);let et=lt[j];return et===void 0&&(et=m(u()),lt[j]=et),et}function m(U){const A=[],nt=[],j=[];for(let q=0;q<a;q++)A[q]=0,nt[q]=0,j[q]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:A,enabledAttributes:nt,attributeDivisors:j,object:U,attributes:{},index:null}}function d(U,A,nt,j){const q=c.attributes,lt=A.attributes;let et=0;const St=nt.getAttributes();for(const F in St)if(St[F].location>=0){const at=q[F];let ft=lt[F];if(ft===void 0&&(F==="instanceMatrix"&&U.instanceMatrix&&(ft=U.instanceMatrix),F==="instanceColor"&&U.instanceColor&&(ft=U.instanceColor)),at===void 0||at.attribute!==ft||ft&&at.data!==ft.data)return!0;et++}return c.attributesNum!==et||c.index!==j}function Z(U,A,nt,j){const q={},lt=A.attributes;let et=0;const St=nt.getAttributes();for(const F in St)if(St[F].location>=0){let at=lt[F];at===void 0&&(F==="instanceMatrix"&&U.instanceMatrix&&(at=U.instanceMatrix),F==="instanceColor"&&U.instanceColor&&(at=U.instanceColor));const ft={};ft.attribute=at,at&&at.data&&(ft.data=at.data),q[F]=ft,et++}c.attributes=q,c.attributesNum=et,c.index=j}function L(){const U=c.newAttributes;for(let A=0,nt=U.length;A<nt;A++)U[A]=0}function T(U){g(U,0)}function g(U,A){const nt=c.newAttributes,j=c.enabledAttributes,q=c.attributeDivisors;nt[U]=1,j[U]===0&&(s.enableVertexAttribArray(U),j[U]=1),q[U]!==A&&((n.isWebGL2?s:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](U,A),q[U]=A)}function v(){const U=c.newAttributes,A=c.enabledAttributes;for(let nt=0,j=A.length;nt<j;nt++)A[nt]!==U[nt]&&(s.disableVertexAttribArray(nt),A[nt]=0)}function N(U,A,nt,j,q,lt,et){et===!0?s.vertexAttribIPointer(U,A,nt,q,lt):s.vertexAttribPointer(U,A,nt,j,q,lt)}function K(U,A,nt,j){if(n.isWebGL2===!1&&(U.isInstancedMesh||j.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;L();const q=j.attributes,lt=nt.getAttributes(),et=A.defaultAttributeValues;for(const St in lt){const F=lt[St];if(F.location>=0){let st=q[St];if(st===void 0&&(St==="instanceMatrix"&&U.instanceMatrix&&(st=U.instanceMatrix),St==="instanceColor"&&U.instanceColor&&(st=U.instanceColor)),st!==void 0){const at=st.normalized,ft=st.itemSize,yt=e.get(st);if(yt===void 0)continue;const Ct=yt.buffer,Ht=yt.type,It=yt.bytesPerElement,ae=n.isWebGL2===!0&&(Ht===s.INT||Ht===s.UNSIGNED_INT||st.gpuType===gr);if(st.isInterleavedBufferAttribute){const kt=st.data,P=kt.stride,de=st.offset;if(kt.isInstancedInterleavedBuffer){for(let vt=0;vt<F.locationSize;vt++)g(F.location+vt,kt.meshPerAttribute);U.isInstancedMesh!==!0&&j._maxInstanceCount===void 0&&(j._maxInstanceCount=kt.meshPerAttribute*kt.count)}else for(let vt=0;vt<F.locationSize;vt++)T(F.location+vt);s.bindBuffer(s.ARRAY_BUFFER,Ct);for(let vt=0;vt<F.locationSize;vt++)N(F.location+vt,ft/F.locationSize,Ht,at,P*It,(de+ft/F.locationSize*vt)*It,ae)}else{if(st.isInstancedBufferAttribute){for(let kt=0;kt<F.locationSize;kt++)g(F.location+kt,st.meshPerAttribute);U.isInstancedMesh!==!0&&j._maxInstanceCount===void 0&&(j._maxInstanceCount=st.meshPerAttribute*st.count)}else for(let kt=0;kt<F.locationSize;kt++)T(F.location+kt);s.bindBuffer(s.ARRAY_BUFFER,Ct);for(let kt=0;kt<F.locationSize;kt++)N(F.location+kt,ft/F.locationSize,Ht,at,ft*It,ft/F.locationSize*kt*It,ae)}}else if(et!==void 0){const at=et[St];if(at!==void 0)switch(at.length){case 2:s.vertexAttrib2fv(F.location,at);break;case 3:s.vertexAttrib3fv(F.location,at);break;case 4:s.vertexAttrib4fv(F.location,at);break;default:s.vertexAttrib1fv(F.location,at)}}}}v()}function G(){$();for(const U in o){const A=o[U];for(const nt in A){const j=A[nt];for(const q in j)x(j[q].object),delete j[q];delete A[nt]}delete o[U]}}function W(U){if(o[U.id]===void 0)return;const A=o[U.id];for(const nt in A){const j=A[nt];for(const q in j)x(j[q].object),delete j[q];delete A[nt]}delete o[U.id]}function Q(U){for(const A in o){const nt=o[A];if(nt[U.id]===void 0)continue;const j=nt[U.id];for(const q in j)x(j[q].object),delete j[q];delete nt[U.id]}}function $(){Y(),h=!0,c!==l&&(c=l,b(c.object))}function Y(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:p,reset:$,resetDefaultState:Y,dispose:G,releaseStatesOfGeometry:W,releaseStatesOfProgram:Q,initAttributes:L,enableAttribute:T,disableUnusedAttributes:v}}function yu(s,t,e,n){const a=n.isWebGL2;let i;function r(c){i=c}function o(c,h){s.drawArrays(i,c,h),e.update(h,i,1)}function l(c,h,p){if(p===0)return;let u,b;if(a)u=s,b="drawArraysInstanced";else if(u=t.get("ANGLE_instanced_arrays"),b="drawArraysInstancedANGLE",u===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}u[b](i,c,h,p),e.update(h,i,p)}this.setMode=r,this.render=o,this.renderInstances=l}function Mu(s,t,e){let n;function a(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const N=t.get("EXT_texture_filter_anisotropic");n=s.getParameter(N.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function i(N){if(N==="highp"){if(s.getShaderPrecisionFormat(s.VERTEX_SHADER,s.HIGH_FLOAT).precision>0&&s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision>0)return"highp";N="mediump"}return N==="mediump"&&s.getShaderPrecisionFormat(s.VERTEX_SHADER,s.MEDIUM_FLOAT).precision>0&&s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const r=typeof WebGL2RenderingContext<"u"&&s.constructor.name==="WebGL2RenderingContext";let o=e.precision!==void 0?e.precision:"highp";const l=i(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=r||t.has("WEBGL_draw_buffers"),h=e.logarithmicDepthBuffer===!0,p=s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),u=s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),b=s.getParameter(s.MAX_TEXTURE_SIZE),x=s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),y=s.getParameter(s.MAX_VERTEX_ATTRIBS),m=s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),d=s.getParameter(s.MAX_VARYING_VECTORS),Z=s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),L=u>0,T=r||t.has("OES_texture_float"),g=L&&T,v=r?s.getParameter(s.MAX_SAMPLES):0;return{isWebGL2:r,drawBuffers:c,getMaxAnisotropy:a,getMaxPrecision:i,precision:o,logarithmicDepthBuffer:h,maxTextures:p,maxVertexTextures:u,maxTextureSize:b,maxCubemapSize:x,maxAttributes:y,maxVertexUniforms:m,maxVaryings:d,maxFragmentUniforms:Z,vertexTextures:L,floatFragmentTextures:T,floatVertexTextures:g,maxSamples:v}}function xu(s){const t=this;let e=null,n=0,a=!1,i=!1;const r=new En,o=new Jt,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(p,u){const b=p.length!==0||u||n!==0||a;return a=u,n=p.length,b},this.beginShadows=function(){i=!0,h(null)},this.endShadows=function(){i=!1},this.setGlobalState=function(p,u){e=h(p,u,0)},this.setState=function(p,u,b){const x=p.clippingPlanes,y=p.clipIntersection,m=p.clipShadows,d=s.get(p);if(!a||x===null||x.length===0||i&&!m)i?h(null):c();else{const Z=i?0:n,L=Z*4;let T=d.clippingState||null;l.value=T,T=h(x,u,L,b);for(let g=0;g!==L;++g)T[g]=e[g];d.clippingState=T,this.numIntersection=y?this.numPlanes:0,this.numPlanes+=Z}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function h(p,u,b,x){const y=p!==null?p.length:0;let m=null;if(y!==0){if(m=l.value,x!==!0||m===null){const d=b+y*4,Z=u.matrixWorldInverse;o.getNormalMatrix(Z),(m===null||m.length<d)&&(m=new Float32Array(d));for(let L=0,T=b;L!==y;++L,T+=4)r.copy(p[L]).applyMatrix4(Z,o),r.normal.toArray(m,T),m[T+3]=r.constant}l.value=m,l.needsUpdate=!0}return t.numPlanes=y,t.numIntersection=0,m}}function Gu(s){let t=new WeakMap;function e(r,o){return o===ya?r.mapping=Xi:o===Ma&&(r.mapping=Li),r}function n(r){if(r&&r.isTexture&&r.isRenderTargetTexture===!1){const o=r.mapping;if(o===ya||o===Ma)if(t.has(r)){const l=t.get(r).texture;return e(l,r.mapping)}else{const l=r.image;if(l&&l.height>0){const c=new wc(l.height/2);return c.fromEquirectangularTexture(s,r),t.set(r,c),r.addEventListener("dispose",a),e(c.texture,r.mapping)}else return null}}return r}function a(r){const o=r.target;o.removeEventListener("dispose",a);const l=t.get(o);l!==void 0&&(t.delete(o),l.dispose())}function i(){t=new WeakMap}return{get:n,dispose:i}}class Ia extends _r{constructor(t=-1,e=1,n=1,a=-1,i=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=a,this.near=i,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,a,i,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=a,this.view.width=i,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,a=(this.top+this.bottom)/2;let i=n-t,r=n+t,o=a+e,l=a-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=c*this.view.offsetX,r=i+c*this.view.width,o-=h*this.view.offsetY,l=o-h*this.view.height}this.projectionMatrix.makeOrthographic(i,r,o,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const Mi=4,Ko=[.125,.215,.35,.446,.526,.582],Yn=20,ra=new Ia,wo=new $t;let la=null;const Pn=(1+Math.sqrt(5))/2,fi=1/Pn,Eo=[new V(1,1,1),new V(-1,1,1),new V(1,1,-1),new V(-1,1,-1),new V(0,Pn,fi),new V(0,Pn,-fi),new V(fi,0,Pn),new V(-fi,0,Pn),new V(Pn,fi,0),new V(-Pn,fi,0)];class Po{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,a=100){la=this._renderer.getRenderTarget(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(t,n,a,i),e>0&&this._blur(i,0,0,e),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Fo(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=Ho(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(la),t.scissorTest=!1,xs(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===Xi||t.mapping===Li?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),la=this._renderer.getRenderTarget();const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:Ue,minFilter:Ue,generateMipmaps:!1,type:Hi,format:tn,colorSpace:on,depthBuffer:!1},a=Yo(t,e,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=Yo(t,e,n);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Xu(i)),this._blurMaterial=Lu(i,t,e)}return a}_compileMaterial(t){const e=new sn(this._lodPlanes[0],t);this._renderer.compile(e,ra)}_sceneToCubeUV(t,e,n,a){const o=new qe(90,1,e,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,p=h.autoClear,u=h.toneMapping;h.getClearColor(wo),h.toneMapping=Xn,h.autoClear=!1;const b=new va({name:"PMREM.Background",side:Ne,depthWrite:!1,depthTest:!1}),x=new sn(new Ui,b);let y=!1;const m=t.background;m?m.isColor&&(b.color.copy(m),t.background=null,y=!0):(b.color.copy(wo),y=!0);for(let d=0;d<6;d++){const Z=d%3;Z===0?(o.up.set(0,l[d],0),o.lookAt(c[d],0,0)):Z===1?(o.up.set(0,0,l[d]),o.lookAt(0,c[d],0)):(o.up.set(0,l[d],0),o.lookAt(0,0,c[d]));const L=this._cubeSize;xs(a,Z*L,d>2?L:0,L,L),h.setRenderTarget(a),y&&h.render(x,o),h.render(t,o)}x.geometry.dispose(),x.material.dispose(),h.toneMapping=u,h.autoClear=p,t.background=m}_textureToCubeUV(t,e){const n=this._renderer,a=t.mapping===Xi||t.mapping===Li;a?(this._cubemapMaterial===null&&(this._cubemapMaterial=Fo()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=Ho());const i=a?this._cubemapMaterial:this._equirectMaterial,r=new sn(this._lodPlanes[0],i),o=i.uniforms;o.envMap.value=t;const l=this._cubeSize;xs(e,0,0,3*l,2*l),n.setRenderTarget(e),n.render(r,ra)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let a=1;a<this._lodPlanes.length;a++){const i=Math.sqrt(this._sigmas[a]*this._sigmas[a]-this._sigmas[a-1]*this._sigmas[a-1]),r=Eo[(a-1)%Eo.length];this._blur(t,a-1,a,i,r)}e.autoClear=n}_blur(t,e,n,a,i){const r=this._pingPongRenderTarget;this._halfBlur(t,r,e,n,a,"latitudinal",i),this._halfBlur(r,t,n,n,a,"longitudinal",i)}_halfBlur(t,e,n,a,i,r,o){const l=this._renderer,c=this._blurMaterial;r!=="latitudinal"&&r!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,p=new sn(this._lodPlanes[a],c),u=c.uniforms,b=this._sizeLods[n]-1,x=isFinite(i)?Math.PI/(2*b):2*Math.PI/(2*Yn-1),y=i/x,m=isFinite(i)?1+Math.floor(h*y):Yn;m>Yn&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Yn}`);const d=[];let Z=0;for(let N=0;N<Yn;++N){const K=N/y,G=Math.exp(-K*K/2);d.push(G),N===0?Z+=G:N<m&&(Z+=2*G)}for(let N=0;N<d.length;N++)d[N]=d[N]/Z;u.envMap.value=t.texture,u.samples.value=m,u.weights.value=d,u.latitudinal.value=r==="latitudinal",o&&(u.poleAxis.value=o);const{_lodMax:L}=this;u.dTheta.value=x,u.mipInt.value=L-n;const T=this._sizeLods[a],g=3*T*(a>L-Mi?a-L+Mi:0),v=4*(this._cubeSize-T);xs(e,g,v,3*T,2*T),l.setRenderTarget(e),l.render(p,ra)}}function Xu(s){const t=[],e=[],n=[];let a=s;const i=s-Mi+1+Ko.length;for(let r=0;r<i;r++){const o=Math.pow(2,a);e.push(o);let l=1/o;r>s-Mi?l=Ko[r-s+Mi-1]:r===0&&(l=0),n.push(l);const c=1/(o-2),h=-c,p=1+c,u=[h,h,p,h,p,p,h,h,p,p,h,p],b=6,x=6,y=3,m=2,d=1,Z=new Float32Array(y*x*b),L=new Float32Array(m*x*b),T=new Float32Array(d*x*b);for(let v=0;v<b;v++){const N=v%3*2/3-1,K=v>2?0:-1,G=[N,K,0,N+2/3,K,0,N+2/3,K+1,0,N,K,0,N+2/3,K+1,0,N,K+1,0];Z.set(G,y*x*v),L.set(u,m*x*v);const W=[v,v,v,v,v,v];T.set(W,d*x*v)}const g=new Ln;g.setAttribute("position",new an(Z,y)),g.setAttribute("uv",new an(L,m)),g.setAttribute("faceIndex",new an(T,d)),t.push(g),a>Mi&&a--}return{lodPlanes:t,sizeLods:e,sigmas:n}}function Yo(s,t,e){const n=new kn(s,t,e);return n.texture.mapping=Zs,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function xs(s,t,e,n,a){s.viewport.set(t,e,n,a),s.scissor.set(t,e,n,a)}function Lu(s,t,e){const n=new Float32Array(Yn),a=new V(0,1,0);return new An({name:"SphericalGaussianBlur",defines:{n:Yn,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:a}},vertexShader:Va(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Cn,depthTest:!1,depthWrite:!1})}function Ho(){return new An({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Va(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Cn,depthTest:!1,depthWrite:!1})}function Fo(){return new An({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Va(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Cn,depthTest:!1,depthWrite:!1})}function Va(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Su(s){let t=new WeakMap,e=null;function n(o){if(o&&o.isTexture){const l=o.mapping,c=l===ya||l===Ma,h=l===Xi||l===Li;if(c||h)if(o.isRenderTargetTexture&&o.needsPMREMUpdate===!0){o.needsPMREMUpdate=!1;let p=t.get(o);return e===null&&(e=new Po(s)),p=c?e.fromEquirectangular(o,p):e.fromCubemap(o,p),t.set(o,p),p.texture}else{if(t.has(o))return t.get(o).texture;{const p=o.image;if(c&&p&&p.height>0||h&&p&&a(p)){e===null&&(e=new Po(s));const u=c?e.fromEquirectangular(o):e.fromCubemap(o);return t.set(o,u),o.addEventListener("dispose",i),u.texture}else return null}}}return o}function a(o){let l=0;const c=6;for(let h=0;h<c;h++)o[h]!==void 0&&l++;return l===c}function i(o){const l=o.target;l.removeEventListener("dispose",i);const c=t.get(l);c!==void 0&&(t.delete(l),c.dispose())}function r(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:r}}function gu(s){const t={};function e(n){if(t[n]!==void 0)return t[n];let a;switch(n){case"WEBGL_depth_texture":a=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":a=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":a=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":a=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:a=s.getExtension(n)}return t[n]=a,a}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(n){const a=e(n);return a===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),a}}}function Tu(s,t,e,n){const a={},i=new WeakMap;function r(p){const u=p.target;u.index!==null&&t.remove(u.index);for(const x in u.attributes)t.remove(u.attributes[x]);for(const x in u.morphAttributes){const y=u.morphAttributes[x];for(let m=0,d=y.length;m<d;m++)t.remove(y[m])}u.removeEventListener("dispose",r),delete a[u.id];const b=i.get(u);b&&(t.remove(b),i.delete(u)),n.releaseStatesOfGeometry(u),u.isInstancedBufferGeometry===!0&&delete u._maxInstanceCount,e.memory.geometries--}function o(p,u){return a[u.id]===!0||(u.addEventListener("dispose",r),a[u.id]=!0,e.memory.geometries++),u}function l(p){const u=p.attributes;for(const x in u)t.update(u[x],s.ARRAY_BUFFER);const b=p.morphAttributes;for(const x in b){const y=b[x];for(let m=0,d=y.length;m<d;m++)t.update(y[m],s.ARRAY_BUFFER)}}function c(p){const u=[],b=p.index,x=p.attributes.position;let y=0;if(b!==null){const Z=b.array;y=b.version;for(let L=0,T=Z.length;L<T;L+=3){const g=Z[L+0],v=Z[L+1],N=Z[L+2];u.push(g,v,v,N,N,g)}}else{const Z=x.array;y=x.version;for(let L=0,T=Z.length/3-1;L<T;L+=3){const g=L+0,v=L+1,N=L+2;u.push(g,v,v,N,N,g)}}const m=new(Ir(u)?Hr:Yr)(u,1);m.version=y;const d=i.get(p);d&&t.remove(d),i.set(p,m)}function h(p){const u=i.get(p);if(u){const b=p.index;b!==null&&u.version<b.version&&c(p)}else c(p);return i.get(p)}return{get:o,update:l,getWireframeAttribute:h}}function Zu(s,t,e,n){const a=n.isWebGL2;let i;function r(u){i=u}let o,l;function c(u){o=u.type,l=u.bytesPerElement}function h(u,b){s.drawElements(i,b,o,u*l),e.update(b,i,1)}function p(u,b,x){if(x===0)return;let y,m;if(a)y=s,m="drawElementsInstanced";else if(y=t.get("ANGLE_instanced_arrays"),m="drawElementsInstancedANGLE",y===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}y[m](i,b,o,u*l,x),e.update(b,i,x)}this.setMode=r,this.setIndex=c,this.render=h,this.renderInstances=p}function Ru(s){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(i,r,o){switch(e.calls++,r){case s.TRIANGLES:e.triangles+=o*(i/3);break;case s.LINES:e.lines+=o*(i/2);break;case s.LINE_STRIP:e.lines+=o*(i-1);break;case s.LINE_LOOP:e.lines+=o*i;break;case s.POINTS:e.points+=o*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r);break}}function a(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:a,update:n}}function Wu(s,t){return s[0]-t[0]}function Cu(s,t){return Math.abs(t[1])-Math.abs(s[1])}function vu(s,t,e){const n={},a=new Float32Array(8),i=new WeakMap,r=new Ge,o=[];for(let c=0;c<8;c++)o[c]=[c,0];function l(c,h,p){const u=c.morphTargetInfluences;if(t.isWebGL2===!0){const x=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,y=x!==void 0?x.length:0;let m=i.get(h);if(m===void 0||m.count!==y){let A=function(){Y.dispose(),i.delete(h),h.removeEventListener("dispose",A)};var b=A;m!==void 0&&m.texture.dispose();const L=h.morphAttributes.position!==void 0,T=h.morphAttributes.normal!==void 0,g=h.morphAttributes.color!==void 0,v=h.morphAttributes.position||[],N=h.morphAttributes.normal||[],K=h.morphAttributes.color||[];let G=0;L===!0&&(G=1),T===!0&&(G=2),g===!0&&(G=3);let W=h.attributes.position.count*G,Q=1;W>t.maxTextureSize&&(Q=Math.ceil(W/t.maxTextureSize),W=t.maxTextureSize);const $=new Float32Array(W*Q*4*y),Y=new wr($,W,Q,y);Y.type=Wn,Y.needsUpdate=!0;const U=G*4;for(let nt=0;nt<y;nt++){const j=v[nt],q=N[nt],lt=K[nt],et=W*Q*4*nt;for(let St=0;St<j.count;St++){const F=St*U;L===!0&&(r.fromBufferAttribute(j,St),$[et+F+0]=r.x,$[et+F+1]=r.y,$[et+F+2]=r.z,$[et+F+3]=0),T===!0&&(r.fromBufferAttribute(q,St),$[et+F+4]=r.x,$[et+F+5]=r.y,$[et+F+6]=r.z,$[et+F+7]=0),g===!0&&(r.fromBufferAttribute(lt,St),$[et+F+8]=r.x,$[et+F+9]=r.y,$[et+F+10]=r.z,$[et+F+11]=lt.itemSize===4?r.w:1)}}m={count:y,texture:Y,size:new Kt(W,Q)},i.set(h,m),h.addEventListener("dispose",A)}let d=0;for(let L=0;L<u.length;L++)d+=u[L];const Z=h.morphTargetsRelative?1:1-d;p.getUniforms().setValue(s,"morphTargetBaseInfluence",Z),p.getUniforms().setValue(s,"morphTargetInfluences",u),p.getUniforms().setValue(s,"morphTargetsTexture",m.texture,e),p.getUniforms().setValue(s,"morphTargetsTextureSize",m.size)}else{const x=u===void 0?0:u.length;let y=n[h.id];if(y===void 0||y.length!==x){y=[];for(let T=0;T<x;T++)y[T]=[T,0];n[h.id]=y}for(let T=0;T<x;T++){const g=y[T];g[0]=T,g[1]=u[T]}y.sort(Cu);for(let T=0;T<8;T++)T<x&&y[T][1]?(o[T][0]=y[T][0],o[T][1]=y[T][1]):(o[T][0]=Number.MAX_SAFE_INTEGER,o[T][1]=0);o.sort(Wu);const m=h.morphAttributes.position,d=h.morphAttributes.normal;let Z=0;for(let T=0;T<8;T++){const g=o[T],v=g[0],N=g[1];v!==Number.MAX_SAFE_INTEGER&&N?(m&&h.getAttribute("morphTarget"+T)!==m[v]&&h.setAttribute("morphTarget"+T,m[v]),d&&h.getAttribute("morphNormal"+T)!==d[v]&&h.setAttribute("morphNormal"+T,d[v]),a[T]=N,Z+=N):(m&&h.hasAttribute("morphTarget"+T)===!0&&h.deleteAttribute("morphTarget"+T),d&&h.hasAttribute("morphNormal"+T)===!0&&h.deleteAttribute("morphNormal"+T),a[T]=0)}const L=h.morphTargetsRelative?1:1-Z;p.getUniforms().setValue(s,"morphTargetBaseInfluence",L),p.getUniforms().setValue(s,"morphTargetInfluences",a)}}return{update:l}}function zu(s,t,e,n){let a=new WeakMap;function i(l){const c=n.render.frame,h=l.geometry,p=t.get(l,h);return a.get(p)!==c&&(t.update(p),a.set(p,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),e.update(l.instanceMatrix,s.ARRAY_BUFFER),l.instanceColor!==null&&e.update(l.instanceColor,s.ARRAY_BUFFER)),p}function r(){a=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:i,dispose:r}}const Dr=new Pe,Ar=new wr,Jr=new xc,Br=new Ur,_o=[],Uo=[],ko=new Float32Array(16),Do=new Float32Array(9),Ao=new Float32Array(4);function Zi(s,t,e){const n=s[0];if(n<=0||n>0)return s;const a=t*e;let i=_o[a];if(i===void 0&&(i=new Float32Array(a),_o[a]=i),t!==0){n.toArray(i,0);for(let r=1,o=0;r!==t;++r)o+=e,s[r].toArray(i,o)}return i}function be(s,t){if(s.length!==t.length)return!1;for(let e=0,n=s.length;e<n;e++)if(s[e]!==t[e])return!1;return!0}function fe(s,t){for(let e=0,n=t.length;e<n;e++)s[e]=t[e]}function Ws(s,t){let e=Uo[t];e===void 0&&(e=new Int32Array(t),Uo[t]=e);for(let n=0;n!==t;++n)e[n]=s.allocateTextureUnit();return e}function Nu(s,t){const e=this.cache;e[0]!==t&&(s.uniform1f(this.addr,t),e[0]=t)}function Iu(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(be(e,t))return;s.uniform2fv(this.addr,t),fe(e,t)}}function Vu(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(s.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(be(e,t))return;s.uniform3fv(this.addr,t),fe(e,t)}}function Ku(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(be(e,t))return;s.uniform4fv(this.addr,t),fe(e,t)}}function wu(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(be(e,t))return;s.uniformMatrix2fv(this.addr,!1,t),fe(e,t)}else{if(be(e,n))return;Ao.set(n),s.uniformMatrix2fv(this.addr,!1,Ao),fe(e,n)}}function Eu(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(be(e,t))return;s.uniformMatrix3fv(this.addr,!1,t),fe(e,t)}else{if(be(e,n))return;Do.set(n),s.uniformMatrix3fv(this.addr,!1,Do),fe(e,n)}}function Pu(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(be(e,t))return;s.uniformMatrix4fv(this.addr,!1,t),fe(e,t)}else{if(be(e,n))return;ko.set(n),s.uniformMatrix4fv(this.addr,!1,ko),fe(e,n)}}function Yu(s,t){const e=this.cache;e[0]!==t&&(s.uniform1i(this.addr,t),e[0]=t)}function Hu(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2i(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(be(e,t))return;s.uniform2iv(this.addr,t),fe(e,t)}}function Fu(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3i(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(be(e,t))return;s.uniform3iv(this.addr,t),fe(e,t)}}function _u(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4i(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(be(e,t))return;s.uniform4iv(this.addr,t),fe(e,t)}}function Uu(s,t){const e=this.cache;e[0]!==t&&(s.uniform1ui(this.addr,t),e[0]=t)}function ku(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2ui(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(be(e,t))return;s.uniform2uiv(this.addr,t),fe(e,t)}}function Du(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3ui(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(be(e,t))return;s.uniform3uiv(this.addr,t),fe(e,t)}}function Au(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4ui(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(be(e,t))return;s.uniform4uiv(this.addr,t),fe(e,t)}}function Ju(s,t,e){const n=this.cache,a=e.allocateTextureUnit();n[0]!==a&&(s.uniform1i(this.addr,a),n[0]=a),e.setTexture2D(t||Dr,a)}function Bu(s,t,e){const n=this.cache,a=e.allocateTextureUnit();n[0]!==a&&(s.uniform1i(this.addr,a),n[0]=a),e.setTexture3D(t||Jr,a)}function Ou(s,t,e){const n=this.cache,a=e.allocateTextureUnit();n[0]!==a&&(s.uniform1i(this.addr,a),n[0]=a),e.setTextureCube(t||Br,a)}function ju(s,t,e){const n=this.cache,a=e.allocateTextureUnit();n[0]!==a&&(s.uniform1i(this.addr,a),n[0]=a),e.setTexture2DArray(t||Ar,a)}function Qu(s){switch(s){case 5126:return Nu;case 35664:return Iu;case 35665:return Vu;case 35666:return Ku;case 35674:return wu;case 35675:return Eu;case 35676:return Pu;case 5124:case 35670:return Yu;case 35667:case 35671:return Hu;case 35668:case 35672:return Fu;case 35669:case 35673:return _u;case 5125:return Uu;case 36294:return ku;case 36295:return Du;case 36296:return Au;case 35678:case 36198:case 36298:case 36306:case 35682:return Ju;case 35679:case 36299:case 36307:return Bu;case 35680:case 36300:case 36308:case 36293:return Ou;case 36289:case 36303:case 36311:case 36292:return ju}}function qu(s,t){s.uniform1fv(this.addr,t)}function $u(s,t){const e=Zi(t,this.size,2);s.uniform2fv(this.addr,e)}function tp(s,t){const e=Zi(t,this.size,3);s.uniform3fv(this.addr,e)}function ep(s,t){const e=Zi(t,this.size,4);s.uniform4fv(this.addr,e)}function np(s,t){const e=Zi(t,this.size,4);s.uniformMatrix2fv(this.addr,!1,e)}function ip(s,t){const e=Zi(t,this.size,9);s.uniformMatrix3fv(this.addr,!1,e)}function sp(s,t){const e=Zi(t,this.size,16);s.uniformMatrix4fv(this.addr,!1,e)}function ap(s,t){s.uniform1iv(this.addr,t)}function op(s,t){s.uniform2iv(this.addr,t)}function rp(s,t){s.uniform3iv(this.addr,t)}function lp(s,t){s.uniform4iv(this.addr,t)}function cp(s,t){s.uniform1uiv(this.addr,t)}function dp(s,t){s.uniform2uiv(this.addr,t)}function hp(s,t){s.uniform3uiv(this.addr,t)}function up(s,t){s.uniform4uiv(this.addr,t)}function pp(s,t,e){const n=this.cache,a=t.length,i=Ws(e,a);be(n,i)||(s.uniform1iv(this.addr,i),fe(n,i));for(let r=0;r!==a;++r)e.setTexture2D(t[r]||Dr,i[r])}function mp(s,t,e){const n=this.cache,a=t.length,i=Ws(e,a);be(n,i)||(s.uniform1iv(this.addr,i),fe(n,i));for(let r=0;r!==a;++r)e.setTexture3D(t[r]||Jr,i[r])}function bp(s,t,e){const n=this.cache,a=t.length,i=Ws(e,a);be(n,i)||(s.uniform1iv(this.addr,i),fe(n,i));for(let r=0;r!==a;++r)e.setTextureCube(t[r]||Br,i[r])}function fp(s,t,e){const n=this.cache,a=t.length,i=Ws(e,a);be(n,i)||(s.uniform1iv(this.addr,i),fe(n,i));for(let r=0;r!==a;++r)e.setTexture2DArray(t[r]||Ar,i[r])}function yp(s){switch(s){case 5126:return qu;case 35664:return $u;case 35665:return tp;case 35666:return ep;case 35674:return np;case 35675:return ip;case 35676:return sp;case 5124:case 35670:return ap;case 35667:case 35671:return op;case 35668:case 35672:return rp;case 35669:case 35673:return lp;case 5125:return cp;case 36294:return dp;case 36295:return hp;case 36296:return up;case 35678:case 36198:case 36298:case 36306:case 35682:return pp;case 35679:case 36299:case 36307:return mp;case 35680:case 36300:case 36308:case 36293:return bp;case 36289:case 36303:case 36311:case 36292:return fp}}class Mp{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=Qu(e.type)}}class xp{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=yp(e.type)}}class Gp{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const a=this.seq;for(let i=0,r=a.length;i!==r;++i){const o=a[i];o.setValue(t,e[o.id],n)}}}const ca=/(\w+)(\])?(\[|\.)?/g;function Jo(s,t){s.seq.push(t),s.map[t.id]=t}function Xp(s,t,e){const n=s.name,a=n.length;for(ca.lastIndex=0;;){const i=ca.exec(n),r=ca.lastIndex;let o=i[1];const l=i[2]==="]",c=i[3];if(l&&(o=o|0),c===void 0||c==="["&&r+2===a){Jo(e,c===void 0?new Mp(o,s,t):new xp(o,s,t));break}else{let p=e.map[o];p===void 0&&(p=new Gp(o),Jo(e,p)),e=p}}}class Ls{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let a=0;a<n;++a){const i=t.getActiveUniform(e,a),r=t.getUniformLocation(e,i.name);Xp(i,r,this)}}setValue(t,e,n,a){const i=this.map[e];i!==void 0&&i.setValue(t,n,a)}setOptional(t,e,n){const a=e[n];a!==void 0&&this.setValue(t,n,a)}static upload(t,e,n,a){for(let i=0,r=e.length;i!==r;++i){const o=e[i],l=n[o.id];l.needsUpdate!==!1&&o.setValue(t,l.value,a)}}static seqWithValue(t,e){const n=[];for(let a=0,i=t.length;a!==i;++a){const r=t[a];r.id in e&&n.push(r)}return n}}function Bo(s,t,e){const n=s.createShader(t);return s.shaderSource(n,e),s.compileShader(n),n}let Lp=0;function Sp(s,t){const e=s.split(`
`),n=[],a=Math.max(t-6,0),i=Math.min(t+6,e.length);for(let r=a;r<i;r++){const o=r+1;n.push(`${o===t?">":" "} ${o}: ${e[r]}`)}return n.join(`
`)}function gp(s){switch(s){case on:return["Linear","( value )"];case Ut:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",s),["Linear","( value )"]}}function Oo(s,t,e){const n=s.getShaderParameter(t,s.COMPILE_STATUS),a=s.getShaderInfoLog(t).trim();if(n&&a==="")return"";const i=/ERROR: 0:(\d+)/.exec(a);if(i){const r=parseInt(i[1]);return e.toUpperCase()+`

`+a+`

`+Sp(s.getShaderSource(t),r)}else return a}function Tp(s,t){const e=gp(t);return"vec4 "+s+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function Zp(s,t){let e;switch(t){case El:e="Linear";break;case Pl:e="Reinhard";break;case Yl:e="OptimizedCineon";break;case Hl:e="ACESFilmic";break;case Fl:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+s+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function Rp(s){return[s.extensionDerivatives||s.envMapCubeUVHeight||s.bumpMap||s.normalMapTangentSpace||s.clearcoatNormalMap||s.flatShading||s.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(s.extensionFragDepth||s.logarithmicDepthBuffer)&&s.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",s.extensionDrawBuffers&&s.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(s.extensionShaderTextureLOD||s.envMap||s.transmission)&&s.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ei).join(`
`)}function Wp(s){const t=[];for(const e in s){const n=s[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function Cp(s,t){const e={},n=s.getProgramParameter(t,s.ACTIVE_ATTRIBUTES);for(let a=0;a<n;a++){const i=s.getActiveAttrib(t,a),r=i.name;let o=1;i.type===s.FLOAT_MAT2&&(o=2),i.type===s.FLOAT_MAT3&&(o=3),i.type===s.FLOAT_MAT4&&(o=4),e[r]={type:i.type,location:s.getAttribLocation(t,r),locationSize:o}}return e}function Ei(s){return s!==""}function jo(s,t){const e=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return s.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Qo(s,t){return s.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const vp=/^[ \t]*#include +<([\w\d./]+)>/gm;function ga(s){return s.replace(vp,zp)}function zp(s,t){const e=At[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return ga(e)}const Np=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function qo(s){return s.replace(Np,Ip)}function Ip(s,t,e,n){let a="";for(let i=parseInt(t);i<parseInt(e);i++)a+=n.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return a}function $o(s){let t="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?t+=`
#define HIGH_PRECISION`:s.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Vp(s){let t="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===Mr?t="SHADOWMAP_TYPE_PCF":s.shadowMapType===xr?t="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===xn&&(t="SHADOWMAP_TYPE_VSM"),t}function Kp(s){let t="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case Xi:case Li:t="ENVMAP_TYPE_CUBE";break;case Zs:t="ENVMAP_TYPE_CUBE_UV";break}return t}function wp(s){let t="ENVMAP_MODE_REFLECTION";if(s.envMap)switch(s.envMapMode){case Li:t="ENVMAP_MODE_REFRACTION";break}return t}function Ep(s){let t="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case Lr:t="ENVMAP_BLENDING_MULTIPLY";break;case Kl:t="ENVMAP_BLENDING_MIX";break;case wl:t="ENVMAP_BLENDING_ADD";break}return t}function Pp(s){const t=s.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t)-2,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:n,maxMip:e}}function Yp(s,t,e,n){const a=s.getContext(),i=e.defines;let r=e.vertexShader,o=e.fragmentShader;const l=Vp(e),c=Kp(e),h=wp(e),p=Ep(e),u=Pp(e),b=e.isWebGL2?"":Rp(e),x=Wp(i),y=a.createProgram();let m,d,Z=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(m=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,x].filter(Ei).join(`
`),m.length>0&&(m+=`
`),d=[b,"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,x].filter(Ei).join(`
`),d.length>0&&(d+=`
`)):(m=[$o(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,x,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors&&e.isWebGL2?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.useLegacyLights?"#define LEGACY_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ei).join(`
`),d=[b,$o(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,x,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+h:"",e.envMap?"#define "+p:"",u?"#define CUBEUV_TEXEL_WIDTH "+u.texelWidth:"",u?"#define CUBEUV_TEXEL_HEIGHT "+u.texelHeight:"",u?"#define CUBEUV_MAX_MIP "+u.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.useLegacyLights?"#define LEGACY_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Xn?"#define TONE_MAPPING":"",e.toneMapping!==Xn?At.tonemapping_pars_fragment:"",e.toneMapping!==Xn?Zp("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",At.encodings_pars_fragment,Tp("linearToOutputTexel",e.outputColorSpace),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Ei).join(`
`)),r=ga(r),r=jo(r,e),r=Qo(r,e),o=ga(o),o=jo(o,e),o=Qo(o,e),r=qo(r),o=qo(o),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(Z=`#version 300 es
`,m=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,d=["#define varying in",e.glslVersion===Mo?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Mo?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+d);const L=Z+m+r,T=Z+d+o,g=Bo(a,a.VERTEX_SHADER,L),v=Bo(a,a.FRAGMENT_SHADER,T);if(a.attachShader(y,g),a.attachShader(y,v),e.index0AttributeName!==void 0?a.bindAttribLocation(y,0,e.index0AttributeName):e.morphTargets===!0&&a.bindAttribLocation(y,0,"position"),a.linkProgram(y),s.debug.checkShaderErrors){const G=a.getProgramInfoLog(y).trim(),W=a.getShaderInfoLog(g).trim(),Q=a.getShaderInfoLog(v).trim();let $=!0,Y=!0;if(a.getProgramParameter(y,a.LINK_STATUS)===!1)if($=!1,typeof s.debug.onShaderError=="function")s.debug.onShaderError(a,y,g,v);else{const U=Oo(a,g,"vertex"),A=Oo(a,v,"fragment");console.error("THREE.WebGLProgram: Shader Error "+a.getError()+" - VALIDATE_STATUS "+a.getProgramParameter(y,a.VALIDATE_STATUS)+`

Program Info Log: `+G+`
`+U+`
`+A)}else G!==""?console.warn("THREE.WebGLProgram: Program Info Log:",G):(W===""||Q==="")&&(Y=!1);Y&&(this.diagnostics={runnable:$,programLog:G,vertexShader:{log:W,prefix:m},fragmentShader:{log:Q,prefix:d}})}a.deleteShader(g),a.deleteShader(v);let N;this.getUniforms=function(){return N===void 0&&(N=new Ls(a,y)),N};let K;return this.getAttributes=function(){return K===void 0&&(K=Cp(a,y)),K},this.destroy=function(){n.releaseStatesOfProgram(this),a.deleteProgram(y),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=Lp++,this.cacheKey=t,this.usedTimes=1,this.program=y,this.vertexShader=g,this.fragmentShader=v,this}let Hp=0;class Fp{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,a=this._getShaderStage(e),i=this._getShaderStage(n),r=this._getShaderCacheForMaterial(t);return r.has(a)===!1&&(r.add(a),a.usedTimes++),r.has(i)===!1&&(r.add(i),i.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return n===void 0&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return n===void 0&&(n=new _p(t),e.set(t,n)),n}}class _p{constructor(t){this.id=Hp++,this.code=t,this.usedTimes=0}}function Up(s,t,e,n,a,i,r){const o=new Er,l=new Fp,c=[],h=a.isWebGL2,p=a.logarithmicDepthBuffer,u=a.vertexTextures;let b=a.precision;const x={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function y(G){return G===0?"uv":`uv${G}`}function m(G,W,Q,$,Y){const U=$.fog,A=Y.geometry,nt=G.isMeshStandardMaterial?$.environment:null,j=(G.isMeshStandardMaterial?e:t).get(G.envMap||nt),q=j&&j.mapping===Zs?j.image.height:null,lt=x[G.type];G.precision!==null&&(b=a.getMaxPrecision(G.precision),b!==G.precision&&console.warn("THREE.WebGLProgram.getParameters:",G.precision,"not supported, using",b,"instead."));const et=A.morphAttributes.position||A.morphAttributes.normal||A.morphAttributes.color,St=et!==void 0?et.length:0;let F=0;A.morphAttributes.position!==void 0&&(F=1),A.morphAttributes.normal!==void 0&&(F=2),A.morphAttributes.color!==void 0&&(F=3);let st,at,ft,yt;if(lt){const re=en[lt];st=re.vertexShader,at=re.fragmentShader}else st=G.vertexShader,at=G.fragmentShader,l.update(G),ft=l.getVertexShaderID(G),yt=l.getFragmentShaderID(G);const Ct=s.getRenderTarget(),Ht=Y.isInstancedMesh===!0,It=!!G.map,ae=!!G.matcap,kt=!!j,P=!!G.aoMap,de=!!G.lightMap,vt=!!G.bumpMap,Yt=!!G.normalMap,zt=!!G.displacementMap,qt=!!G.emissiveMap,Ft=!!G.metalnessMap,wt=!!G.roughnessMap,Qt=G.anisotropy>0,he=G.clearcoat>0,ue=G.iridescence>0,R=G.sheen>0,X=G.transmission>0,J=Qt&&!!G.anisotropyMap,ct=he&&!!G.clearcoatMap,dt=he&&!!G.clearcoatNormalMap,C=he&&!!G.clearcoatRoughnessMap,tt=ue&&!!G.iridescenceMap,rt=ue&&!!G.iridescenceThicknessMap,D=R&&!!G.sheenColorMap,Gt=R&&!!G.sheenRoughnessMap,Zt=!!G.specularMap,gt=!!G.specularColorMap,Xt=!!G.specularIntensityMap,Mt=X&&!!G.transmissionMap,Vt=X&&!!G.thicknessMap,Dt=!!G.gradientMap,I=!!G.alphaMap,pt=G.alphaTest>0,k=!!G.extensions,ht=!!A.attributes.uv1,bt=!!A.attributes.uv2,jt=!!A.attributes.uv3;return{isWebGL2:h,shaderID:lt,shaderType:G.type,shaderName:G.name,vertexShader:st,fragmentShader:at,defines:G.defines,customVertexShaderID:ft,customFragmentShaderID:yt,isRawShaderMaterial:G.isRawShaderMaterial===!0,glslVersion:G.glslVersion,precision:b,instancing:Ht,instancingColor:Ht&&Y.instanceColor!==null,supportsVertexTextures:u,outputColorSpace:Ct===null?s.outputColorSpace:Ct.isXRRenderTarget===!0?Ct.texture.colorSpace:on,map:It,matcap:ae,envMap:kt,envMapMode:kt&&j.mapping,envMapCubeUVHeight:q,aoMap:P,lightMap:de,bumpMap:vt,normalMap:Yt,displacementMap:u&&zt,emissiveMap:qt,normalMapObjectSpace:Yt&&G.normalMapType===tc,normalMapTangentSpace:Yt&&G.normalMapType===zr,metalnessMap:Ft,roughnessMap:wt,anisotropy:Qt,anisotropyMap:J,clearcoat:he,clearcoatMap:ct,clearcoatNormalMap:dt,clearcoatRoughnessMap:C,iridescence:ue,iridescenceMap:tt,iridescenceThicknessMap:rt,sheen:R,sheenColorMap:D,sheenRoughnessMap:Gt,specularMap:Zt,specularColorMap:gt,specularIntensityMap:Xt,transmission:X,transmissionMap:Mt,thicknessMap:Vt,gradientMap:Dt,opaque:G.transparent===!1&&G.blending===xi,alphaMap:I,alphaTest:pt,combine:G.combine,mapUv:It&&y(G.map.channel),aoMapUv:P&&y(G.aoMap.channel),lightMapUv:de&&y(G.lightMap.channel),bumpMapUv:vt&&y(G.bumpMap.channel),normalMapUv:Yt&&y(G.normalMap.channel),displacementMapUv:zt&&y(G.displacementMap.channel),emissiveMapUv:qt&&y(G.emissiveMap.channel),metalnessMapUv:Ft&&y(G.metalnessMap.channel),roughnessMapUv:wt&&y(G.roughnessMap.channel),anisotropyMapUv:J&&y(G.anisotropyMap.channel),clearcoatMapUv:ct&&y(G.clearcoatMap.channel),clearcoatNormalMapUv:dt&&y(G.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:C&&y(G.clearcoatRoughnessMap.channel),iridescenceMapUv:tt&&y(G.iridescenceMap.channel),iridescenceThicknessMapUv:rt&&y(G.iridescenceThicknessMap.channel),sheenColorMapUv:D&&y(G.sheenColorMap.channel),sheenRoughnessMapUv:Gt&&y(G.sheenRoughnessMap.channel),specularMapUv:Zt&&y(G.specularMap.channel),specularColorMapUv:gt&&y(G.specularColorMap.channel),specularIntensityMapUv:Xt&&y(G.specularIntensityMap.channel),transmissionMapUv:Mt&&y(G.transmissionMap.channel),thicknessMapUv:Vt&&y(G.thicknessMap.channel),alphaMapUv:I&&y(G.alphaMap.channel),vertexTangents:!!A.attributes.tangent&&(Yt||Qt),vertexColors:G.vertexColors,vertexAlphas:G.vertexColors===!0&&!!A.attributes.color&&A.attributes.color.itemSize===4,vertexUv1s:ht,vertexUv2s:bt,vertexUv3s:jt,pointsUvs:Y.isPoints===!0&&!!A.attributes.uv&&(It||I),fog:!!U,useFog:G.fog===!0,fogExp2:U&&U.isFogExp2,flatShading:G.flatShading===!0,sizeAttenuation:G.sizeAttenuation===!0,logarithmicDepthBuffer:p,skinning:Y.isSkinnedMesh===!0,morphTargets:A.morphAttributes.position!==void 0,morphNormals:A.morphAttributes.normal!==void 0,morphColors:A.morphAttributes.color!==void 0,morphTargetsCount:St,morphTextureStride:F,numDirLights:W.directional.length,numPointLights:W.point.length,numSpotLights:W.spot.length,numSpotLightMaps:W.spotLightMap.length,numRectAreaLights:W.rectArea.length,numHemiLights:W.hemi.length,numDirLightShadows:W.directionalShadowMap.length,numPointLightShadows:W.pointShadowMap.length,numSpotLightShadows:W.spotShadowMap.length,numSpotLightShadowsWithMaps:W.numSpotLightShadowsWithMaps,numClippingPlanes:r.numPlanes,numClipIntersection:r.numIntersection,dithering:G.dithering,shadowMapEnabled:s.shadowMap.enabled&&Q.length>0,shadowMapType:s.shadowMap.type,toneMapping:G.toneMapped?s.toneMapping:Xn,useLegacyLights:s.useLegacyLights,premultipliedAlpha:G.premultipliedAlpha,doubleSided:G.side===nn,flipSided:G.side===Ne,useDepthPacking:G.depthPacking>=0,depthPacking:G.depthPacking||0,index0AttributeName:G.index0AttributeName,extensionDerivatives:k&&G.extensions.derivatives===!0,extensionFragDepth:k&&G.extensions.fragDepth===!0,extensionDrawBuffers:k&&G.extensions.drawBuffers===!0,extensionShaderTextureLOD:k&&G.extensions.shaderTextureLOD===!0,rendererExtensionFragDepth:h||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||n.has("EXT_shader_texture_lod"),customProgramCacheKey:G.customProgramCacheKey()}}function d(G){const W=[];if(G.shaderID?W.push(G.shaderID):(W.push(G.customVertexShaderID),W.push(G.customFragmentShaderID)),G.defines!==void 0)for(const Q in G.defines)W.push(Q),W.push(G.defines[Q]);return G.isRawShaderMaterial===!1&&(Z(W,G),L(W,G),W.push(s.outputColorSpace)),W.push(G.customProgramCacheKey),W.join()}function Z(G,W){G.push(W.precision),G.push(W.outputColorSpace),G.push(W.envMapMode),G.push(W.envMapCubeUVHeight),G.push(W.mapUv),G.push(W.alphaMapUv),G.push(W.lightMapUv),G.push(W.aoMapUv),G.push(W.bumpMapUv),G.push(W.normalMapUv),G.push(W.displacementMapUv),G.push(W.emissiveMapUv),G.push(W.metalnessMapUv),G.push(W.roughnessMapUv),G.push(W.anisotropyMapUv),G.push(W.clearcoatMapUv),G.push(W.clearcoatNormalMapUv),G.push(W.clearcoatRoughnessMapUv),G.push(W.iridescenceMapUv),G.push(W.iridescenceThicknessMapUv),G.push(W.sheenColorMapUv),G.push(W.sheenRoughnessMapUv),G.push(W.specularMapUv),G.push(W.specularColorMapUv),G.push(W.specularIntensityMapUv),G.push(W.transmissionMapUv),G.push(W.thicknessMapUv),G.push(W.combine),G.push(W.fogExp2),G.push(W.sizeAttenuation),G.push(W.morphTargetsCount),G.push(W.morphAttributeCount),G.push(W.numDirLights),G.push(W.numPointLights),G.push(W.numSpotLights),G.push(W.numSpotLightMaps),G.push(W.numHemiLights),G.push(W.numRectAreaLights),G.push(W.numDirLightShadows),G.push(W.numPointLightShadows),G.push(W.numSpotLightShadows),G.push(W.numSpotLightShadowsWithMaps),G.push(W.shadowMapType),G.push(W.toneMapping),G.push(W.numClippingPlanes),G.push(W.numClipIntersection),G.push(W.depthPacking)}function L(G,W){o.disableAll(),W.isWebGL2&&o.enable(0),W.supportsVertexTextures&&o.enable(1),W.instancing&&o.enable(2),W.instancingColor&&o.enable(3),W.matcap&&o.enable(4),W.envMap&&o.enable(5),W.normalMapObjectSpace&&o.enable(6),W.normalMapTangentSpace&&o.enable(7),W.clearcoat&&o.enable(8),W.iridescence&&o.enable(9),W.alphaTest&&o.enable(10),W.vertexColors&&o.enable(11),W.vertexAlphas&&o.enable(12),W.vertexUv1s&&o.enable(13),W.vertexUv2s&&o.enable(14),W.vertexUv3s&&o.enable(15),W.vertexTangents&&o.enable(16),W.anisotropy&&o.enable(17),G.push(o.mask),o.disableAll(),W.fog&&o.enable(0),W.useFog&&o.enable(1),W.flatShading&&o.enable(2),W.logarithmicDepthBuffer&&o.enable(3),W.skinning&&o.enable(4),W.morphTargets&&o.enable(5),W.morphNormals&&o.enable(6),W.morphColors&&o.enable(7),W.premultipliedAlpha&&o.enable(8),W.shadowMapEnabled&&o.enable(9),W.useLegacyLights&&o.enable(10),W.doubleSided&&o.enable(11),W.flipSided&&o.enable(12),W.useDepthPacking&&o.enable(13),W.dithering&&o.enable(14),W.transmission&&o.enable(15),W.sheen&&o.enable(16),W.opaque&&o.enable(17),W.pointsUvs&&o.enable(18),G.push(o.mask)}function T(G){const W=x[G.type];let Q;if(W){const $=en[W];Q=Nc.clone($.uniforms)}else Q=G.uniforms;return Q}function g(G,W){let Q;for(let $=0,Y=c.length;$<Y;$++){const U=c[$];if(U.cacheKey===W){Q=U,++Q.usedTimes;break}}return Q===void 0&&(Q=new Yp(s,W,G,i),c.push(Q)),Q}function v(G){if(--G.usedTimes===0){const W=c.indexOf(G);c[W]=c[c.length-1],c.pop(),G.destroy()}}function N(G){l.remove(G)}function K(){l.dispose()}return{getParameters:m,getProgramCacheKey:d,getUniforms:T,acquireProgram:g,releaseProgram:v,releaseShaderCache:N,programs:c,dispose:K}}function kp(){let s=new WeakMap;function t(i){let r=s.get(i);return r===void 0&&(r={},s.set(i,r)),r}function e(i){s.delete(i)}function n(i,r,o){s.get(i)[r]=o}function a(){s=new WeakMap}return{get:t,remove:e,update:n,dispose:a}}function Dp(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.material.id!==t.material.id?s.material.id-t.material.id:s.z!==t.z?s.z-t.z:s.id-t.id}function tr(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.z!==t.z?t.z-s.z:s.id-t.id}function er(){const s=[];let t=0;const e=[],n=[],a=[];function i(){t=0,e.length=0,n.length=0,a.length=0}function r(p,u,b,x,y,m){let d=s[t];return d===void 0?(d={id:p.id,object:p,geometry:u,material:b,groupOrder:x,renderOrder:p.renderOrder,z:y,group:m},s[t]=d):(d.id=p.id,d.object=p,d.geometry=u,d.material=b,d.groupOrder=x,d.renderOrder=p.renderOrder,d.z=y,d.group=m),t++,d}function o(p,u,b,x,y,m){const d=r(p,u,b,x,y,m);b.transmission>0?n.push(d):b.transparent===!0?a.push(d):e.push(d)}function l(p,u,b,x,y,m){const d=r(p,u,b,x,y,m);b.transmission>0?n.unshift(d):b.transparent===!0?a.unshift(d):e.unshift(d)}function c(p,u){e.length>1&&e.sort(p||Dp),n.length>1&&n.sort(u||tr),a.length>1&&a.sort(u||tr)}function h(){for(let p=t,u=s.length;p<u;p++){const b=s[p];if(b.id===null)break;b.id=null,b.object=null,b.geometry=null,b.material=null,b.group=null}}return{opaque:e,transmissive:n,transparent:a,init:i,push:o,unshift:l,finish:h,sort:c}}function Ap(){let s=new WeakMap;function t(n,a){const i=s.get(n);let r;return i===void 0?(r=new er,s.set(n,[r])):a>=i.length?(r=new er,i.push(r)):r=i[a],r}function e(){s=new WeakMap}return{get:t,dispose:e}}function Jp(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new V,color:new $t};break;case"SpotLight":e={position:new V,direction:new V,color:new $t,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new V,color:new $t,distance:0,decay:0};break;case"HemisphereLight":e={direction:new V,skyColor:new $t,groundColor:new $t};break;case"RectAreaLight":e={color:new $t,position:new V,halfWidth:new V,halfHeight:new V};break}return s[t.id]=e,e}}}function Bp(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Kt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Kt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Kt,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[t.id]=e,e}}}let Op=0;function jp(s,t){return(t.castShadow?2:0)-(s.castShadow?2:0)+(t.map?1:0)-(s.map?1:0)}function Qp(s,t){const e=new Jp,n=Bp(),a={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let h=0;h<9;h++)a.probe.push(new V);const i=new V,r=new me,o=new me;function l(h,p){let u=0,b=0,x=0;for(let Q=0;Q<9;Q++)a.probe[Q].set(0,0,0);let y=0,m=0,d=0,Z=0,L=0,T=0,g=0,v=0,N=0,K=0;h.sort(jp);const G=p===!0?Math.PI:1;for(let Q=0,$=h.length;Q<$;Q++){const Y=h[Q],U=Y.color,A=Y.intensity,nt=Y.distance,j=Y.shadow&&Y.shadow.map?Y.shadow.map.texture:null;if(Y.isAmbientLight)u+=U.r*A*G,b+=U.g*A*G,x+=U.b*A*G;else if(Y.isLightProbe)for(let q=0;q<9;q++)a.probe[q].addScaledVector(Y.sh.coefficients[q],A);else if(Y.isDirectionalLight){const q=e.get(Y);if(q.color.copy(Y.color).multiplyScalar(Y.intensity*G),Y.castShadow){const lt=Y.shadow,et=n.get(Y);et.shadowBias=lt.bias,et.shadowNormalBias=lt.normalBias,et.shadowRadius=lt.radius,et.shadowMapSize=lt.mapSize,a.directionalShadow[y]=et,a.directionalShadowMap[y]=j,a.directionalShadowMatrix[y]=Y.shadow.matrix,T++}a.directional[y]=q,y++}else if(Y.isSpotLight){const q=e.get(Y);q.position.setFromMatrixPosition(Y.matrixWorld),q.color.copy(U).multiplyScalar(A*G),q.distance=nt,q.coneCos=Math.cos(Y.angle),q.penumbraCos=Math.cos(Y.angle*(1-Y.penumbra)),q.decay=Y.decay,a.spot[d]=q;const lt=Y.shadow;if(Y.map&&(a.spotLightMap[N]=Y.map,N++,lt.updateMatrices(Y),Y.castShadow&&K++),a.spotLightMatrix[d]=lt.matrix,Y.castShadow){const et=n.get(Y);et.shadowBias=lt.bias,et.shadowNormalBias=lt.normalBias,et.shadowRadius=lt.radius,et.shadowMapSize=lt.mapSize,a.spotShadow[d]=et,a.spotShadowMap[d]=j,v++}d++}else if(Y.isRectAreaLight){const q=e.get(Y);q.color.copy(U).multiplyScalar(A),q.halfWidth.set(Y.width*.5,0,0),q.halfHeight.set(0,Y.height*.5,0),a.rectArea[Z]=q,Z++}else if(Y.isPointLight){const q=e.get(Y);if(q.color.copy(Y.color).multiplyScalar(Y.intensity*G),q.distance=Y.distance,q.decay=Y.decay,Y.castShadow){const lt=Y.shadow,et=n.get(Y);et.shadowBias=lt.bias,et.shadowNormalBias=lt.normalBias,et.shadowRadius=lt.radius,et.shadowMapSize=lt.mapSize,et.shadowCameraNear=lt.camera.near,et.shadowCameraFar=lt.camera.far,a.pointShadow[m]=et,a.pointShadowMap[m]=j,a.pointShadowMatrix[m]=Y.shadow.matrix,g++}a.point[m]=q,m++}else if(Y.isHemisphereLight){const q=e.get(Y);q.skyColor.copy(Y.color).multiplyScalar(A*G),q.groundColor.copy(Y.groundColor).multiplyScalar(A*G),a.hemi[L]=q,L++}}Z>0&&(t.isWebGL2||s.has("OES_texture_float_linear")===!0?(a.rectAreaLTC1=ut.LTC_FLOAT_1,a.rectAreaLTC2=ut.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(a.rectAreaLTC1=ut.LTC_HALF_1,a.rectAreaLTC2=ut.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),a.ambient[0]=u,a.ambient[1]=b,a.ambient[2]=x;const W=a.hash;(W.directionalLength!==y||W.pointLength!==m||W.spotLength!==d||W.rectAreaLength!==Z||W.hemiLength!==L||W.numDirectionalShadows!==T||W.numPointShadows!==g||W.numSpotShadows!==v||W.numSpotMaps!==N)&&(a.directional.length=y,a.spot.length=d,a.rectArea.length=Z,a.point.length=m,a.hemi.length=L,a.directionalShadow.length=T,a.directionalShadowMap.length=T,a.pointShadow.length=g,a.pointShadowMap.length=g,a.spotShadow.length=v,a.spotShadowMap.length=v,a.directionalShadowMatrix.length=T,a.pointShadowMatrix.length=g,a.spotLightMatrix.length=v+N-K,a.spotLightMap.length=N,a.numSpotLightShadowsWithMaps=K,W.directionalLength=y,W.pointLength=m,W.spotLength=d,W.rectAreaLength=Z,W.hemiLength=L,W.numDirectionalShadows=T,W.numPointShadows=g,W.numSpotShadows=v,W.numSpotMaps=N,a.version=Op++)}function c(h,p){let u=0,b=0,x=0,y=0,m=0;const d=p.matrixWorldInverse;for(let Z=0,L=h.length;Z<L;Z++){const T=h[Z];if(T.isDirectionalLight){const g=a.directional[u];g.direction.setFromMatrixPosition(T.matrixWorld),i.setFromMatrixPosition(T.target.matrixWorld),g.direction.sub(i),g.direction.transformDirection(d),u++}else if(T.isSpotLight){const g=a.spot[x];g.position.setFromMatrixPosition(T.matrixWorld),g.position.applyMatrix4(d),g.direction.setFromMatrixPosition(T.matrixWorld),i.setFromMatrixPosition(T.target.matrixWorld),g.direction.sub(i),g.direction.transformDirection(d),x++}else if(T.isRectAreaLight){const g=a.rectArea[y];g.position.setFromMatrixPosition(T.matrixWorld),g.position.applyMatrix4(d),o.identity(),r.copy(T.matrixWorld),r.premultiply(d),o.extractRotation(r),g.halfWidth.set(T.width*.5,0,0),g.halfHeight.set(0,T.height*.5,0),g.halfWidth.applyMatrix4(o),g.halfHeight.applyMatrix4(o),y++}else if(T.isPointLight){const g=a.point[b];g.position.setFromMatrixPosition(T.matrixWorld),g.position.applyMatrix4(d),b++}else if(T.isHemisphereLight){const g=a.hemi[m];g.direction.setFromMatrixPosition(T.matrixWorld),g.direction.transformDirection(d),m++}}}return{setup:l,setupView:c,state:a}}function nr(s,t){const e=new Qp(s,t),n=[],a=[];function i(){n.length=0,a.length=0}function r(p){n.push(p)}function o(p){a.push(p)}function l(p){e.setup(n,p)}function c(p){e.setupView(n,p)}return{init:i,state:{lightsArray:n,shadowsArray:a,lights:e},setupLights:l,setupLightsView:c,pushLight:r,pushShadow:o}}function qp(s,t){let e=new WeakMap;function n(i,r=0){const o=e.get(i);let l;return o===void 0?(l=new nr(s,t),e.set(i,[l])):r>=o.length?(l=new nr(s,t),o.push(l)):l=o[r],l}function a(){e=new WeakMap}return{get:n,dispose:a}}class $p extends _i{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=ql,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class tm extends _i{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}const em=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,nm=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function im(s,t,e){let n=new za;const a=new Kt,i=new Kt,r=new Ge,o=new $p({depthPacking:$l}),l=new tm,c={},h=e.maxTextureSize,p={[zn]:Ne,[Ne]:zn,[nn]:nn},u=new An({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Kt},radius:{value:4}},vertexShader:em,fragmentShader:nm}),b=u.clone();b.defines.HORIZONTAL_PASS=1;const x=new Ln;x.setAttribute("position",new an(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const y=new sn(x,u),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Mr;let d=this.type;this.render=function(g,v,N){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||g.length===0)return;const K=s.getRenderTarget(),G=s.getActiveCubeFace(),W=s.getActiveMipmapLevel(),Q=s.state;Q.setBlending(Cn),Q.buffers.color.setClear(1,1,1,1),Q.buffers.depth.setTest(!0),Q.setScissorTest(!1);const $=d!==xn&&this.type===xn,Y=d===xn&&this.type!==xn;for(let U=0,A=g.length;U<A;U++){const nt=g[U],j=nt.shadow;if(j===void 0){console.warn("THREE.WebGLShadowMap:",nt,"has no shadow.");continue}if(j.autoUpdate===!1&&j.needsUpdate===!1)continue;a.copy(j.mapSize);const q=j.getFrameExtents();if(a.multiply(q),i.copy(j.mapSize),(a.x>h||a.y>h)&&(a.x>h&&(i.x=Math.floor(h/q.x),a.x=i.x*q.x,j.mapSize.x=i.x),a.y>h&&(i.y=Math.floor(h/q.y),a.y=i.y*q.y,j.mapSize.y=i.y)),j.map===null||$===!0||Y===!0){const et=this.type!==xn?{minFilter:ve,magFilter:ve}:{};j.map!==null&&j.map.dispose(),j.map=new kn(a.x,a.y,et),j.map.texture.name=nt.name+".shadowMap",j.camera.updateProjectionMatrix()}s.setRenderTarget(j.map),s.clear();const lt=j.getViewportCount();for(let et=0;et<lt;et++){const St=j.getViewport(et);r.set(i.x*St.x,i.y*St.y,i.x*St.z,i.y*St.w),Q.viewport(r),j.updateMatrices(nt,et),n=j.getFrustum(),T(v,N,j.camera,nt,this.type)}j.isPointLightShadow!==!0&&this.type===xn&&Z(j,N),j.needsUpdate=!1}d=this.type,m.needsUpdate=!1,s.setRenderTarget(K,G,W)};function Z(g,v){const N=t.update(y);u.defines.VSM_SAMPLES!==g.blurSamples&&(u.defines.VSM_SAMPLES=g.blurSamples,b.defines.VSM_SAMPLES=g.blurSamples,u.needsUpdate=!0,b.needsUpdate=!0),g.mapPass===null&&(g.mapPass=new kn(a.x,a.y)),u.uniforms.shadow_pass.value=g.map.texture,u.uniforms.resolution.value=g.mapSize,u.uniforms.radius.value=g.radius,s.setRenderTarget(g.mapPass),s.clear(),s.renderBufferDirect(v,null,N,u,y,null),b.uniforms.shadow_pass.value=g.mapPass.texture,b.uniforms.resolution.value=g.mapSize,b.uniforms.radius.value=g.radius,s.setRenderTarget(g.map),s.clear(),s.renderBufferDirect(v,null,N,b,y,null)}function L(g,v,N,K){let G=null;const W=N.isPointLight===!0?g.customDistanceMaterial:g.customDepthMaterial;if(W!==void 0)G=W;else if(G=N.isPointLight===!0?l:o,s.localClippingEnabled&&v.clipShadows===!0&&Array.isArray(v.clippingPlanes)&&v.clippingPlanes.length!==0||v.displacementMap&&v.displacementScale!==0||v.alphaMap&&v.alphaTest>0||v.map&&v.alphaTest>0){const Q=G.uuid,$=v.uuid;let Y=c[Q];Y===void 0&&(Y={},c[Q]=Y);let U=Y[$];U===void 0&&(U=G.clone(),Y[$]=U),G=U}if(G.visible=v.visible,G.wireframe=v.wireframe,K===xn?G.side=v.shadowSide!==null?v.shadowSide:v.side:G.side=v.shadowSide!==null?v.shadowSide:p[v.side],G.alphaMap=v.alphaMap,G.alphaTest=v.alphaTest,G.map=v.map,G.clipShadows=v.clipShadows,G.clippingPlanes=v.clippingPlanes,G.clipIntersection=v.clipIntersection,G.displacementMap=v.displacementMap,G.displacementScale=v.displacementScale,G.displacementBias=v.displacementBias,G.wireframeLinewidth=v.wireframeLinewidth,G.linewidth=v.linewidth,N.isPointLight===!0&&G.isMeshDistanceMaterial===!0){const Q=s.properties.get(G);Q.light=N}return G}function T(g,v,N,K,G){if(g.visible===!1)return;if(g.layers.test(v.layers)&&(g.isMesh||g.isLine||g.isPoints)&&(g.castShadow||g.receiveShadow&&G===xn)&&(!g.frustumCulled||n.intersectsObject(g))){g.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse,g.matrixWorld);const $=t.update(g),Y=g.material;if(Array.isArray(Y)){const U=$.groups;for(let A=0,nt=U.length;A<nt;A++){const j=U[A],q=Y[j.materialIndex];if(q&&q.visible){const lt=L(g,q,K,G);s.renderBufferDirect(N,null,$,lt,g,j)}}}else if(Y.visible){const U=L(g,Y,K,G);s.renderBufferDirect(N,null,$,U,g,null)}}const Q=g.children;for(let $=0,Y=Q.length;$<Y;$++)T(Q[$],v,N,K,G)}}function sm(s,t,e){const n=e.isWebGL2;function a(){let I=!1;const pt=new Ge;let k=null;const ht=new Ge(0,0,0,0);return{setMask:function(bt){k!==bt&&!I&&(s.colorMask(bt,bt,bt,bt),k=bt)},setLocked:function(bt){I=bt},setClear:function(bt,jt,oe,re,rn){rn===!0&&(bt*=re,jt*=re,oe*=re),pt.set(bt,jt,oe,re),ht.equals(pt)===!1&&(s.clearColor(bt,jt,oe,re),ht.copy(pt))},reset:function(){I=!1,k=null,ht.set(-1,0,0,0)}}}function i(){let I=!1,pt=null,k=null,ht=null;return{setTest:function(bt){bt?Ct(s.DEPTH_TEST):Ht(s.DEPTH_TEST)},setMask:function(bt){pt!==bt&&!I&&(s.depthMask(bt),pt=bt)},setFunc:function(bt){if(k!==bt){switch(bt){case Wl:s.depthFunc(s.NEVER);break;case Cl:s.depthFunc(s.ALWAYS);break;case vl:s.depthFunc(s.LESS);break;case fa:s.depthFunc(s.LEQUAL);break;case zl:s.depthFunc(s.EQUAL);break;case Nl:s.depthFunc(s.GEQUAL);break;case Il:s.depthFunc(s.GREATER);break;case Vl:s.depthFunc(s.NOTEQUAL);break;default:s.depthFunc(s.LEQUAL)}k=bt}},setLocked:function(bt){I=bt},setClear:function(bt){ht!==bt&&(s.clearDepth(bt),ht=bt)},reset:function(){I=!1,pt=null,k=null,ht=null}}}function r(){let I=!1,pt=null,k=null,ht=null,bt=null,jt=null,oe=null,re=null,rn=null;return{setTest:function(ie){I||(ie?Ct(s.STENCIL_TEST):Ht(s.STENCIL_TEST))},setMask:function(ie){pt!==ie&&!I&&(s.stencilMask(ie),pt=ie)},setFunc:function(ie,He,Xe){(k!==ie||ht!==He||bt!==Xe)&&(s.stencilFunc(ie,He,Xe),k=ie,ht=He,bt=Xe)},setOp:function(ie,He,Xe){(jt!==ie||oe!==He||re!==Xe)&&(s.stencilOp(ie,He,Xe),jt=ie,oe=He,re=Xe)},setLocked:function(ie){I=ie},setClear:function(ie){rn!==ie&&(s.clearStencil(ie),rn=ie)},reset:function(){I=!1,pt=null,k=null,ht=null,bt=null,jt=null,oe=null,re=null,rn=null}}}const o=new a,l=new i,c=new r,h=new WeakMap,p=new WeakMap;let u={},b={},x=new WeakMap,y=[],m=null,d=!1,Z=null,L=null,T=null,g=null,v=null,N=null,K=null,G=!1,W=null,Q=null,$=null,Y=null,U=null;const A=s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let nt=!1,j=0;const q=s.getParameter(s.VERSION);q.indexOf("WebGL")!==-1?(j=parseFloat(/^WebGL (\d)/.exec(q)[1]),nt=j>=1):q.indexOf("OpenGL ES")!==-1&&(j=parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),nt=j>=2);let lt=null,et={};const St=s.getParameter(s.SCISSOR_BOX),F=s.getParameter(s.VIEWPORT),st=new Ge().fromArray(St),at=new Ge().fromArray(F);function ft(I,pt,k,ht){const bt=new Uint8Array(4),jt=s.createTexture();s.bindTexture(I,jt),s.texParameteri(I,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(I,s.TEXTURE_MAG_FILTER,s.NEAREST);for(let oe=0;oe<k;oe++)n&&(I===s.TEXTURE_3D||I===s.TEXTURE_2D_ARRAY)?s.texImage3D(pt,0,s.RGBA,1,1,ht,0,s.RGBA,s.UNSIGNED_BYTE,bt):s.texImage2D(pt+oe,0,s.RGBA,1,1,0,s.RGBA,s.UNSIGNED_BYTE,bt);return jt}const yt={};yt[s.TEXTURE_2D]=ft(s.TEXTURE_2D,s.TEXTURE_2D,1),yt[s.TEXTURE_CUBE_MAP]=ft(s.TEXTURE_CUBE_MAP,s.TEXTURE_CUBE_MAP_POSITIVE_X,6),n&&(yt[s.TEXTURE_2D_ARRAY]=ft(s.TEXTURE_2D_ARRAY,s.TEXTURE_2D_ARRAY,1,1),yt[s.TEXTURE_3D]=ft(s.TEXTURE_3D,s.TEXTURE_3D,1,1)),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),Ct(s.DEPTH_TEST),l.setFunc(fa),zt(!1),qt(Ha),Ct(s.CULL_FACE),vt(Cn);function Ct(I){u[I]!==!0&&(s.enable(I),u[I]=!0)}function Ht(I){u[I]!==!1&&(s.disable(I),u[I]=!1)}function It(I,pt){return b[I]!==pt?(s.bindFramebuffer(I,pt),b[I]=pt,n&&(I===s.DRAW_FRAMEBUFFER&&(b[s.FRAMEBUFFER]=pt),I===s.FRAMEBUFFER&&(b[s.DRAW_FRAMEBUFFER]=pt)),!0):!1}function ae(I,pt){let k=y,ht=!1;if(I)if(k=x.get(pt),k===void 0&&(k=[],x.set(pt,k)),I.isWebGLMultipleRenderTargets){const bt=I.texture;if(k.length!==bt.length||k[0]!==s.COLOR_ATTACHMENT0){for(let jt=0,oe=bt.length;jt<oe;jt++)k[jt]=s.COLOR_ATTACHMENT0+jt;k.length=bt.length,ht=!0}}else k[0]!==s.COLOR_ATTACHMENT0&&(k[0]=s.COLOR_ATTACHMENT0,ht=!0);else k[0]!==s.BACK&&(k[0]=s.BACK,ht=!0);ht&&(e.isWebGL2?s.drawBuffers(k):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(k))}function kt(I){return m!==I?(s.useProgram(I),m=I,!0):!1}const P={[yi]:s.FUNC_ADD,[yl]:s.FUNC_SUBTRACT,[Ml]:s.FUNC_REVERSE_SUBTRACT};if(n)P[ka]=s.MIN,P[Da]=s.MAX;else{const I=t.get("EXT_blend_minmax");I!==null&&(P[ka]=I.MIN_EXT,P[Da]=I.MAX_EXT)}const de={[xl]:s.ZERO,[Gl]:s.ONE,[Xl]:s.SRC_COLOR,[Gr]:s.SRC_ALPHA,[Rl]:s.SRC_ALPHA_SATURATE,[Tl]:s.DST_COLOR,[Sl]:s.DST_ALPHA,[Ll]:s.ONE_MINUS_SRC_COLOR,[Xr]:s.ONE_MINUS_SRC_ALPHA,[Zl]:s.ONE_MINUS_DST_COLOR,[gl]:s.ONE_MINUS_DST_ALPHA};function vt(I,pt,k,ht,bt,jt,oe,re){if(I===Cn){d===!0&&(Ht(s.BLEND),d=!1);return}if(d===!1&&(Ct(s.BLEND),d=!0),I!==fl){if(I!==Z||re!==G){if((L!==yi||v!==yi)&&(s.blendEquation(s.FUNC_ADD),L=yi,v=yi),re)switch(I){case xi:s.blendFuncSeparate(s.ONE,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA);break;case Fa:s.blendFunc(s.ONE,s.ONE);break;case _a:s.blendFuncSeparate(s.ZERO,s.ONE_MINUS_SRC_COLOR,s.ZERO,s.ONE);break;case Ua:s.blendFuncSeparate(s.ZERO,s.SRC_COLOR,s.ZERO,s.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",I);break}else switch(I){case xi:s.blendFuncSeparate(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA);break;case Fa:s.blendFunc(s.SRC_ALPHA,s.ONE);break;case _a:s.blendFuncSeparate(s.ZERO,s.ONE_MINUS_SRC_COLOR,s.ZERO,s.ONE);break;case Ua:s.blendFunc(s.ZERO,s.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",I);break}T=null,g=null,N=null,K=null,Z=I,G=re}return}bt=bt||pt,jt=jt||k,oe=oe||ht,(pt!==L||bt!==v)&&(s.blendEquationSeparate(P[pt],P[bt]),L=pt,v=bt),(k!==T||ht!==g||jt!==N||oe!==K)&&(s.blendFuncSeparate(de[k],de[ht],de[jt],de[oe]),T=k,g=ht,N=jt,K=oe),Z=I,G=!1}function Yt(I,pt){I.side===nn?Ht(s.CULL_FACE):Ct(s.CULL_FACE);let k=I.side===Ne;pt&&(k=!k),zt(k),I.blending===xi&&I.transparent===!1?vt(Cn):vt(I.blending,I.blendEquation,I.blendSrc,I.blendDst,I.blendEquationAlpha,I.blendSrcAlpha,I.blendDstAlpha,I.premultipliedAlpha),l.setFunc(I.depthFunc),l.setTest(I.depthTest),l.setMask(I.depthWrite),o.setMask(I.colorWrite);const ht=I.stencilWrite;c.setTest(ht),ht&&(c.setMask(I.stencilWriteMask),c.setFunc(I.stencilFunc,I.stencilRef,I.stencilFuncMask),c.setOp(I.stencilFail,I.stencilZFail,I.stencilZPass)),wt(I.polygonOffset,I.polygonOffsetFactor,I.polygonOffsetUnits),I.alphaToCoverage===!0?Ct(s.SAMPLE_ALPHA_TO_COVERAGE):Ht(s.SAMPLE_ALPHA_TO_COVERAGE)}function zt(I){W!==I&&(I?s.frontFace(s.CW):s.frontFace(s.CCW),W=I)}function qt(I){I!==ml?(Ct(s.CULL_FACE),I!==Q&&(I===Ha?s.cullFace(s.BACK):I===bl?s.cullFace(s.FRONT):s.cullFace(s.FRONT_AND_BACK))):Ht(s.CULL_FACE),Q=I}function Ft(I){I!==$&&(nt&&s.lineWidth(I),$=I)}function wt(I,pt,k){I?(Ct(s.POLYGON_OFFSET_FILL),(Y!==pt||U!==k)&&(s.polygonOffset(pt,k),Y=pt,U=k)):Ht(s.POLYGON_OFFSET_FILL)}function Qt(I){I?Ct(s.SCISSOR_TEST):Ht(s.SCISSOR_TEST)}function he(I){I===void 0&&(I=s.TEXTURE0+A-1),lt!==I&&(s.activeTexture(I),lt=I)}function ue(I,pt,k){k===void 0&&(lt===null?k=s.TEXTURE0+A-1:k=lt);let ht=et[k];ht===void 0&&(ht={type:void 0,texture:void 0},et[k]=ht),(ht.type!==I||ht.texture!==pt)&&(lt!==k&&(s.activeTexture(k),lt=k),s.bindTexture(I,pt||yt[I]),ht.type=I,ht.texture=pt)}function R(){const I=et[lt];I!==void 0&&I.type!==void 0&&(s.bindTexture(I.type,null),I.type=void 0,I.texture=void 0)}function X(){try{s.compressedTexImage2D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function J(){try{s.compressedTexImage3D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function ct(){try{s.texSubImage2D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function dt(){try{s.texSubImage3D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function C(){try{s.compressedTexSubImage2D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function tt(){try{s.compressedTexSubImage3D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function rt(){try{s.texStorage2D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function D(){try{s.texStorage3D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function Gt(){try{s.texImage2D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function Zt(){try{s.texImage3D.apply(s,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function gt(I){st.equals(I)===!1&&(s.scissor(I.x,I.y,I.z,I.w),st.copy(I))}function Xt(I){at.equals(I)===!1&&(s.viewport(I.x,I.y,I.z,I.w),at.copy(I))}function Mt(I,pt){let k=p.get(pt);k===void 0&&(k=new WeakMap,p.set(pt,k));let ht=k.get(I);ht===void 0&&(ht=s.getUniformBlockIndex(pt,I.name),k.set(I,ht))}function Vt(I,pt){const ht=p.get(pt).get(I);h.get(pt)!==ht&&(s.uniformBlockBinding(pt,ht,I.__bindingPointIndex),h.set(pt,ht))}function Dt(){s.disable(s.BLEND),s.disable(s.CULL_FACE),s.disable(s.DEPTH_TEST),s.disable(s.POLYGON_OFFSET_FILL),s.disable(s.SCISSOR_TEST),s.disable(s.STENCIL_TEST),s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),s.blendEquation(s.FUNC_ADD),s.blendFunc(s.ONE,s.ZERO),s.blendFuncSeparate(s.ONE,s.ZERO,s.ONE,s.ZERO),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(s.LESS),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(s.ALWAYS,0,4294967295),s.stencilOp(s.KEEP,s.KEEP,s.KEEP),s.clearStencil(0),s.cullFace(s.BACK),s.frontFace(s.CCW),s.polygonOffset(0,0),s.activeTexture(s.TEXTURE0),s.bindFramebuffer(s.FRAMEBUFFER,null),n===!0&&(s.bindFramebuffer(s.DRAW_FRAMEBUFFER,null),s.bindFramebuffer(s.READ_FRAMEBUFFER,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),u={},lt=null,et={},b={},x=new WeakMap,y=[],m=null,d=!1,Z=null,L=null,T=null,g=null,v=null,N=null,K=null,G=!1,W=null,Q=null,$=null,Y=null,U=null,st.set(0,0,s.canvas.width,s.canvas.height),at.set(0,0,s.canvas.width,s.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:Ct,disable:Ht,bindFramebuffer:It,drawBuffers:ae,useProgram:kt,setBlending:vt,setMaterial:Yt,setFlipSided:zt,setCullFace:qt,setLineWidth:Ft,setPolygonOffset:wt,setScissorTest:Qt,activeTexture:he,bindTexture:ue,unbindTexture:R,compressedTexImage2D:X,compressedTexImage3D:J,texImage2D:Gt,texImage3D:Zt,updateUBOMapping:Mt,uniformBlockBinding:Vt,texStorage2D:rt,texStorage3D:D,texSubImage2D:ct,texSubImage3D:dt,compressedTexSubImage2D:C,compressedTexSubImage3D:tt,scissor:gt,viewport:Xt,reset:Dt}}function am(s,t,e,n,a,i,r){const o=a.isWebGL2,l=a.maxTextures,c=a.maxCubemapSize,h=a.maxTextureSize,p=a.maxSamples,u=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,b=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),x=new WeakMap;let y;const m=new WeakMap;let d=!1;try{d=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function Z(R,X){return d?new OffscreenCanvas(R,X):gs("canvas")}function L(R,X,J,ct){let dt=1;if((R.width>ct||R.height>ct)&&(dt=ct/Math.max(R.width,R.height)),dt<1||X===!0)if(typeof HTMLImageElement<"u"&&R instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&R instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&R instanceof ImageBitmap){const C=X?Sa:Math.floor,tt=C(dt*R.width),rt=C(dt*R.height);y===void 0&&(y=Z(tt,rt));const D=J?Z(tt,rt):y;return D.width=tt,D.height=rt,D.getContext("2d").drawImage(R,0,0,tt,rt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+R.width+"x"+R.height+") to ("+tt+"x"+rt+")."),D}else return"data"in R&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+R.width+"x"+R.height+")."),R;return R}function T(R){return xo(R.width)&&xo(R.height)}function g(R){return o?!1:R.wrapS!==$e||R.wrapT!==$e||R.minFilter!==ve&&R.minFilter!==Ue}function v(R,X){return R.generateMipmaps&&X&&R.minFilter!==ve&&R.minFilter!==Ue}function N(R){s.generateMipmap(R)}function K(R,X,J,ct,dt=!1){if(o===!1)return X;if(R!==null){if(s[R]!==void 0)return s[R];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+R+"'")}let C=X;return X===s.RED&&(J===s.FLOAT&&(C=s.R32F),J===s.HALF_FLOAT&&(C=s.R16F),J===s.UNSIGNED_BYTE&&(C=s.R8)),X===s.RG&&(J===s.FLOAT&&(C=s.RG32F),J===s.HALF_FLOAT&&(C=s.RG16F),J===s.UNSIGNED_BYTE&&(C=s.RG8)),X===s.RGBA&&(J===s.FLOAT&&(C=s.RGBA32F),J===s.HALF_FLOAT&&(C=s.RGBA16F),J===s.UNSIGNED_BYTE&&(C=ct===Ut&&dt===!1?s.SRGB8_ALPHA8:s.RGBA8),J===s.UNSIGNED_SHORT_4_4_4_4&&(C=s.RGBA4),J===s.UNSIGNED_SHORT_5_5_5_1&&(C=s.RGB5_A1)),(C===s.R16F||C===s.R32F||C===s.RG16F||C===s.RG32F||C===s.RGBA16F||C===s.RGBA32F)&&t.get("EXT_color_buffer_float"),C}function G(R,X,J){return v(R,J)===!0||R.isFramebufferTexture&&R.minFilter!==ve&&R.minFilter!==Ue?Math.log2(Math.max(X.width,X.height))+1:R.mipmaps!==void 0&&R.mipmaps.length>0?R.mipmaps.length:R.isCompressedTexture&&Array.isArray(R.image)?X.mipmaps.length:1}function W(R){return R===ve||R===Aa||R===Ks?s.NEAREST:s.LINEAR}function Q(R){const X=R.target;X.removeEventListener("dispose",Q),Y(X),X.isVideoTexture&&x.delete(X)}function $(R){const X=R.target;X.removeEventListener("dispose",$),A(X)}function Y(R){const X=n.get(R);if(X.__webglInit===void 0)return;const J=R.source,ct=m.get(J);if(ct){const dt=ct[X.__cacheKey];dt.usedTimes--,dt.usedTimes===0&&U(R),Object.keys(ct).length===0&&m.delete(J)}n.remove(R)}function U(R){const X=n.get(R);s.deleteTexture(X.__webglTexture);const J=R.source,ct=m.get(J);delete ct[X.__cacheKey],r.memory.textures--}function A(R){const X=R.texture,J=n.get(R),ct=n.get(X);if(ct.__webglTexture!==void 0&&(s.deleteTexture(ct.__webglTexture),r.memory.textures--),R.depthTexture&&R.depthTexture.dispose(),R.isWebGLCubeRenderTarget)for(let dt=0;dt<6;dt++)s.deleteFramebuffer(J.__webglFramebuffer[dt]),J.__webglDepthbuffer&&s.deleteRenderbuffer(J.__webglDepthbuffer[dt]);else{if(s.deleteFramebuffer(J.__webglFramebuffer),J.__webglDepthbuffer&&s.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&s.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer)for(let dt=0;dt<J.__webglColorRenderbuffer.length;dt++)J.__webglColorRenderbuffer[dt]&&s.deleteRenderbuffer(J.__webglColorRenderbuffer[dt]);J.__webglDepthRenderbuffer&&s.deleteRenderbuffer(J.__webglDepthRenderbuffer)}if(R.isWebGLMultipleRenderTargets)for(let dt=0,C=X.length;dt<C;dt++){const tt=n.get(X[dt]);tt.__webglTexture&&(s.deleteTexture(tt.__webglTexture),r.memory.textures--),n.remove(X[dt])}n.remove(X),n.remove(R)}let nt=0;function j(){nt=0}function q(){const R=nt;return R>=l&&console.warn("THREE.WebGLTextures: Trying to use "+R+" texture units while this GPU supports only "+l),nt+=1,R}function lt(R){const X=[];return X.push(R.wrapS),X.push(R.wrapT),X.push(R.wrapR||0),X.push(R.magFilter),X.push(R.minFilter),X.push(R.anisotropy),X.push(R.internalFormat),X.push(R.format),X.push(R.type),X.push(R.generateMipmaps),X.push(R.premultiplyAlpha),X.push(R.flipY),X.push(R.unpackAlignment),X.push(R.colorSpace),X.join()}function et(R,X){const J=n.get(R);if(R.isVideoTexture&&he(R),R.isRenderTargetTexture===!1&&R.version>0&&J.__version!==R.version){const ct=R.image;if(ct===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(ct.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{It(J,R,X);return}}e.bindTexture(s.TEXTURE_2D,J.__webglTexture,s.TEXTURE0+X)}function St(R,X){const J=n.get(R);if(R.version>0&&J.__version!==R.version){It(J,R,X);return}e.bindTexture(s.TEXTURE_2D_ARRAY,J.__webglTexture,s.TEXTURE0+X)}function F(R,X){const J=n.get(R);if(R.version>0&&J.__version!==R.version){It(J,R,X);return}e.bindTexture(s.TEXTURE_3D,J.__webglTexture,s.TEXTURE0+X)}function st(R,X){const J=n.get(R);if(R.version>0&&J.__version!==R.version){ae(J,R,X);return}e.bindTexture(s.TEXTURE_CUBE_MAP,J.__webglTexture,s.TEXTURE0+X)}const at={[xa]:s.REPEAT,[$e]:s.CLAMP_TO_EDGE,[Ga]:s.MIRRORED_REPEAT},ft={[ve]:s.NEAREST,[Aa]:s.NEAREST_MIPMAP_NEAREST,[Ks]:s.NEAREST_MIPMAP_LINEAR,[Ue]:s.LINEAR,[_l]:s.LINEAR_MIPMAP_NEAREST,[Yi]:s.LINEAR_MIPMAP_LINEAR},yt={[nc]:s.NEVER,[cc]:s.ALWAYS,[ic]:s.LESS,[ac]:s.LEQUAL,[sc]:s.EQUAL,[lc]:s.GEQUAL,[oc]:s.GREATER,[rc]:s.NOTEQUAL};function Ct(R,X,J){if(J?(s.texParameteri(R,s.TEXTURE_WRAP_S,at[X.wrapS]),s.texParameteri(R,s.TEXTURE_WRAP_T,at[X.wrapT]),(R===s.TEXTURE_3D||R===s.TEXTURE_2D_ARRAY)&&s.texParameteri(R,s.TEXTURE_WRAP_R,at[X.wrapR]),s.texParameteri(R,s.TEXTURE_MAG_FILTER,ft[X.magFilter]),s.texParameteri(R,s.TEXTURE_MIN_FILTER,ft[X.minFilter])):(s.texParameteri(R,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(R,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),(R===s.TEXTURE_3D||R===s.TEXTURE_2D_ARRAY)&&s.texParameteri(R,s.TEXTURE_WRAP_R,s.CLAMP_TO_EDGE),(X.wrapS!==$e||X.wrapT!==$e)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(R,s.TEXTURE_MAG_FILTER,W(X.magFilter)),s.texParameteri(R,s.TEXTURE_MIN_FILTER,W(X.minFilter)),X.minFilter!==ve&&X.minFilter!==Ue&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),X.compareFunction&&(s.texParameteri(R,s.TEXTURE_COMPARE_MODE,s.COMPARE_REF_TO_TEXTURE),s.texParameteri(R,s.TEXTURE_COMPARE_FUNC,yt[X.compareFunction])),t.has("EXT_texture_filter_anisotropic")===!0){const ct=t.get("EXT_texture_filter_anisotropic");if(X.magFilter===ve||X.minFilter!==Ks&&X.minFilter!==Yi||X.type===Wn&&t.has("OES_texture_float_linear")===!1||o===!1&&X.type===Hi&&t.has("OES_texture_half_float_linear")===!1)return;(X.anisotropy>1||n.get(X).__currentAnisotropy)&&(s.texParameterf(R,ct.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(X.anisotropy,a.getMaxAnisotropy())),n.get(X).__currentAnisotropy=X.anisotropy)}}function Ht(R,X){let J=!1;R.__webglInit===void 0&&(R.__webglInit=!0,X.addEventListener("dispose",Q));const ct=X.source;let dt=m.get(ct);dt===void 0&&(dt={},m.set(ct,dt));const C=lt(X);if(C!==R.__cacheKey){dt[C]===void 0&&(dt[C]={texture:s.createTexture(),usedTimes:0},r.memory.textures++,J=!0),dt[C].usedTimes++;const tt=dt[R.__cacheKey];tt!==void 0&&(dt[R.__cacheKey].usedTimes--,tt.usedTimes===0&&U(X)),R.__cacheKey=C,R.__webglTexture=dt[C].texture}return J}function It(R,X,J){let ct=s.TEXTURE_2D;(X.isDataArrayTexture||X.isCompressedArrayTexture)&&(ct=s.TEXTURE_2D_ARRAY),X.isData3DTexture&&(ct=s.TEXTURE_3D);const dt=Ht(R,X),C=X.source;e.bindTexture(ct,R.__webglTexture,s.TEXTURE0+J);const tt=n.get(C);if(C.version!==tt.__version||dt===!0){e.activeTexture(s.TEXTURE0+J),s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,X.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,X.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,X.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,s.NONE);const rt=g(X)&&T(X.image)===!1;let D=L(X.image,rt,!1,h);D=ue(X,D);const Gt=T(D)||o,Zt=i.convert(X.format,X.colorSpace);let gt=i.convert(X.type),Xt=K(X.internalFormat,Zt,gt,X.colorSpace);Ct(ct,X,Gt);let Mt;const Vt=X.mipmaps,Dt=o&&X.isVideoTexture!==!0,I=tt.__version===void 0||dt===!0,pt=G(X,D,Gt);if(X.isDepthTexture)Xt=s.DEPTH_COMPONENT,o?X.type===Wn?Xt=s.DEPTH_COMPONENT32F:X.type===Rn?Xt=s.DEPTH_COMPONENT24:X.type===Hn?Xt=s.DEPTH24_STENCIL8:Xt=s.DEPTH_COMPONENT16:X.type===Wn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),X.format===Fn&&Xt===s.DEPTH_COMPONENT&&X.type!==Wa&&X.type!==Rn&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),X.type=Rn,gt=i.convert(X.type)),X.format===Si&&Xt===s.DEPTH_COMPONENT&&(Xt=s.DEPTH_STENCIL,X.type!==Hn&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),X.type=Hn,gt=i.convert(X.type))),I&&(Dt?e.texStorage2D(s.TEXTURE_2D,1,Xt,D.width,D.height):e.texImage2D(s.TEXTURE_2D,0,Xt,D.width,D.height,0,Zt,gt,null));else if(X.isDataTexture)if(Vt.length>0&&Gt){Dt&&I&&e.texStorage2D(s.TEXTURE_2D,pt,Xt,Vt[0].width,Vt[0].height);for(let k=0,ht=Vt.length;k<ht;k++)Mt=Vt[k],Dt?e.texSubImage2D(s.TEXTURE_2D,k,0,0,Mt.width,Mt.height,Zt,gt,Mt.data):e.texImage2D(s.TEXTURE_2D,k,Xt,Mt.width,Mt.height,0,Zt,gt,Mt.data);X.generateMipmaps=!1}else Dt?(I&&e.texStorage2D(s.TEXTURE_2D,pt,Xt,D.width,D.height),e.texSubImage2D(s.TEXTURE_2D,0,0,0,D.width,D.height,Zt,gt,D.data)):e.texImage2D(s.TEXTURE_2D,0,Xt,D.width,D.height,0,Zt,gt,D.data);else if(X.isCompressedTexture)if(X.isCompressedArrayTexture){Dt&&I&&e.texStorage3D(s.TEXTURE_2D_ARRAY,pt,Xt,Vt[0].width,Vt[0].height,D.depth);for(let k=0,ht=Vt.length;k<ht;k++)Mt=Vt[k],X.format!==tn?Zt!==null?Dt?e.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,k,0,0,0,Mt.width,Mt.height,D.depth,Zt,Mt.data,0,0):e.compressedTexImage3D(s.TEXTURE_2D_ARRAY,k,Xt,Mt.width,Mt.height,D.depth,0,Mt.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Dt?e.texSubImage3D(s.TEXTURE_2D_ARRAY,k,0,0,0,Mt.width,Mt.height,D.depth,Zt,gt,Mt.data):e.texImage3D(s.TEXTURE_2D_ARRAY,k,Xt,Mt.width,Mt.height,D.depth,0,Zt,gt,Mt.data)}else{Dt&&I&&e.texStorage2D(s.TEXTURE_2D,pt,Xt,Vt[0].width,Vt[0].height);for(let k=0,ht=Vt.length;k<ht;k++)Mt=Vt[k],X.format!==tn?Zt!==null?Dt?e.compressedTexSubImage2D(s.TEXTURE_2D,k,0,0,Mt.width,Mt.height,Zt,Mt.data):e.compressedTexImage2D(s.TEXTURE_2D,k,Xt,Mt.width,Mt.height,0,Mt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Dt?e.texSubImage2D(s.TEXTURE_2D,k,0,0,Mt.width,Mt.height,Zt,gt,Mt.data):e.texImage2D(s.TEXTURE_2D,k,Xt,Mt.width,Mt.height,0,Zt,gt,Mt.data)}else if(X.isDataArrayTexture)Dt?(I&&e.texStorage3D(s.TEXTURE_2D_ARRAY,pt,Xt,D.width,D.height,D.depth),e.texSubImage3D(s.TEXTURE_2D_ARRAY,0,0,0,0,D.width,D.height,D.depth,Zt,gt,D.data)):e.texImage3D(s.TEXTURE_2D_ARRAY,0,Xt,D.width,D.height,D.depth,0,Zt,gt,D.data);else if(X.isData3DTexture)Dt?(I&&e.texStorage3D(s.TEXTURE_3D,pt,Xt,D.width,D.height,D.depth),e.texSubImage3D(s.TEXTURE_3D,0,0,0,0,D.width,D.height,D.depth,Zt,gt,D.data)):e.texImage3D(s.TEXTURE_3D,0,Xt,D.width,D.height,D.depth,0,Zt,gt,D.data);else if(X.isFramebufferTexture){if(I)if(Dt)e.texStorage2D(s.TEXTURE_2D,pt,Xt,D.width,D.height);else{let k=D.width,ht=D.height;for(let bt=0;bt<pt;bt++)e.texImage2D(s.TEXTURE_2D,bt,Xt,k,ht,0,Zt,gt,null),k>>=1,ht>>=1}}else if(Vt.length>0&&Gt){Dt&&I&&e.texStorage2D(s.TEXTURE_2D,pt,Xt,Vt[0].width,Vt[0].height);for(let k=0,ht=Vt.length;k<ht;k++)Mt=Vt[k],Dt?e.texSubImage2D(s.TEXTURE_2D,k,0,0,Zt,gt,Mt):e.texImage2D(s.TEXTURE_2D,k,Xt,Zt,gt,Mt);X.generateMipmaps=!1}else Dt?(I&&e.texStorage2D(s.TEXTURE_2D,pt,Xt,D.width,D.height),e.texSubImage2D(s.TEXTURE_2D,0,0,0,Zt,gt,D)):e.texImage2D(s.TEXTURE_2D,0,Xt,Zt,gt,D);v(X,Gt)&&N(ct),tt.__version=C.version,X.onUpdate&&X.onUpdate(X)}R.__version=X.version}function ae(R,X,J){if(X.image.length!==6)return;const ct=Ht(R,X),dt=X.source;e.bindTexture(s.TEXTURE_CUBE_MAP,R.__webglTexture,s.TEXTURE0+J);const C=n.get(dt);if(dt.version!==C.__version||ct===!0){e.activeTexture(s.TEXTURE0+J),s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,X.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,X.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,X.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,s.NONE);const tt=X.isCompressedTexture||X.image[0].isCompressedTexture,rt=X.image[0]&&X.image[0].isDataTexture,D=[];for(let k=0;k<6;k++)!tt&&!rt?D[k]=L(X.image[k],!1,!0,c):D[k]=rt?X.image[k].image:X.image[k],D[k]=ue(X,D[k]);const Gt=D[0],Zt=T(Gt)||o,gt=i.convert(X.format,X.colorSpace),Xt=i.convert(X.type),Mt=K(X.internalFormat,gt,Xt,X.colorSpace),Vt=o&&X.isVideoTexture!==!0,Dt=C.__version===void 0||ct===!0;let I=G(X,Gt,Zt);Ct(s.TEXTURE_CUBE_MAP,X,Zt);let pt;if(tt){Vt&&Dt&&e.texStorage2D(s.TEXTURE_CUBE_MAP,I,Mt,Gt.width,Gt.height);for(let k=0;k<6;k++){pt=D[k].mipmaps;for(let ht=0;ht<pt.length;ht++){const bt=pt[ht];X.format!==tn?gt!==null?Vt?e.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht,0,0,bt.width,bt.height,gt,bt.data):e.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht,Mt,bt.width,bt.height,0,bt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Vt?e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht,0,0,bt.width,bt.height,gt,Xt,bt.data):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht,Mt,bt.width,bt.height,0,gt,Xt,bt.data)}}}else{pt=X.mipmaps,Vt&&Dt&&(pt.length>0&&I++,e.texStorage2D(s.TEXTURE_CUBE_MAP,I,Mt,D[0].width,D[0].height));for(let k=0;k<6;k++)if(rt){Vt?e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,0,0,0,D[k].width,D[k].height,gt,Xt,D[k].data):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,0,Mt,D[k].width,D[k].height,0,gt,Xt,D[k].data);for(let ht=0;ht<pt.length;ht++){const jt=pt[ht].image[k].image;Vt?e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht+1,0,0,jt.width,jt.height,gt,Xt,jt.data):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht+1,Mt,jt.width,jt.height,0,gt,Xt,jt.data)}}else{Vt?e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,0,0,0,gt,Xt,D[k]):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,0,Mt,gt,Xt,D[k]);for(let ht=0;ht<pt.length;ht++){const bt=pt[ht];Vt?e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht+1,0,0,gt,Xt,bt.image[k]):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+k,ht+1,Mt,gt,Xt,bt.image[k])}}}v(X,Zt)&&N(s.TEXTURE_CUBE_MAP),C.__version=dt.version,X.onUpdate&&X.onUpdate(X)}R.__version=X.version}function kt(R,X,J,ct,dt){const C=i.convert(J.format,J.colorSpace),tt=i.convert(J.type),rt=K(J.internalFormat,C,tt,J.colorSpace);n.get(X).__hasExternalTextures||(dt===s.TEXTURE_3D||dt===s.TEXTURE_2D_ARRAY?e.texImage3D(dt,0,rt,X.width,X.height,X.depth,0,C,tt,null):e.texImage2D(dt,0,rt,X.width,X.height,0,C,tt,null)),e.bindFramebuffer(s.FRAMEBUFFER,R),Qt(X)?u.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,ct,dt,n.get(J).__webglTexture,0,wt(X)):(dt===s.TEXTURE_2D||dt>=s.TEXTURE_CUBE_MAP_POSITIVE_X&&dt<=s.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&s.framebufferTexture2D(s.FRAMEBUFFER,ct,dt,n.get(J).__webglTexture,0),e.bindFramebuffer(s.FRAMEBUFFER,null)}function P(R,X,J){if(s.bindRenderbuffer(s.RENDERBUFFER,R),X.depthBuffer&&!X.stencilBuffer){let ct=s.DEPTH_COMPONENT16;if(J||Qt(X)){const dt=X.depthTexture;dt&&dt.isDepthTexture&&(dt.type===Wn?ct=s.DEPTH_COMPONENT32F:dt.type===Rn&&(ct=s.DEPTH_COMPONENT24));const C=wt(X);Qt(X)?u.renderbufferStorageMultisampleEXT(s.RENDERBUFFER,C,ct,X.width,X.height):s.renderbufferStorageMultisample(s.RENDERBUFFER,C,ct,X.width,X.height)}else s.renderbufferStorage(s.RENDERBUFFER,ct,X.width,X.height);s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.RENDERBUFFER,R)}else if(X.depthBuffer&&X.stencilBuffer){const ct=wt(X);J&&Qt(X)===!1?s.renderbufferStorageMultisample(s.RENDERBUFFER,ct,s.DEPTH24_STENCIL8,X.width,X.height):Qt(X)?u.renderbufferStorageMultisampleEXT(s.RENDERBUFFER,ct,s.DEPTH24_STENCIL8,X.width,X.height):s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_STENCIL,X.width,X.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.RENDERBUFFER,R)}else{const ct=X.isWebGLMultipleRenderTargets===!0?X.texture:[X.texture];for(let dt=0;dt<ct.length;dt++){const C=ct[dt],tt=i.convert(C.format,C.colorSpace),rt=i.convert(C.type),D=K(C.internalFormat,tt,rt,C.colorSpace),Gt=wt(X);J&&Qt(X)===!1?s.renderbufferStorageMultisample(s.RENDERBUFFER,Gt,D,X.width,X.height):Qt(X)?u.renderbufferStorageMultisampleEXT(s.RENDERBUFFER,Gt,D,X.width,X.height):s.renderbufferStorage(s.RENDERBUFFER,D,X.width,X.height)}}s.bindRenderbuffer(s.RENDERBUFFER,null)}function de(R,X){if(X&&X.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(s.FRAMEBUFFER,R),!(X.depthTexture&&X.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(X.depthTexture).__webglTexture||X.depthTexture.image.width!==X.width||X.depthTexture.image.height!==X.height)&&(X.depthTexture.image.width=X.width,X.depthTexture.image.height=X.height,X.depthTexture.needsUpdate=!0),et(X.depthTexture,0);const ct=n.get(X.depthTexture).__webglTexture,dt=wt(X);if(X.depthTexture.format===Fn)Qt(X)?u.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,ct,0,dt):s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,ct,0);else if(X.depthTexture.format===Si)Qt(X)?u.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.TEXTURE_2D,ct,0,dt):s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.TEXTURE_2D,ct,0);else throw new Error("Unknown depthTexture format")}function vt(R){const X=n.get(R),J=R.isWebGLCubeRenderTarget===!0;if(R.depthTexture&&!X.__autoAllocateDepthBuffer){if(J)throw new Error("target.depthTexture not supported in Cube render targets");de(X.__webglFramebuffer,R)}else if(J){X.__webglDepthbuffer=[];for(let ct=0;ct<6;ct++)e.bindFramebuffer(s.FRAMEBUFFER,X.__webglFramebuffer[ct]),X.__webglDepthbuffer[ct]=s.createRenderbuffer(),P(X.__webglDepthbuffer[ct],R,!1)}else e.bindFramebuffer(s.FRAMEBUFFER,X.__webglFramebuffer),X.__webglDepthbuffer=s.createRenderbuffer(),P(X.__webglDepthbuffer,R,!1);e.bindFramebuffer(s.FRAMEBUFFER,null)}function Yt(R,X,J){const ct=n.get(R);X!==void 0&&kt(ct.__webglFramebuffer,R,R.texture,s.COLOR_ATTACHMENT0,s.TEXTURE_2D),J!==void 0&&vt(R)}function zt(R){const X=R.texture,J=n.get(R),ct=n.get(X);R.addEventListener("dispose",$),R.isWebGLMultipleRenderTargets!==!0&&(ct.__webglTexture===void 0&&(ct.__webglTexture=s.createTexture()),ct.__version=X.version,r.memory.textures++);const dt=R.isWebGLCubeRenderTarget===!0,C=R.isWebGLMultipleRenderTargets===!0,tt=T(R)||o;if(dt){J.__webglFramebuffer=[];for(let rt=0;rt<6;rt++)J.__webglFramebuffer[rt]=s.createFramebuffer()}else{if(J.__webglFramebuffer=s.createFramebuffer(),C)if(a.drawBuffers){const rt=R.texture;for(let D=0,Gt=rt.length;D<Gt;D++){const Zt=n.get(rt[D]);Zt.__webglTexture===void 0&&(Zt.__webglTexture=s.createTexture(),r.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&R.samples>0&&Qt(R)===!1){const rt=C?X:[X];J.__webglMultisampledFramebuffer=s.createFramebuffer(),J.__webglColorRenderbuffer=[],e.bindFramebuffer(s.FRAMEBUFFER,J.__webglMultisampledFramebuffer);for(let D=0;D<rt.length;D++){const Gt=rt[D];J.__webglColorRenderbuffer[D]=s.createRenderbuffer(),s.bindRenderbuffer(s.RENDERBUFFER,J.__webglColorRenderbuffer[D]);const Zt=i.convert(Gt.format,Gt.colorSpace),gt=i.convert(Gt.type),Xt=K(Gt.internalFormat,Zt,gt,Gt.colorSpace,R.isXRRenderTarget===!0),Mt=wt(R);s.renderbufferStorageMultisample(s.RENDERBUFFER,Mt,Xt,R.width,R.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+D,s.RENDERBUFFER,J.__webglColorRenderbuffer[D])}s.bindRenderbuffer(s.RENDERBUFFER,null),R.depthBuffer&&(J.__webglDepthRenderbuffer=s.createRenderbuffer(),P(J.__webglDepthRenderbuffer,R,!0)),e.bindFramebuffer(s.FRAMEBUFFER,null)}}if(dt){e.bindTexture(s.TEXTURE_CUBE_MAP,ct.__webglTexture),Ct(s.TEXTURE_CUBE_MAP,X,tt);for(let rt=0;rt<6;rt++)kt(J.__webglFramebuffer[rt],R,X,s.COLOR_ATTACHMENT0,s.TEXTURE_CUBE_MAP_POSITIVE_X+rt);v(X,tt)&&N(s.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(C){const rt=R.texture;for(let D=0,Gt=rt.length;D<Gt;D++){const Zt=rt[D],gt=n.get(Zt);e.bindTexture(s.TEXTURE_2D,gt.__webglTexture),Ct(s.TEXTURE_2D,Zt,tt),kt(J.__webglFramebuffer,R,Zt,s.COLOR_ATTACHMENT0+D,s.TEXTURE_2D),v(Zt,tt)&&N(s.TEXTURE_2D)}e.unbindTexture()}else{let rt=s.TEXTURE_2D;(R.isWebGL3DRenderTarget||R.isWebGLArrayRenderTarget)&&(o?rt=R.isWebGL3DRenderTarget?s.TEXTURE_3D:s.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),e.bindTexture(rt,ct.__webglTexture),Ct(rt,X,tt),kt(J.__webglFramebuffer,R,X,s.COLOR_ATTACHMENT0,rt),v(X,tt)&&N(rt),e.unbindTexture()}R.depthBuffer&&vt(R)}function qt(R){const X=T(R)||o,J=R.isWebGLMultipleRenderTargets===!0?R.texture:[R.texture];for(let ct=0,dt=J.length;ct<dt;ct++){const C=J[ct];if(v(C,X)){const tt=R.isWebGLCubeRenderTarget?s.TEXTURE_CUBE_MAP:s.TEXTURE_2D,rt=n.get(C).__webglTexture;e.bindTexture(tt,rt),N(tt),e.unbindTexture()}}}function Ft(R){if(o&&R.samples>0&&Qt(R)===!1){const X=R.isWebGLMultipleRenderTargets?R.texture:[R.texture],J=R.width,ct=R.height;let dt=s.COLOR_BUFFER_BIT;const C=[],tt=R.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,rt=n.get(R),D=R.isWebGLMultipleRenderTargets===!0;if(D)for(let Gt=0;Gt<X.length;Gt++)e.bindFramebuffer(s.FRAMEBUFFER,rt.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+Gt,s.RENDERBUFFER,null),e.bindFramebuffer(s.FRAMEBUFFER,rt.__webglFramebuffer),s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0+Gt,s.TEXTURE_2D,null,0);e.bindFramebuffer(s.READ_FRAMEBUFFER,rt.__webglMultisampledFramebuffer),e.bindFramebuffer(s.DRAW_FRAMEBUFFER,rt.__webglFramebuffer);for(let Gt=0;Gt<X.length;Gt++){C.push(s.COLOR_ATTACHMENT0+Gt),R.depthBuffer&&C.push(tt);const Zt=rt.__ignoreDepthValues!==void 0?rt.__ignoreDepthValues:!1;if(Zt===!1&&(R.depthBuffer&&(dt|=s.DEPTH_BUFFER_BIT),R.stencilBuffer&&(dt|=s.STENCIL_BUFFER_BIT)),D&&s.framebufferRenderbuffer(s.READ_FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.RENDERBUFFER,rt.__webglColorRenderbuffer[Gt]),Zt===!0&&(s.invalidateFramebuffer(s.READ_FRAMEBUFFER,[tt]),s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER,[tt])),D){const gt=n.get(X[Gt]).__webglTexture;s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,gt,0)}s.blitFramebuffer(0,0,J,ct,0,0,J,ct,dt,s.NEAREST),b&&s.invalidateFramebuffer(s.READ_FRAMEBUFFER,C)}if(e.bindFramebuffer(s.READ_FRAMEBUFFER,null),e.bindFramebuffer(s.DRAW_FRAMEBUFFER,null),D)for(let Gt=0;Gt<X.length;Gt++){e.bindFramebuffer(s.FRAMEBUFFER,rt.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+Gt,s.RENDERBUFFER,rt.__webglColorRenderbuffer[Gt]);const Zt=n.get(X[Gt]).__webglTexture;e.bindFramebuffer(s.FRAMEBUFFER,rt.__webglFramebuffer),s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0+Gt,s.TEXTURE_2D,Zt,0)}e.bindFramebuffer(s.DRAW_FRAMEBUFFER,rt.__webglMultisampledFramebuffer)}}function wt(R){return Math.min(p,R.samples)}function Qt(R){const X=n.get(R);return o&&R.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&X.__useRenderToTexture!==!1}function he(R){const X=r.render.frame;x.get(R)!==X&&(x.set(R,X),R.update())}function ue(R,X){const J=R.colorSpace,ct=R.format,dt=R.type;return R.isCompressedTexture===!0||R.format===Xa||J!==on&&J!==Un&&(J===Ut?o===!1?t.has("EXT_sRGB")===!0&&ct===tn?(R.format=Xa,R.minFilter=Ue,R.generateMipmaps=!1):X=Vr.sRGBToLinear(X):(ct!==tn||dt!==vn)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",J)),X}this.allocateTextureUnit=q,this.resetTextureUnits=j,this.setTexture2D=et,this.setTexture2DArray=St,this.setTexture3D=F,this.setTextureCube=st,this.rebindTextures=Yt,this.setupRenderTarget=zt,this.updateRenderTargetMipmap=qt,this.updateMultisampleRenderTarget=Ft,this.setupDepthRenderbuffer=vt,this.setupFrameBufferTexture=kt,this.useMultisampledRTT=Qt}function om(s,t,e){const n=e.isWebGL2;function a(i,r=Un){let o;if(i===vn)return s.UNSIGNED_BYTE;if(i===Tr)return s.UNSIGNED_SHORT_4_4_4_4;if(i===Zr)return s.UNSIGNED_SHORT_5_5_5_1;if(i===Ul)return s.BYTE;if(i===kl)return s.SHORT;if(i===Wa)return s.UNSIGNED_SHORT;if(i===gr)return s.INT;if(i===Rn)return s.UNSIGNED_INT;if(i===Wn)return s.FLOAT;if(i===Hi)return n?s.HALF_FLOAT:(o=t.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(i===Dl)return s.ALPHA;if(i===tn)return s.RGBA;if(i===Al)return s.LUMINANCE;if(i===Jl)return s.LUMINANCE_ALPHA;if(i===Fn)return s.DEPTH_COMPONENT;if(i===Si)return s.DEPTH_STENCIL;if(i===Xa)return o=t.get("EXT_sRGB"),o!==null?o.SRGB_ALPHA_EXT:null;if(i===Bl)return s.RED;if(i===Rr)return s.RED_INTEGER;if(i===Ol)return s.RG;if(i===Wr)return s.RG_INTEGER;if(i===Cr)return s.RGBA_INTEGER;if(i===ws||i===Es||i===Ps||i===Ys)if(r===Ut)if(o=t.get("WEBGL_compressed_texture_s3tc_srgb"),o!==null){if(i===ws)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===Es)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===Ps)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===Ys)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(o=t.get("WEBGL_compressed_texture_s3tc"),o!==null){if(i===ws)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===Es)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===Ps)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===Ys)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===Ja||i===Ba||i===Oa||i===ja)if(o=t.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(i===Ja)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===Ba)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===Oa)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===ja)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===jl)return o=t.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if(i===Qa||i===qa)if(o=t.get("WEBGL_compressed_texture_etc"),o!==null){if(i===Qa)return r===Ut?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(i===qa)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===$a||i===to||i===eo||i===no||i===io||i===so||i===ao||i===oo||i===ro||i===lo||i===co||i===ho||i===uo||i===po)if(o=t.get("WEBGL_compressed_texture_astc"),o!==null){if(i===$a)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===to)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===eo)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===no)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===io)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===so)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===ao)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===oo)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===ro)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===lo)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===co)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===ho)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===uo)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===po)return r===Ut?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===Hs)if(o=t.get("EXT_texture_compression_bptc"),o!==null){if(i===Hs)return r===Ut?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(i===Ql||i===mo||i===bo||i===fo)if(o=t.get("EXT_texture_compression_rgtc"),o!==null){if(i===Hs)return o.COMPRESSED_RED_RGTC1_EXT;if(i===mo)return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===bo)return o.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===fo)return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return i===Hn?n?s.UNSIGNED_INT_24_8:(o=t.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null):s[i]!==void 0?s[i]:null}return{convert:a}}class rm extends qe{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class Gs extends Ze{constructor(){super(),this.isGroup=!0,this.type="Group"}}const lm={type:"move"};class da{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Gs,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Gs,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new V,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new V),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Gs,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new V,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new V),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let a=null,i=null,r=null;const o=this._targetRay,l=this._grip,c=this._hand;if(t&&e.session.visibilityState!=="visible-blurred"){if(c&&t.hand){r=!0;for(const y of t.hand.values()){const m=e.getJointPose(y,n),d=this._getHandJoint(c,y);m!==null&&(d.matrix.fromArray(m.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.matrixWorldNeedsUpdate=!0,d.jointRadius=m.radius),d.visible=m!==null}const h=c.joints["index-finger-tip"],p=c.joints["thumb-tip"],u=h.position.distanceTo(p.position),b=.02,x=.005;c.inputState.pinching&&u>b+x?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!c.inputState.pinching&&u<=b-x&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(i=e.getPose(t.gripSpace,n),i!==null&&(l.matrix.fromArray(i.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,i.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(i.linearVelocity)):l.hasLinearVelocity=!1,i.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(i.angularVelocity)):l.hasAngularVelocity=!1));o!==null&&(a=e.getPose(t.targetRaySpace,n),a===null&&i!==null&&(a=i),a!==null&&(o.matrix.fromArray(a.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,a.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(a.linearVelocity)):o.hasLinearVelocity=!1,a.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(a.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(lm)))}return o!==null&&(o.visible=a!==null),l!==null&&(l.visible=i!==null),c!==null&&(c.visible=r!==null),this}_getHandJoint(t,e){if(t.joints[e.jointName]===void 0){const n=new Gs;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class cm extends Pe{constructor(t,e,n,a,i,r,o,l,c,h){if(h=h!==void 0?h:Fn,h!==Fn&&h!==Si)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&h===Fn&&(n=Rn),n===void 0&&h===Si&&(n=Hn),super(null,a,i,r,o,l,h,n,c),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=o!==void 0?o:ve,this.minFilter=l!==void 0?l:ve,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}class dm extends Bn{constructor(t,e){super();const n=this;let a=null,i=1,r=null,o="local-floor",l=1,c=null,h=null,p=null,u=null,b=null,x=null;const y=e.getContextAttributes();let m=null,d=null;const Z=[],L=[];let T=null;const g=new qe;g.layers.enable(1),g.viewport=new Ge;const v=new qe;v.layers.enable(2),v.viewport=new Ge;const N=[g,v],K=new rm;K.layers.enable(1),K.layers.enable(2);let G=null,W=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getCamera=function(){},this.setUserCamera=function(F){T=F},this.getController=function(F){let st=Z[F];return st===void 0&&(st=new da,Z[F]=st),st.getTargetRaySpace()},this.getControllerGrip=function(F){let st=Z[F];return st===void 0&&(st=new da,Z[F]=st),st.getGripSpace()},this.getHand=function(F){let st=Z[F];return st===void 0&&(st=new da,Z[F]=st),st.getHandSpace()};function Q(F){const st=L.indexOf(F.inputSource);if(st===-1)return;const at=Z[st];at!==void 0&&(at.update(F.inputSource,F.frame,c||r),at.dispatchEvent({type:F.type,data:F.inputSource}))}function $(){a.removeEventListener("select",Q),a.removeEventListener("selectstart",Q),a.removeEventListener("selectend",Q),a.removeEventListener("squeeze",Q),a.removeEventListener("squeezestart",Q),a.removeEventListener("squeezeend",Q),a.removeEventListener("end",$),a.removeEventListener("inputsourceschange",Y);for(let F=0;F<Z.length;F++){const st=L[F];st!==null&&(L[F]=null,Z[F].disconnect(st))}G=null,W=null,t.setRenderTarget(m),b=null,u=null,p=null,a=null,d=null,St.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(F){i=F,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(F){o=F,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||r},this.setReferenceSpace=function(F){c=F},this.getBaseLayer=function(){return u!==null?u:b},this.getBinding=function(){return p},this.getFrame=function(){return x},this.getSession=function(){return a},this.setSession=async function(F){if(a=F,a!==null){if(m=t.getRenderTarget(),a.addEventListener("select",Q),a.addEventListener("selectstart",Q),a.addEventListener("selectend",Q),a.addEventListener("squeeze",Q),a.addEventListener("squeezestart",Q),a.addEventListener("squeezeend",Q),a.addEventListener("end",$),a.addEventListener("inputsourceschange",Y),y.xrCompatible!==!0&&await e.makeXRCompatible(),a.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const st={antialias:a.renderState.layers===void 0?y.antialias:!0,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:i};b=new XRWebGLLayer(a,e,st),a.updateRenderState({baseLayer:b}),d=new kn(b.framebufferWidth,b.framebufferHeight,{format:tn,type:vn,colorSpace:t.outputColorSpace,stencilBuffer:y.stencil})}else{let st=null,at=null,ft=null;y.depth&&(ft=y.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,st=y.stencil?Si:Fn,at=y.stencil?Hn:Rn);const yt={colorFormat:e.RGBA8,depthFormat:ft,scaleFactor:i};p=new XRWebGLBinding(a,e),u=p.createProjectionLayer(yt),a.updateRenderState({layers:[u]}),d=new kn(u.textureWidth,u.textureHeight,{format:tn,type:vn,depthTexture:new cm(u.textureWidth,u.textureHeight,at,void 0,void 0,void 0,void 0,void 0,void 0,st),stencilBuffer:y.stencil,colorSpace:t.outputColorSpace,samples:y.antialias?4:0});const Ct=t.properties.get(d);Ct.__ignoreDepthValues=u.ignoreDepthValues}d.isXRRenderTarget=!0,this.setFoveation(l),c=null,r=await a.requestReferenceSpace(o),St.setContext(a),St.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(a!==null)return a.environmentBlendMode};function Y(F){for(let st=0;st<F.removed.length;st++){const at=F.removed[st],ft=L.indexOf(at);ft>=0&&(L[ft]=null,Z[ft].disconnect(at))}for(let st=0;st<F.added.length;st++){const at=F.added[st];let ft=L.indexOf(at);if(ft===-1){for(let Ct=0;Ct<Z.length;Ct++)if(Ct>=L.length){L.push(at),ft=Ct;break}else if(L[Ct]===null){L[Ct]=at,ft=Ct;break}if(ft===-1)break}const yt=Z[ft];yt&&yt.connect(at)}}const U=new V,A=new V;function nt(F,st,at){U.setFromMatrixPosition(st.matrixWorld),A.setFromMatrixPosition(at.matrixWorld);const ft=U.distanceTo(A),yt=st.projectionMatrix.elements,Ct=at.projectionMatrix.elements,Ht=yt[14]/(yt[10]-1),It=yt[14]/(yt[10]+1),ae=(yt[9]+1)/yt[5],kt=(yt[9]-1)/yt[5],P=(yt[8]-1)/yt[0],de=(Ct[8]+1)/Ct[0],vt=Ht*P,Yt=Ht*de,zt=ft/(-P+de),qt=zt*-P;st.matrixWorld.decompose(F.position,F.quaternion,F.scale),F.translateX(qt),F.translateZ(zt),F.matrixWorld.compose(F.position,F.quaternion,F.scale),F.matrixWorldInverse.copy(F.matrixWorld).invert();const Ft=Ht+zt,wt=It+zt,Qt=vt-qt,he=Yt+(ft-qt),ue=ae*It/wt*Ft,R=kt*It/wt*Ft;F.projectionMatrix.makePerspective(Qt,he,ue,R,Ft,wt),F.projectionMatrixInverse.copy(F.projectionMatrix).invert()}function j(F,st){st===null?F.matrixWorld.copy(F.matrix):F.matrixWorld.multiplyMatrices(st.matrixWorld,F.matrix),F.matrixWorldInverse.copy(F.matrixWorld).invert()}this.updateCameraXR=function(F){if(a===null)return F;T&&(F=T),K.near=v.near=g.near=F.near,K.far=v.far=g.far=F.far,(G!==K.near||W!==K.far)&&(a.updateRenderState({depthNear:K.near,depthFar:K.far}),G=K.near,W=K.far);const st=F.parent,at=K.cameras;j(K,st);for(let ft=0;ft<at.length;ft++)j(at[ft],st);return at.length===2?nt(K,g,v):K.projectionMatrix.copy(g.projectionMatrix),T&&q(K,st),K};function q(F,st){const at=T;st===null?at.matrix.copy(F.matrixWorld):(at.matrix.copy(st.matrixWorld),at.matrix.invert(),at.matrix.multiply(F.matrixWorld)),at.matrix.decompose(at.position,at.quaternion,at.scale),at.updateMatrixWorld(!0);const ft=at.children;for(let yt=0,Ct=ft.length;yt<Ct;yt++)ft[yt].updateMatrixWorld(!0);at.projectionMatrix.copy(F.projectionMatrix),at.projectionMatrixInverse.copy(F.projectionMatrixInverse),at.isPerspectiveCamera&&(at.fov=La*2*Math.atan(1/at.projectionMatrix.elements[5]),at.zoom=1)}this.getFoveation=function(){if(!(u===null&&b===null))return l},this.setFoveation=function(F){l=F,u!==null&&(u.fixedFoveation=F),b!==null&&b.fixedFoveation!==void 0&&(b.fixedFoveation=F)};let lt=null;function et(F,st){if(h=st.getViewerPose(c||r),x=st,h!==null){const at=h.views;b!==null&&(t.setRenderTargetFramebuffer(d,b.framebuffer),t.setRenderTarget(d));let ft=!1;at.length!==K.cameras.length&&(K.cameras.length=0,ft=!0);for(let yt=0;yt<at.length;yt++){const Ct=at[yt];let Ht=null;if(b!==null)Ht=b.getViewport(Ct);else{const ae=p.getViewSubImage(u,Ct);Ht=ae.viewport,yt===0&&(t.setRenderTargetTextures(d,ae.colorTexture,u.ignoreDepthValues?void 0:ae.depthStencilTexture),t.setRenderTarget(d))}let It=N[yt];It===void 0&&(It=new qe,It.layers.enable(yt),It.viewport=new Ge,N[yt]=It),It.matrix.fromArray(Ct.transform.matrix),It.matrix.decompose(It.position,It.quaternion,It.scale),It.projectionMatrix.fromArray(Ct.projectionMatrix),It.projectionMatrixInverse.copy(It.projectionMatrix).invert(),It.viewport.set(Ht.x,Ht.y,Ht.width,Ht.height),yt===0&&(K.matrix.copy(It.matrix),K.matrix.decompose(K.position,K.quaternion,K.scale)),ft===!0&&K.cameras.push(It)}}for(let at=0;at<Z.length;at++){const ft=L[at],yt=Z[at];ft!==null&&yt!==void 0&&yt.update(ft,st,c||r)}lt&&lt(F,st),st.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:st}),x=null}const St=new kr;St.setAnimationLoop(et),this.setAnimationLoop=function(F){lt=F},this.dispose=function(){}}}function hm(s,t){function e(m,d){m.matrixAutoUpdate===!0&&m.updateMatrix(),d.value.copy(m.matrix)}function n(m,d){d.color.getRGB(m.fogColor.value,Fr(s)),d.isFog?(m.fogNear.value=d.near,m.fogFar.value=d.far):d.isFogExp2&&(m.fogDensity.value=d.density)}function a(m,d,Z,L,T){d.isMeshBasicMaterial||d.isMeshLambertMaterial?i(m,d):d.isMeshToonMaterial?(i(m,d),p(m,d)):d.isMeshPhongMaterial?(i(m,d),h(m,d)):d.isMeshStandardMaterial?(i(m,d),u(m,d),d.isMeshPhysicalMaterial&&b(m,d,T)):d.isMeshMatcapMaterial?(i(m,d),x(m,d)):d.isMeshDepthMaterial?i(m,d):d.isMeshDistanceMaterial?(i(m,d),y(m,d)):d.isMeshNormalMaterial?i(m,d):d.isLineBasicMaterial?(r(m,d),d.isLineDashedMaterial&&o(m,d)):d.isPointsMaterial?l(m,d,Z,L):d.isSpriteMaterial?c(m,d):d.isShadowMaterial?(m.color.value.copy(d.color),m.opacity.value=d.opacity):d.isShaderMaterial&&(d.uniformsNeedUpdate=!1)}function i(m,d){m.opacity.value=d.opacity,d.color&&m.diffuse.value.copy(d.color),d.emissive&&m.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),d.map&&(m.map.value=d.map,e(d.map,m.mapTransform)),d.alphaMap&&(m.alphaMap.value=d.alphaMap,e(d.alphaMap,m.alphaMapTransform)),d.bumpMap&&(m.bumpMap.value=d.bumpMap,e(d.bumpMap,m.bumpMapTransform),m.bumpScale.value=d.bumpScale,d.side===Ne&&(m.bumpScale.value*=-1)),d.normalMap&&(m.normalMap.value=d.normalMap,e(d.normalMap,m.normalMapTransform),m.normalScale.value.copy(d.normalScale),d.side===Ne&&m.normalScale.value.negate()),d.displacementMap&&(m.displacementMap.value=d.displacementMap,e(d.displacementMap,m.displacementMapTransform),m.displacementScale.value=d.displacementScale,m.displacementBias.value=d.displacementBias),d.emissiveMap&&(m.emissiveMap.value=d.emissiveMap,e(d.emissiveMap,m.emissiveMapTransform)),d.specularMap&&(m.specularMap.value=d.specularMap,e(d.specularMap,m.specularMapTransform)),d.alphaTest>0&&(m.alphaTest.value=d.alphaTest);const Z=t.get(d).envMap;if(Z&&(m.envMap.value=Z,m.flipEnvMap.value=Z.isCubeTexture&&Z.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=d.reflectivity,m.ior.value=d.ior,m.refractionRatio.value=d.refractionRatio),d.lightMap){m.lightMap.value=d.lightMap;const L=s.useLegacyLights===!0?Math.PI:1;m.lightMapIntensity.value=d.lightMapIntensity*L,e(d.lightMap,m.lightMapTransform)}d.aoMap&&(m.aoMap.value=d.aoMap,m.aoMapIntensity.value=d.aoMapIntensity,e(d.aoMap,m.aoMapTransform))}function r(m,d){m.diffuse.value.copy(d.color),m.opacity.value=d.opacity,d.map&&(m.map.value=d.map,e(d.map,m.mapTransform))}function o(m,d){m.dashSize.value=d.dashSize,m.totalSize.value=d.dashSize+d.gapSize,m.scale.value=d.scale}function l(m,d,Z,L){m.diffuse.value.copy(d.color),m.opacity.value=d.opacity,m.size.value=d.size*Z,m.scale.value=L*.5,d.map&&(m.map.value=d.map,e(d.map,m.uvTransform)),d.alphaMap&&(m.alphaMap.value=d.alphaMap,e(d.alphaMap,m.alphaMapTransform)),d.alphaTest>0&&(m.alphaTest.value=d.alphaTest)}function c(m,d){m.diffuse.value.copy(d.color),m.opacity.value=d.opacity,m.rotation.value=d.rotation,d.map&&(m.map.value=d.map,e(d.map,m.mapTransform)),d.alphaMap&&(m.alphaMap.value=d.alphaMap,e(d.alphaMap,m.alphaMapTransform)),d.alphaTest>0&&(m.alphaTest.value=d.alphaTest)}function h(m,d){m.specular.value.copy(d.specular),m.shininess.value=Math.max(d.shininess,1e-4)}function p(m,d){d.gradientMap&&(m.gradientMap.value=d.gradientMap)}function u(m,d){m.metalness.value=d.metalness,d.metalnessMap&&(m.metalnessMap.value=d.metalnessMap,e(d.metalnessMap,m.metalnessMapTransform)),m.roughness.value=d.roughness,d.roughnessMap&&(m.roughnessMap.value=d.roughnessMap,e(d.roughnessMap,m.roughnessMapTransform)),t.get(d).envMap&&(m.envMapIntensity.value=d.envMapIntensity)}function b(m,d,Z){m.ior.value=d.ior,d.sheen>0&&(m.sheenColor.value.copy(d.sheenColor).multiplyScalar(d.sheen),m.sheenRoughness.value=d.sheenRoughness,d.sheenColorMap&&(m.sheenColorMap.value=d.sheenColorMap,e(d.sheenColorMap,m.sheenColorMapTransform)),d.sheenRoughnessMap&&(m.sheenRoughnessMap.value=d.sheenRoughnessMap,e(d.sheenRoughnessMap,m.sheenRoughnessMapTransform))),d.clearcoat>0&&(m.clearcoat.value=d.clearcoat,m.clearcoatRoughness.value=d.clearcoatRoughness,d.clearcoatMap&&(m.clearcoatMap.value=d.clearcoatMap,e(d.clearcoatMap,m.clearcoatMapTransform)),d.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=d.clearcoatRoughnessMap,e(d.clearcoatRoughnessMap,m.clearcoatRoughnessMapTransform)),d.clearcoatNormalMap&&(m.clearcoatNormalMap.value=d.clearcoatNormalMap,e(d.clearcoatNormalMap,m.clearcoatNormalMapTransform),m.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),d.side===Ne&&m.clearcoatNormalScale.value.negate())),d.iridescence>0&&(m.iridescence.value=d.iridescence,m.iridescenceIOR.value=d.iridescenceIOR,m.iridescenceThicknessMinimum.value=d.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=d.iridescenceThicknessRange[1],d.iridescenceMap&&(m.iridescenceMap.value=d.iridescenceMap,e(d.iridescenceMap,m.iridescenceMapTransform)),d.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=d.iridescenceThicknessMap,e(d.iridescenceThicknessMap,m.iridescenceThicknessMapTransform))),d.transmission>0&&(m.transmission.value=d.transmission,m.transmissionSamplerMap.value=Z.texture,m.transmissionSamplerSize.value.set(Z.width,Z.height),d.transmissionMap&&(m.transmissionMap.value=d.transmissionMap,e(d.transmissionMap,m.transmissionMapTransform)),m.thickness.value=d.thickness,d.thicknessMap&&(m.thicknessMap.value=d.thicknessMap,e(d.thicknessMap,m.thicknessMapTransform)),m.attenuationDistance.value=d.attenuationDistance,m.attenuationColor.value.copy(d.attenuationColor)),d.anisotropy>0&&(m.anisotropyVector.value.set(d.anisotropy*Math.cos(d.anisotropyRotation),d.anisotropy*Math.sin(d.anisotropyRotation)),d.anisotropyMap&&(m.anisotropyMap.value=d.anisotropyMap,e(d.anisotropyMap,m.anisotropyMapTransform))),m.specularIntensity.value=d.specularIntensity,m.specularColor.value.copy(d.specularColor),d.specularColorMap&&(m.specularColorMap.value=d.specularColorMap,e(d.specularColorMap,m.specularColorMapTransform)),d.specularIntensityMap&&(m.specularIntensityMap.value=d.specularIntensityMap,e(d.specularIntensityMap,m.specularIntensityMapTransform))}function x(m,d){d.matcap&&(m.matcap.value=d.matcap)}function y(m,d){const Z=t.get(d).light;m.referencePosition.value.setFromMatrixPosition(Z.matrixWorld),m.nearDistance.value=Z.shadow.camera.near,m.farDistance.value=Z.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:a}}function um(s,t,e,n){let a={},i={},r=[];const o=e.isWebGL2?s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(Z,L){const T=L.program;n.uniformBlockBinding(Z,T)}function c(Z,L){let T=a[Z.id];T===void 0&&(x(Z),T=h(Z),a[Z.id]=T,Z.addEventListener("dispose",m));const g=L.program;n.updateUBOMapping(Z,g);const v=t.render.frame;i[Z.id]!==v&&(u(Z),i[Z.id]=v)}function h(Z){const L=p();Z.__bindingPointIndex=L;const T=s.createBuffer(),g=Z.__size,v=Z.usage;return s.bindBuffer(s.UNIFORM_BUFFER,T),s.bufferData(s.UNIFORM_BUFFER,g,v),s.bindBuffer(s.UNIFORM_BUFFER,null),s.bindBufferBase(s.UNIFORM_BUFFER,L,T),T}function p(){for(let Z=0;Z<o;Z++)if(r.indexOf(Z)===-1)return r.push(Z),Z;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function u(Z){const L=a[Z.id],T=Z.uniforms,g=Z.__cache;s.bindBuffer(s.UNIFORM_BUFFER,L);for(let v=0,N=T.length;v<N;v++){const K=T[v];if(b(K,v,g)===!0){const G=K.__offset,W=Array.isArray(K.value)?K.value:[K.value];let Q=0;for(let $=0;$<W.length;$++){const Y=W[$],U=y(Y);typeof Y=="number"?(K.__data[0]=Y,s.bufferSubData(s.UNIFORM_BUFFER,G+Q,K.__data)):Y.isMatrix3?(K.__data[0]=Y.elements[0],K.__data[1]=Y.elements[1],K.__data[2]=Y.elements[2],K.__data[3]=Y.elements[0],K.__data[4]=Y.elements[3],K.__data[5]=Y.elements[4],K.__data[6]=Y.elements[5],K.__data[7]=Y.elements[0],K.__data[8]=Y.elements[6],K.__data[9]=Y.elements[7],K.__data[10]=Y.elements[8],K.__data[11]=Y.elements[0]):(Y.toArray(K.__data,Q),Q+=U.storage/Float32Array.BYTES_PER_ELEMENT)}s.bufferSubData(s.UNIFORM_BUFFER,G,K.__data)}}s.bindBuffer(s.UNIFORM_BUFFER,null)}function b(Z,L,T){const g=Z.value;if(T[L]===void 0){if(typeof g=="number")T[L]=g;else{const v=Array.isArray(g)?g:[g],N=[];for(let K=0;K<v.length;K++)N.push(v[K].clone());T[L]=N}return!0}else if(typeof g=="number"){if(T[L]!==g)return T[L]=g,!0}else{const v=Array.isArray(T[L])?T[L]:[T[L]],N=Array.isArray(g)?g:[g];for(let K=0;K<v.length;K++){const G=v[K];if(G.equals(N[K])===!1)return G.copy(N[K]),!0}}return!1}function x(Z){const L=Z.uniforms;let T=0;const g=16;let v=0;for(let N=0,K=L.length;N<K;N++){const G=L[N],W={boundary:0,storage:0},Q=Array.isArray(G.value)?G.value:[G.value];for(let $=0,Y=Q.length;$<Y;$++){const U=Q[$],A=y(U);W.boundary+=A.boundary,W.storage+=A.storage}if(G.__data=new Float32Array(W.storage/Float32Array.BYTES_PER_ELEMENT),G.__offset=T,N>0){v=T%g;const $=g-v;v!==0&&$-W.boundary<0&&(T+=g-v,G.__offset=T)}T+=W.storage}return v=T%g,v>0&&(T+=g-v),Z.__size=T,Z.__cache={},this}function y(Z){const L={boundary:0,storage:0};return typeof Z=="number"?(L.boundary=4,L.storage=4):Z.isVector2?(L.boundary=8,L.storage=8):Z.isVector3||Z.isColor?(L.boundary=16,L.storage=12):Z.isVector4?(L.boundary=16,L.storage=16):Z.isMatrix3?(L.boundary=48,L.storage=48):Z.isMatrix4?(L.boundary=64,L.storage=64):Z.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",Z),L}function m(Z){const L=Z.target;L.removeEventListener("dispose",m);const T=r.indexOf(L.__bindingPointIndex);r.splice(T,1),s.deleteBuffer(a[L.id]),delete a[L.id],delete i[L.id]}function d(){for(const Z in a)s.deleteBuffer(a[Z]);r=[],a={},i={}}return{bind:l,update:c,dispose:d}}function pm(){const s=gs("canvas");return s.style.display="block",s}class Or{constructor(t={}){const{canvas:e=pm(),context:n=null,depth:a=!0,stencil:i=!0,alpha:r=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:p=!1}=t;this.isWebGLRenderer=!0;let u;n!==null?u=n.getContextAttributes().alpha:u=r;const b=new Uint32Array(4),x=new Int32Array(4);let y=null,m=null;const d=[],Z=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputColorSpace=Ut,this.useLegacyLights=!0,this.toneMapping=Xn,this.toneMappingExposure=1;const L=this;let T=!1,g=0,v=0,N=null,K=-1,G=null;const W=new Ge,Q=new Ge;let $=null;const Y=new $t(0);let U=0,A=e.width,nt=e.height,j=1,q=null,lt=null;const et=new Ge(0,0,A,nt),St=new Ge(0,0,A,nt);let F=!1;const st=new za;let at=!1,ft=!1,yt=null;const Ct=new me,Ht=new Kt,It=new V,ae={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function kt(){return N===null?j:1}let P=n;function de(S,H){for(let B=0;B<S.length;B++){const w=S[B],O=e.getContext(w,H);if(O!==null)return O}return null}try{const S={alpha:!0,depth:a,stencil:i,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:p};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Ra}`),e.addEventListener("webglcontextlost",pt,!1),e.addEventListener("webglcontextrestored",k,!1),e.addEventListener("webglcontextcreationerror",ht,!1),P===null){const H=["webgl2","webgl","experimental-webgl"];if(L.isWebGL1Renderer===!0&&H.shift(),P=de(H,S),P===null)throw de(H)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}P instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),P.getShaderPrecisionFormat===void 0&&(P.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(S){throw console.error("THREE.WebGLRenderer: "+S.message),S}let vt,Yt,zt,qt,Ft,wt,Qt,he,ue,R,X,J,ct,dt,C,tt,rt,D,Gt,Zt,gt,Xt,Mt,Vt;function Dt(){vt=new gu(P),Yt=new Mu(P,vt,t),vt.init(Yt),Xt=new om(P,vt,Yt),zt=new sm(P,vt,Yt),qt=new Ru(P),Ft=new kp,wt=new am(P,vt,zt,Ft,Yt,Xt,qt),Qt=new Gu(L),he=new Su(L),ue=new Yc(P,Yt),Mt=new fu(P,vt,ue,Yt),R=new Tu(P,ue,qt,Mt),X=new zu(P,R,ue,qt),Gt=new vu(P,Yt,wt),tt=new xu(Ft),J=new Up(L,Qt,he,vt,Yt,Mt,tt),ct=new hm(L,Ft),dt=new Ap,C=new qp(vt,Yt),D=new bu(L,Qt,he,zt,X,u,l),rt=new im(L,X,Yt),Vt=new um(P,qt,Yt,zt),Zt=new yu(P,vt,qt,Yt),gt=new Zu(P,vt,qt,Yt),qt.programs=J.programs,L.capabilities=Yt,L.extensions=vt,L.properties=Ft,L.renderLists=dt,L.shadowMap=rt,L.state=zt,L.info=qt}Dt();const I=new dm(L,P);this.xr=I,this.getContext=function(){return P},this.getContextAttributes=function(){return P.getContextAttributes()},this.forceContextLoss=function(){const S=vt.get("WEBGL_lose_context");S&&S.loseContext()},this.forceContextRestore=function(){const S=vt.get("WEBGL_lose_context");S&&S.restoreContext()},this.getPixelRatio=function(){return j},this.setPixelRatio=function(S){S!==void 0&&(j=S,this.setSize(A,nt,!1))},this.getSize=function(S){return S.set(A,nt)},this.setSize=function(S,H,B=!0){if(I.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}A=S,nt=H,e.width=Math.floor(S*j),e.height=Math.floor(H*j),B===!0&&(e.style.width=S+"px",e.style.height=H+"px"),this.setViewport(0,0,S,H)},this.getDrawingBufferSize=function(S){return S.set(A*j,nt*j).floor()},this.setDrawingBufferSize=function(S,H,B){A=S,nt=H,j=B,e.width=Math.floor(S*B),e.height=Math.floor(H*B),this.setViewport(0,0,S,H)},this.getCurrentViewport=function(S){return S.copy(W)},this.getViewport=function(S){return S.copy(et)},this.setViewport=function(S,H,B,w){S.isVector4?et.set(S.x,S.y,S.z,S.w):et.set(S,H,B,w),zt.viewport(W.copy(et).multiplyScalar(j).floor())},this.getScissor=function(S){return S.copy(St)},this.setScissor=function(S,H,B,w){S.isVector4?St.set(S.x,S.y,S.z,S.w):St.set(S,H,B,w),zt.scissor(Q.copy(St).multiplyScalar(j).floor())},this.getScissorTest=function(){return F},this.setScissorTest=function(S){zt.setScissorTest(F=S)},this.setOpaqueSort=function(S){q=S},this.setTransparentSort=function(S){lt=S},this.getClearColor=function(S){return S.copy(D.getClearColor())},this.setClearColor=function(){D.setClearColor.apply(D,arguments)},this.getClearAlpha=function(){return D.getClearAlpha()},this.setClearAlpha=function(){D.setClearAlpha.apply(D,arguments)},this.clear=function(S=!0,H=!0,B=!0){let w=0;if(S){let O=!1;if(N!==null){const f=N.texture.format;O=f===Cr||f===Wr||f===Rr}if(O){const f=N.texture.type,Rt=f===vn||f===Rn||f===Wa||f===Hn||f===Tr||f===Zr,Nt=D.getClearColor(),Wt=D.getClearAlpha(),_t=Nt.r,it=Nt.g,Et=Nt.b,te=Ft.get(N).__webglFramebuffer;Rt?(b[0]=_t,b[1]=it,b[2]=Et,b[3]=Wt,P.clearBufferuiv(P.COLOR,te,b)):(x[0]=_t,x[1]=it,x[2]=Et,x[3]=Wt,P.clearBufferiv(P.COLOR,te,x))}else w|=P.COLOR_BUFFER_BIT}H&&(w|=P.DEPTH_BUFFER_BIT),B&&(w|=P.STENCIL_BUFFER_BIT),P.clear(w)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",pt,!1),e.removeEventListener("webglcontextrestored",k,!1),e.removeEventListener("webglcontextcreationerror",ht,!1),dt.dispose(),C.dispose(),Ft.dispose(),Qt.dispose(),he.dispose(),X.dispose(),Mt.dispose(),Vt.dispose(),J.dispose(),I.dispose(),I.removeEventListener("sessionstart",ie),I.removeEventListener("sessionend",He),yt&&(yt.dispose(),yt=null),Xe.stop()};function pt(S){S.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),T=!0}function k(){console.log("THREE.WebGLRenderer: Context Restored."),T=!1;const S=qt.autoReset,H=rt.enabled,B=rt.autoUpdate,w=rt.needsUpdate,O=rt.type;Dt(),qt.autoReset=S,rt.enabled=H,rt.autoUpdate=B,rt.needsUpdate=w,rt.type=O}function ht(S){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",S.statusMessage)}function bt(S){const H=S.target;H.removeEventListener("dispose",bt),jt(H)}function jt(S){oe(S),Ft.remove(S)}function oe(S){const H=Ft.get(S).programs;H!==void 0&&(H.forEach(function(B){J.releaseProgram(B)}),S.isShaderMaterial&&J.releaseShaderCache(S))}this.renderBufferDirect=function(S,H,B,w,O,f){H===null&&(H=ae);const Rt=O.isMesh&&O.matrixWorld.determinant()<0,Nt=vs(S,H,B,w,O);zt.setMaterial(w,Rt);let Wt=B.index,_t=1;w.wireframe===!0&&(Wt=R.getWireframeAttribute(B),_t=2);const it=B.drawRange,Et=B.attributes.position;let te=it.start*_t,xt=(it.start+it.count)*_t;f!==null&&(te=Math.max(te,f.start*_t),xt=Math.min(xt,(f.start+f.count)*_t)),Wt!==null?(te=Math.max(te,0),xt=Math.min(xt,Wt.count)):Et!=null&&(te=Math.max(te,0),xt=Math.min(xt,Et.count));const Ie=xt-te;if(Ie<0||Ie===1/0)return;Mt.setup(O,w,Nt,B,Wt);let De,le=Zt;if(Wt!==null&&(De=ue.get(Wt),le=gt,le.setIndex(De)),O.isMesh)w.wireframe===!0?(zt.setLineWidth(w.wireframeLinewidth*kt()),le.setMode(P.LINES)):le.setMode(P.TRIANGLES);else if(O.isLine){let Bt=w.linewidth;Bt===void 0&&(Bt=1),zt.setLineWidth(Bt*kt()),O.isLineSegments?le.setMode(P.LINES):O.isLineLoop?le.setMode(P.LINE_LOOP):le.setMode(P.LINE_STRIP)}else O.isPoints?le.setMode(P.POINTS):O.isSprite&&le.setMode(P.TRIANGLES);if(O.isInstancedMesh)le.renderInstances(te,Ie,O.count);else if(B.isInstancedBufferGeometry){const Bt=B._maxInstanceCount!==void 0?B._maxInstanceCount:1/0,qn=Math.min(B.instanceCount,Bt);le.renderInstances(te,Ie,qn)}else le.render(te,Ie)},this.compile=function(S,H){function B(w,O,f){w.transparent===!0&&w.side===nn&&w.forceSinglePass===!1?(w.side=Ne,w.needsUpdate=!0,Qn(w,O,f),w.side=zn,w.needsUpdate=!0,Qn(w,O,f),w.side=nn):Qn(w,O,f)}m=C.get(S),m.init(),Z.push(m),S.traverseVisible(function(w){w.isLight&&w.layers.test(H.layers)&&(m.pushLight(w),w.castShadow&&m.pushShadow(w))}),m.setupLights(L.useLegacyLights),S.traverse(function(w){const O=w.material;if(O)if(Array.isArray(O))for(let f=0;f<O.length;f++){const Rt=O[f];B(Rt,S,w)}else B(O,S,w)}),Z.pop(),m=null};let re=null;function rn(S){re&&re(S)}function ie(){Xe.stop()}function He(){Xe.start()}const Xe=new kr;Xe.setAnimationLoop(rn),typeof self<"u"&&Xe.setContext(self),this.setAnimationLoop=function(S){re=S,I.setAnimationLoop(S),S===null?Xe.stop():Xe.start()},I.addEventListener("sessionstart",ie),I.addEventListener("sessionend",He),this.render=function(S,H){if(H!==void 0&&H.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(T===!0)return;S.matrixWorldAutoUpdate===!0&&S.updateMatrixWorld(),H.parent===null&&H.matrixWorldAutoUpdate===!0&&H.updateMatrixWorld(),I.enabled===!0&&I.isPresenting===!0&&(H=I.updateCameraXR(H)),S.isScene===!0&&S.onBeforeRender(L,S,H,N),m=C.get(S,Z.length),m.init(),Z.push(m),Ct.multiplyMatrices(H.projectionMatrix,H.matrixWorldInverse),st.setFromProjectionMatrix(Ct),ft=this.localClippingEnabled,at=tt.init(this.clippingPlanes,ft),y=dt.get(S,d.length),y.init(),d.push(y),ki(S,H,0,L.sortObjects),y.finish(),L.sortObjects===!0&&y.sort(q,lt),at===!0&&tt.beginShadows();const B=m.state.shadowsArray;if(rt.render(B,S,H),at===!0&&tt.endShadows(),this.info.autoReset===!0&&this.info.reset(),this.info.render.frame++,D.render(y,S),m.setupLights(L.useLegacyLights),H.isArrayCamera){const w=H.cameras;for(let O=0,f=w.length;O<f;O++){const Rt=w[O];Ri(y,S,Rt,Rt.viewport)}}else Ri(y,S,H);N!==null&&(wt.updateMultisampleRenderTarget(N),wt.updateRenderTargetMipmap(N)),S.isScene===!0&&S.onAfterRender(L,S,H),Mt.resetDefaultState(),K=-1,G=null,Z.pop(),Z.length>0?m=Z[Z.length-1]:m=null,d.pop(),d.length>0?y=d[d.length-1]:y=null};function ki(S,H,B,w){if(S.visible===!1)return;if(S.layers.test(H.layers)){if(S.isGroup)B=S.renderOrder;else if(S.isLOD)S.autoUpdate===!0&&S.update(H);else if(S.isLight)m.pushLight(S),S.castShadow&&m.pushShadow(S);else if(S.isSprite){if(!S.frustumCulled||st.intersectsSprite(S)){w&&It.setFromMatrixPosition(S.matrixWorld).applyMatrix4(Ct);const Rt=X.update(S),Nt=S.material;Nt.visible&&y.push(S,Rt,Nt,B,It.z,null)}}else if((S.isMesh||S.isLine||S.isPoints)&&(!S.frustumCulled||st.intersectsObject(S))){S.isSkinnedMesh&&S.skeleton.frame!==qt.render.frame&&(S.skeleton.update(),S.skeleton.frame=qt.render.frame);const Rt=X.update(S),Nt=S.material;if(w&&(S.boundingSphere!==void 0?(S.boundingSphere===null&&S.computeBoundingSphere(),It.copy(S.boundingSphere.center)):(Rt.boundingSphere===null&&Rt.computeBoundingSphere(),It.copy(Rt.boundingSphere.center)),It.applyMatrix4(S.matrixWorld).applyMatrix4(Ct)),Array.isArray(Nt)){const Wt=Rt.groups;for(let _t=0,it=Wt.length;_t<it;_t++){const Et=Wt[_t],te=Nt[Et.materialIndex];te&&te.visible&&y.push(S,Rt,te,B,It.z,Et)}}else Nt.visible&&y.push(S,Rt,Nt,B,It.z,null)}}const f=S.children;for(let Rt=0,Nt=f.length;Rt<Nt;Rt++)ki(f[Rt],H,B,w)}function Ri(S,H,B,w){const O=S.opaque,f=S.transmissive,Rt=S.transparent;m.setupLightsView(B),at===!0&&tt.setGlobalState(L.clippingPlanes,B),f.length>0&&Cs(O,f,H,B),w&&zt.viewport(W.copy(w)),O.length>0&&jn(O,H,B),f.length>0&&jn(f,H,B),Rt.length>0&&jn(Rt,H,B),zt.buffers.depth.setTest(!0),zt.buffers.depth.setMask(!0),zt.buffers.color.setMask(!0),zt.setPolygonOffset(!1)}function Cs(S,H,B,w){const O=Yt.isWebGL2;yt===null&&(yt=new kn(1,1,{generateMipmaps:!0,type:vt.has("EXT_color_buffer_half_float")?Hi:vn,minFilter:Yi,samples:O&&o===!0?4:0})),L.getDrawingBufferSize(Ht),O?yt.setSize(Ht.x,Ht.y):yt.setSize(Sa(Ht.x),Sa(Ht.y));const f=L.getRenderTarget();L.setRenderTarget(yt),L.getClearColor(Y),U=L.getClearAlpha(),U<1&&L.setClearColor(16777215,.5),L.clear();const Rt=L.toneMapping;L.toneMapping=Xn,jn(S,B,w),wt.updateMultisampleRenderTarget(yt),wt.updateRenderTargetMipmap(yt);let Nt=!1;for(let Wt=0,_t=H.length;Wt<_t;Wt++){const it=H[Wt],Et=it.object,te=it.geometry,xt=it.material,Ie=it.group;if(xt.side===nn&&Et.layers.test(w.layers)){const De=xt.side;xt.side=Ne,xt.needsUpdate=!0,Di(Et,B,w,te,xt,Ie),xt.side=De,xt.needsUpdate=!0,Nt=!0}}Nt===!0&&(wt.updateMultisampleRenderTarget(yt),wt.updateRenderTargetMipmap(yt)),L.setRenderTarget(f),L.setClearColor(Y,U),L.toneMapping=Rt}function jn(S,H,B){const w=H.isScene===!0?H.overrideMaterial:null;for(let O=0,f=S.length;O<f;O++){const Rt=S[O],Nt=Rt.object,Wt=Rt.geometry,_t=w===null?Rt.material:w,it=Rt.group;Nt.layers.test(B.layers)&&Di(Nt,H,B,Wt,_t,it)}}function Di(S,H,B,w,O,f){S.onBeforeRender(L,H,B,w,O,f),S.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse,S.matrixWorld),S.normalMatrix.getNormalMatrix(S.modelViewMatrix),O.onBeforeRender(L,H,B,w,S,f),O.transparent===!0&&O.side===nn&&O.forceSinglePass===!1?(O.side=Ne,O.needsUpdate=!0,L.renderBufferDirect(B,H,w,O,S,f),O.side=zn,O.needsUpdate=!0,L.renderBufferDirect(B,H,w,O,S,f),O.side=nn):L.renderBufferDirect(B,H,w,O,S,f),S.onAfterRender(L,H,B,w,O,f)}function Qn(S,H,B){H.isScene!==!0&&(H=ae);const w=Ft.get(S),O=m.state.lights,f=m.state.shadowsArray,Rt=O.state.version,Nt=J.getParameters(S,O.state,f,H,B),Wt=J.getProgramCacheKey(Nt);let _t=w.programs;w.environment=S.isMeshStandardMaterial?H.environment:null,w.fog=H.fog,w.envMap=(S.isMeshStandardMaterial?he:Qt).get(S.envMap||w.environment),_t===void 0&&(S.addEventListener("dispose",bt),_t=new Map,w.programs=_t);let it=_t.get(Wt);if(it!==void 0){if(w.currentProgram===it&&w.lightsStateVersion===Rt)return Ai(S,Nt),it}else Nt.uniforms=J.getUniforms(S),S.onBuild(B,Nt,L),S.onBeforeCompile(Nt,L),it=J.acquireProgram(Nt,Wt),_t.set(Wt,it),w.uniforms=Nt.uniforms;const Et=w.uniforms;(!S.isShaderMaterial&&!S.isRawShaderMaterial||S.clipping===!0)&&(Et.clippingPlanes=tt.uniform),Ai(S,Nt),w.needsLights=Ns(S),w.lightsStateVersion=Rt,w.needsLights&&(Et.ambientLightColor.value=O.state.ambient,Et.lightProbe.value=O.state.probe,Et.directionalLights.value=O.state.directional,Et.directionalLightShadows.value=O.state.directionalShadow,Et.spotLights.value=O.state.spot,Et.spotLightShadows.value=O.state.spotShadow,Et.rectAreaLights.value=O.state.rectArea,Et.ltc_1.value=O.state.rectAreaLTC1,Et.ltc_2.value=O.state.rectAreaLTC2,Et.pointLights.value=O.state.point,Et.pointLightShadows.value=O.state.pointShadow,Et.hemisphereLights.value=O.state.hemi,Et.directionalShadowMap.value=O.state.directionalShadowMap,Et.directionalShadowMatrix.value=O.state.directionalShadowMatrix,Et.spotShadowMap.value=O.state.spotShadowMap,Et.spotLightMatrix.value=O.state.spotLightMatrix,Et.spotLightMap.value=O.state.spotLightMap,Et.pointShadowMap.value=O.state.pointShadowMap,Et.pointShadowMatrix.value=O.state.pointShadowMatrix);const te=it.getUniforms(),xt=Ls.seqWithValue(te.seq,Et);return w.currentProgram=it,w.uniformsList=xt,it}function Ai(S,H){const B=Ft.get(S);B.outputColorSpace=H.outputColorSpace,B.instancing=H.instancing,B.skinning=H.skinning,B.morphTargets=H.morphTargets,B.morphNormals=H.morphNormals,B.morphColors=H.morphColors,B.morphTargetsCount=H.morphTargetsCount,B.numClippingPlanes=H.numClippingPlanes,B.numIntersection=H.numClipIntersection,B.vertexAlphas=H.vertexAlphas,B.vertexTangents=H.vertexTangents,B.toneMapping=H.toneMapping}function vs(S,H,B,w,O){H.isScene!==!0&&(H=ae),wt.resetTextureUnits();const f=H.fog,Rt=w.isMeshStandardMaterial?H.environment:null,Nt=N===null?L.outputColorSpace:N.isXRRenderTarget===!0?N.texture.colorSpace:on,Wt=(w.isMeshStandardMaterial?he:Qt).get(w.envMap||Rt),_t=w.vertexColors===!0&&!!B.attributes.color&&B.attributes.color.itemSize===4,it=!!B.attributes.tangent&&(!!w.normalMap||w.anisotropy>0),Et=!!B.morphAttributes.position,te=!!B.morphAttributes.normal,xt=!!B.morphAttributes.color,Ie=w.toneMapped?L.toneMapping:Xn,De=B.morphAttributes.position||B.morphAttributes.normal||B.morphAttributes.color,le=De!==void 0?De.length:0,Bt=Ft.get(w),qn=m.state.lights;if(at===!0&&(ft===!0||S!==G)){const Re=S===G&&w.id===K;tt.setState(w,S,Re)}let mt=!1;w.version===Bt.__version?(Bt.needsLights&&Bt.lightsStateVersion!==qn.state.version||Bt.outputColorSpace!==Nt||O.isInstancedMesh&&Bt.instancing===!1||!O.isInstancedMesh&&Bt.instancing===!0||O.isSkinnedMesh&&Bt.skinning===!1||!O.isSkinnedMesh&&Bt.skinning===!0||Bt.envMap!==Wt||w.fog===!0&&Bt.fog!==f||Bt.numClippingPlanes!==void 0&&(Bt.numClippingPlanes!==tt.numPlanes||Bt.numIntersection!==tt.numIntersection)||Bt.vertexAlphas!==_t||Bt.vertexTangents!==it||Bt.morphTargets!==Et||Bt.morphNormals!==te||Bt.morphColors!==xt||Bt.toneMapping!==Ie||Yt.isWebGL2===!0&&Bt.morphTargetsCount!==le)&&(mt=!0):(mt=!0,Bt.__version=w.version);let ln=Bt.currentProgram;mt===!0&&(ln=Qn(w,H,O));let Wi=!1,Nn=!1,Ci=!1;const Le=ln.getUniforms(),cn=Bt.uniforms;if(zt.useProgram(ln.program)&&(Wi=!0,Nn=!0,Ci=!0),w.id!==K&&(K=w.id,Nn=!0),Wi||G!==S){if(Le.setValue(P,"projectionMatrix",S.projectionMatrix),Yt.logarithmicDepthBuffer&&Le.setValue(P,"logDepthBufFC",2/(Math.log(S.far+1)/Math.LN2)),G!==S&&(G=S,Nn=!0,Ci=!0),w.isShaderMaterial||w.isMeshPhongMaterial||w.isMeshToonMaterial||w.isMeshStandardMaterial||w.envMap){const Re=Le.map.cameraPosition;Re!==void 0&&Re.setValue(P,It.setFromMatrixPosition(S.matrixWorld))}(w.isMeshPhongMaterial||w.isMeshToonMaterial||w.isMeshLambertMaterial||w.isMeshBasicMaterial||w.isMeshStandardMaterial||w.isShaderMaterial)&&Le.setValue(P,"isOrthographic",S.isOrthographicCamera===!0),(w.isMeshPhongMaterial||w.isMeshToonMaterial||w.isMeshLambertMaterial||w.isMeshBasicMaterial||w.isMeshStandardMaterial||w.isShaderMaterial||w.isShadowMaterial||O.isSkinnedMesh)&&Le.setValue(P,"viewMatrix",S.matrixWorldInverse)}if(O.isSkinnedMesh){Le.setOptional(P,O,"bindMatrix"),Le.setOptional(P,O,"bindMatrixInverse");const Re=O.skeleton;Re&&(Yt.floatVertexTextures?(Re.boneTexture===null&&Re.computeBoneTexture(),Le.setValue(P,"boneTexture",Re.boneTexture,wt),Le.setValue(P,"boneTextureSize",Re.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const vi=B.morphAttributes;if((vi.position!==void 0||vi.normal!==void 0||vi.color!==void 0&&Yt.isWebGL2===!0)&&Gt.update(O,B,ln),(Nn||Bt.receiveShadow!==O.receiveShadow)&&(Bt.receiveShadow=O.receiveShadow,Le.setValue(P,"receiveShadow",O.receiveShadow)),w.isMeshGouraudMaterial&&w.envMap!==null&&(cn.envMap.value=Wt,cn.flipEnvMap.value=Wt.isCubeTexture&&Wt.isRenderTargetTexture===!1?-1:1),Nn&&(Le.setValue(P,"toneMappingExposure",L.toneMappingExposure),Bt.needsLights&&zs(cn,Ci),f&&w.fog===!0&&ct.refreshFogUniforms(cn,f),ct.refreshMaterialUniforms(cn,w,j,nt,yt),Ls.upload(P,Bt.uniformsList,cn,wt)),w.isShaderMaterial&&w.uniformsNeedUpdate===!0&&(Ls.upload(P,Bt.uniformsList,cn,wt),w.uniformsNeedUpdate=!1),w.isSpriteMaterial&&Le.setValue(P,"center",O.center),Le.setValue(P,"modelViewMatrix",O.modelViewMatrix),Le.setValue(P,"normalMatrix",O.normalMatrix),Le.setValue(P,"modelMatrix",O.matrixWorld),w.isShaderMaterial||w.isRawShaderMaterial){const Re=w.uniformsGroups;for(let zi=0,Is=Re.length;zi<Is;zi++)if(Yt.isWebGL2){const Ji=Re[zi];Vt.update(Ji,ln),Vt.bind(Ji,ln)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return ln}function zs(S,H){S.ambientLightColor.needsUpdate=H,S.lightProbe.needsUpdate=H,S.directionalLights.needsUpdate=H,S.directionalLightShadows.needsUpdate=H,S.pointLights.needsUpdate=H,S.pointLightShadows.needsUpdate=H,S.spotLights.needsUpdate=H,S.spotLightShadows.needsUpdate=H,S.rectAreaLights.needsUpdate=H,S.hemisphereLights.needsUpdate=H}function Ns(S){return S.isMeshLambertMaterial||S.isMeshToonMaterial||S.isMeshPhongMaterial||S.isMeshStandardMaterial||S.isShadowMaterial||S.isShaderMaterial&&S.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return v},this.getRenderTarget=function(){return N},this.setRenderTargetTextures=function(S,H,B){Ft.get(S.texture).__webglTexture=H,Ft.get(S.depthTexture).__webglTexture=B;const w=Ft.get(S);w.__hasExternalTextures=!0,w.__hasExternalTextures&&(w.__autoAllocateDepthBuffer=B===void 0,w.__autoAllocateDepthBuffer||vt.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),w.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(S,H){const B=Ft.get(S);B.__webglFramebuffer=H,B.__useDefaultFramebuffer=H===void 0},this.setRenderTarget=function(S,H=0,B=0){N=S,g=H,v=B;let w=!0,O=null,f=!1,Rt=!1;if(S){const Wt=Ft.get(S);Wt.__useDefaultFramebuffer!==void 0?(zt.bindFramebuffer(P.FRAMEBUFFER,null),w=!1):Wt.__webglFramebuffer===void 0?wt.setupRenderTarget(S):Wt.__hasExternalTextures&&wt.rebindTextures(S,Ft.get(S.texture).__webglTexture,Ft.get(S.depthTexture).__webglTexture);const _t=S.texture;(_t.isData3DTexture||_t.isDataArrayTexture||_t.isCompressedArrayTexture)&&(Rt=!0);const it=Ft.get(S).__webglFramebuffer;S.isWebGLCubeRenderTarget?(O=it[H],f=!0):Yt.isWebGL2&&S.samples>0&&wt.useMultisampledRTT(S)===!1?O=Ft.get(S).__webglMultisampledFramebuffer:O=it,W.copy(S.viewport),Q.copy(S.scissor),$=S.scissorTest}else W.copy(et).multiplyScalar(j).floor(),Q.copy(St).multiplyScalar(j).floor(),$=F;if(zt.bindFramebuffer(P.FRAMEBUFFER,O)&&Yt.drawBuffers&&w&&zt.drawBuffers(S,O),zt.viewport(W),zt.scissor(Q),zt.setScissorTest($),f){const Wt=Ft.get(S.texture);P.framebufferTexture2D(P.FRAMEBUFFER,P.COLOR_ATTACHMENT0,P.TEXTURE_CUBE_MAP_POSITIVE_X+H,Wt.__webglTexture,B)}else if(Rt){const Wt=Ft.get(S.texture),_t=H||0;P.framebufferTextureLayer(P.FRAMEBUFFER,P.COLOR_ATTACHMENT0,Wt.__webglTexture,B||0,_t)}K=-1},this.readRenderTargetPixels=function(S,H,B,w,O,f,Rt){if(!(S&&S.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Nt=Ft.get(S).__webglFramebuffer;if(S.isWebGLCubeRenderTarget&&Rt!==void 0&&(Nt=Nt[Rt]),Nt){zt.bindFramebuffer(P.FRAMEBUFFER,Nt);try{const Wt=S.texture,_t=Wt.format,it=Wt.type;if(_t!==tn&&Xt.convert(_t)!==P.getParameter(P.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Et=it===Hi&&(vt.has("EXT_color_buffer_half_float")||Yt.isWebGL2&&vt.has("EXT_color_buffer_float"));if(it!==vn&&Xt.convert(it)!==P.getParameter(P.IMPLEMENTATION_COLOR_READ_TYPE)&&!(it===Wn&&(Yt.isWebGL2||vt.has("OES_texture_float")||vt.has("WEBGL_color_buffer_float")))&&!Et){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}H>=0&&H<=S.width-w&&B>=0&&B<=S.height-O&&P.readPixels(H,B,w,O,Xt.convert(_t),Xt.convert(it),f)}finally{const Wt=N!==null?Ft.get(N).__webglFramebuffer:null;zt.bindFramebuffer(P.FRAMEBUFFER,Wt)}}},this.copyFramebufferToTexture=function(S,H,B=0){const w=Math.pow(2,-B),O=Math.floor(H.image.width*w),f=Math.floor(H.image.height*w);wt.setTexture2D(H,0),P.copyTexSubImage2D(P.TEXTURE_2D,B,0,0,S.x,S.y,O,f),zt.unbindTexture()},this.copyTextureToTexture=function(S,H,B,w=0){const O=H.image.width,f=H.image.height,Rt=Xt.convert(B.format),Nt=Xt.convert(B.type);wt.setTexture2D(B,0),P.pixelStorei(P.UNPACK_FLIP_Y_WEBGL,B.flipY),P.pixelStorei(P.UNPACK_PREMULTIPLY_ALPHA_WEBGL,B.premultiplyAlpha),P.pixelStorei(P.UNPACK_ALIGNMENT,B.unpackAlignment),H.isDataTexture?P.texSubImage2D(P.TEXTURE_2D,w,S.x,S.y,O,f,Rt,Nt,H.image.data):H.isCompressedTexture?P.compressedTexSubImage2D(P.TEXTURE_2D,w,S.x,S.y,H.mipmaps[0].width,H.mipmaps[0].height,Rt,H.mipmaps[0].data):P.texSubImage2D(P.TEXTURE_2D,w,S.x,S.y,Rt,Nt,H.image),w===0&&B.generateMipmaps&&P.generateMipmap(P.TEXTURE_2D),zt.unbindTexture()},this.copyTextureToTexture3D=function(S,H,B,w,O=0){if(L.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const f=S.max.x-S.min.x+1,Rt=S.max.y-S.min.y+1,Nt=S.max.z-S.min.z+1,Wt=Xt.convert(w.format),_t=Xt.convert(w.type);let it;if(w.isData3DTexture)wt.setTexture3D(w,0),it=P.TEXTURE_3D;else if(w.isDataArrayTexture)wt.setTexture2DArray(w,0),it=P.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}P.pixelStorei(P.UNPACK_FLIP_Y_WEBGL,w.flipY),P.pixelStorei(P.UNPACK_PREMULTIPLY_ALPHA_WEBGL,w.premultiplyAlpha),P.pixelStorei(P.UNPACK_ALIGNMENT,w.unpackAlignment);const Et=P.getParameter(P.UNPACK_ROW_LENGTH),te=P.getParameter(P.UNPACK_IMAGE_HEIGHT),xt=P.getParameter(P.UNPACK_SKIP_PIXELS),Ie=P.getParameter(P.UNPACK_SKIP_ROWS),De=P.getParameter(P.UNPACK_SKIP_IMAGES),le=B.isCompressedTexture?B.mipmaps[0]:B.image;P.pixelStorei(P.UNPACK_ROW_LENGTH,le.width),P.pixelStorei(P.UNPACK_IMAGE_HEIGHT,le.height),P.pixelStorei(P.UNPACK_SKIP_PIXELS,S.min.x),P.pixelStorei(P.UNPACK_SKIP_ROWS,S.min.y),P.pixelStorei(P.UNPACK_SKIP_IMAGES,S.min.z),B.isDataTexture||B.isData3DTexture?P.texSubImage3D(it,O,H.x,H.y,H.z,f,Rt,Nt,Wt,_t,le.data):B.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),P.compressedTexSubImage3D(it,O,H.x,H.y,H.z,f,Rt,Nt,Wt,le.data)):P.texSubImage3D(it,O,H.x,H.y,H.z,f,Rt,Nt,Wt,_t,le),P.pixelStorei(P.UNPACK_ROW_LENGTH,Et),P.pixelStorei(P.UNPACK_IMAGE_HEIGHT,te),P.pixelStorei(P.UNPACK_SKIP_PIXELS,xt),P.pixelStorei(P.UNPACK_SKIP_ROWS,Ie),P.pixelStorei(P.UNPACK_SKIP_IMAGES,De),O===0&&w.generateMipmaps&&P.generateMipmap(it),zt.unbindTexture()},this.initTexture=function(S){S.isCubeTexture?wt.setTextureCube(S,0):S.isData3DTexture?wt.setTexture3D(S,0):S.isDataArrayTexture||S.isCompressedArrayTexture?wt.setTexture2DArray(S,0):wt.setTexture2D(S,0),zt.unbindTexture()},this.resetState=function(){g=0,v=0,N=null,zt.reset(),Mt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Gn}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(t){console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!t}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===Ut?_n:vr}set outputEncoding(t){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=t===_n?Ut:on}}class mm extends Or{}mm.prototype.isWebGL1Renderer=!0;let bm=class extends Ze{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(t){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=t}};class Ka extends Ln{constructor(t=[new Kt(0,-.5),new Kt(.5,0),new Kt(0,.5)],e=12,n=0,a=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:a},e=Math.floor(e),a=Te(a,0,Math.PI*2);const i=[],r=[],o=[],l=[],c=[],h=1/e,p=new V,u=new Kt,b=new V,x=new V,y=new V;let m=0,d=0;for(let Z=0;Z<=t.length-1;Z++)switch(Z){case 0:m=t[Z+1].x-t[Z].x,d=t[Z+1].y-t[Z].y,b.x=d*1,b.y=-m,b.z=d*0,y.copy(b),b.normalize(),l.push(b.x,b.y,b.z);break;case t.length-1:l.push(y.x,y.y,y.z);break;default:m=t[Z+1].x-t[Z].x,d=t[Z+1].y-t[Z].y,b.x=d*1,b.y=-m,b.z=d*0,x.copy(b),b.x+=y.x,b.y+=y.y,b.z+=y.z,b.normalize(),l.push(b.x,b.y,b.z),y.copy(x)}for(let Z=0;Z<=e;Z++){const L=n+Z*h*a,T=Math.sin(L),g=Math.cos(L);for(let v=0;v<=t.length-1;v++){p.x=t[v].x*T,p.y=t[v].y,p.z=t[v].x*g,r.push(p.x,p.y,p.z),u.x=Z/e,u.y=v/(t.length-1),o.push(u.x,u.y);const N=l[3*v+0]*T,K=l[3*v+1],G=l[3*v+0]*g;c.push(N,K,G)}}for(let Z=0;Z<e;Z++)for(let L=0;L<t.length-1;L++){const T=L+Z*t.length,g=T,v=T+t.length,N=T+t.length+1,K=T+1;i.push(g,v,K),i.push(N,K,v)}this.setIndex(i),this.setAttribute("position",new Ye(r,3)),this.setAttribute("uv",new Ye(o,2)),this.setAttribute("normal",new Ye(c,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ka(t.points,t.segments,t.phiStart,t.phiLength)}}class wa extends Ln{constructor(t=1,e=1,n=1,a=32,i=1,r=!1,o=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:a,heightSegments:i,openEnded:r,thetaStart:o,thetaLength:l};const c=this;a=Math.floor(a),i=Math.floor(i);const h=[],p=[],u=[],b=[];let x=0;const y=[],m=n/2;let d=0;Z(),r===!1&&(t>0&&L(!0),e>0&&L(!1)),this.setIndex(h),this.setAttribute("position",new Ye(p,3)),this.setAttribute("normal",new Ye(u,3)),this.setAttribute("uv",new Ye(b,2));function Z(){const T=new V,g=new V;let v=0;const N=(e-t)/n;for(let K=0;K<=i;K++){const G=[],W=K/i,Q=W*(e-t)+t;for(let $=0;$<=a;$++){const Y=$/a,U=Y*l+o,A=Math.sin(U),nt=Math.cos(U);g.x=Q*A,g.y=-W*n+m,g.z=Q*nt,p.push(g.x,g.y,g.z),T.set(A,N,nt).normalize(),u.push(T.x,T.y,T.z),b.push(Y,1-W),G.push(x++)}y.push(G)}for(let K=0;K<a;K++)for(let G=0;G<i;G++){const W=y[G][K],Q=y[G+1][K],$=y[G+1][K+1],Y=y[G][K+1];h.push(W,Q,Y),h.push(Q,$,Y),v+=6}c.addGroup(d,v,0),d+=v}function L(T){const g=x,v=new Kt,N=new V;let K=0;const G=T===!0?t:e,W=T===!0?1:-1;for(let $=1;$<=a;$++)p.push(0,m*W,0),u.push(0,W,0),b.push(.5,.5),x++;const Q=x;for(let $=0;$<=a;$++){const U=$/a*l+o,A=Math.cos(U),nt=Math.sin(U);N.x=G*nt,N.y=m*W,N.z=G*A,p.push(N.x,N.y,N.z),u.push(0,W,0),v.x=A*.5+.5,v.y=nt*.5*W+.5,b.push(v.x,v.y),x++}for(let $=0;$<a;$++){const Y=g+$,U=Q+$;T===!0?h.push(U,U+1,Y):h.push(U+1,U,Y),K+=3}c.addGroup(d,K,T===!0?1:2),d+=K}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new wa(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class fm extends _i{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new $t(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=zr,this.normalScale=new Kt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class ym extends Ze{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new $t(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}const ha=new me,ir=new V,sr=new V;class Mm{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Kt(512,512),this.map=null,this.mapPass=null,this.matrix=new me,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new za,this._frameExtents=new Kt(1,1),this._viewportCount=1,this._viewports=[new Ge(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;ir.setFromMatrixPosition(t.matrixWorld),e.position.copy(ir),sr.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(sr),e.updateMatrixWorld(),ha.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ha),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(ha)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class xm extends Mm{constructor(){super(new Ia(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class ua extends ym{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Ze.DEFAULT_UP),this.updateMatrix(),this.target=new Ze,this.shadow=new xm}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class ar{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Te(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Ra}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Ra);const or={type:"change"},pa={type:"start"},rr={type:"end"};class Gm extends Bn{constructor(t,e){super(),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new V,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:$n.ROTATE,MIDDLE:$n.DOLLY,RIGHT:$n.PAN},this.touches={ONE:ti.ROTATE,TWO:ti.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return o.phi},this.getAzimuthalAngle=function(){return o.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(C){C.addEventListener("keydown",Qt),this._domElementKeyEvents=C},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Qt),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(or),n.update(),i=a.NONE},this.update=function(){const C=new V,tt=new Dn().setFromUnitVectors(t.up,new V(0,1,0)),rt=tt.clone().invert(),D=new V,Gt=new Dn,Zt=new V,gt=2*Math.PI;return function(){const Mt=n.object.position;C.copy(Mt).sub(n.target),C.applyQuaternion(tt),o.setFromVector3(C),n.autoRotate&&i===a.NONE&&G(N()),n.enableDamping?(o.theta+=l.theta*n.dampingFactor,o.phi+=l.phi*n.dampingFactor):(o.theta+=l.theta,o.phi+=l.phi);let Vt=n.minAzimuthAngle,Dt=n.maxAzimuthAngle;return isFinite(Vt)&&isFinite(Dt)&&(Vt<-Math.PI?Vt+=gt:Vt>Math.PI&&(Vt-=gt),Dt<-Math.PI?Dt+=gt:Dt>Math.PI&&(Dt-=gt),Vt<=Dt?o.theta=Math.max(Vt,Math.min(Dt,o.theta)):o.theta=o.theta>(Vt+Dt)/2?Math.max(Vt,o.theta):Math.min(Dt,o.theta)),o.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,o.phi)),o.makeSafe(),o.radius*=c,o.radius=Math.max(n.minDistance,Math.min(n.maxDistance,o.radius)),n.enableDamping===!0?n.target.addScaledVector(h,n.dampingFactor):n.target.add(h),C.setFromSpherical(o),C.applyQuaternion(rt),Mt.copy(n.target).add(C),n.object.lookAt(n.target),n.enableDamping===!0?(l.theta*=1-n.dampingFactor,l.phi*=1-n.dampingFactor,h.multiplyScalar(1-n.dampingFactor)):(l.set(0,0,0),h.set(0,0,0)),c=1,p||D.distanceToSquared(n.object.position)>r||8*(1-Gt.dot(n.object.quaternion))>r||Zt.distanceToSquared(n.target)>0?(n.dispatchEvent(or),D.copy(n.object.position),Gt.copy(n.object.quaternion),Zt.copy(n.target),p=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",R),n.domElement.removeEventListener("pointerdown",vt),n.domElement.removeEventListener("pointercancel",zt),n.domElement.removeEventListener("wheel",wt),n.domElement.removeEventListener("pointermove",Yt),n.domElement.removeEventListener("pointerup",zt),n._domElementKeyEvents!==null&&(n._domElementKeyEvents.removeEventListener("keydown",Qt),n._domElementKeyEvents=null)};const n=this,a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=a.NONE;const r=1e-6,o=new ar,l=new ar;let c=1;const h=new V;let p=!1;const u=new Kt,b=new Kt,x=new Kt,y=new Kt,m=new Kt,d=new Kt,Z=new Kt,L=new Kt,T=new Kt,g=[],v={};function N(){return 2*Math.PI/60/60*n.autoRotateSpeed}function K(){return Math.pow(.95,n.zoomSpeed)}function G(C){l.theta-=C}function W(C){l.phi-=C}const Q=function(){const C=new V;return function(rt,D){C.setFromMatrixColumn(D,0),C.multiplyScalar(-rt),h.add(C)}}(),$=function(){const C=new V;return function(rt,D){n.screenSpacePanning===!0?C.setFromMatrixColumn(D,1):(C.setFromMatrixColumn(D,0),C.crossVectors(n.object.up,C)),C.multiplyScalar(rt),h.add(C)}}(),Y=function(){const C=new V;return function(rt,D){const Gt=n.domElement;if(n.object.isPerspectiveCamera){const Zt=n.object.position;C.copy(Zt).sub(n.target);let gt=C.length();gt*=Math.tan(n.object.fov/2*Math.PI/180),Q(2*rt*gt/Gt.clientHeight,n.object.matrix),$(2*D*gt/Gt.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(Q(rt*(n.object.right-n.object.left)/n.object.zoom/Gt.clientWidth,n.object.matrix),$(D*(n.object.top-n.object.bottom)/n.object.zoom/Gt.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function U(C){n.object.isPerspectiveCamera?c/=C:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*C)),n.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function A(C){n.object.isPerspectiveCamera?c*=C:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/C)),n.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function nt(C){u.set(C.clientX,C.clientY)}function j(C){Z.set(C.clientX,C.clientY)}function q(C){y.set(C.clientX,C.clientY)}function lt(C){b.set(C.clientX,C.clientY),x.subVectors(b,u).multiplyScalar(n.rotateSpeed);const tt=n.domElement;G(2*Math.PI*x.x/tt.clientHeight),W(2*Math.PI*x.y/tt.clientHeight),u.copy(b),n.update()}function et(C){L.set(C.clientX,C.clientY),T.subVectors(L,Z),T.y>0?U(K()):T.y<0&&A(K()),Z.copy(L),n.update()}function St(C){m.set(C.clientX,C.clientY),d.subVectors(m,y).multiplyScalar(n.panSpeed),Y(d.x,d.y),y.copy(m),n.update()}function F(C){C.deltaY<0?A(K()):C.deltaY>0&&U(K()),n.update()}function st(C){let tt=!1;switch(C.code){case n.keys.UP:C.ctrlKey||C.metaKey||C.shiftKey?W(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):Y(0,n.keyPanSpeed),tt=!0;break;case n.keys.BOTTOM:C.ctrlKey||C.metaKey||C.shiftKey?W(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):Y(0,-n.keyPanSpeed),tt=!0;break;case n.keys.LEFT:C.ctrlKey||C.metaKey||C.shiftKey?G(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):Y(n.keyPanSpeed,0),tt=!0;break;case n.keys.RIGHT:C.ctrlKey||C.metaKey||C.shiftKey?G(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):Y(-n.keyPanSpeed,0),tt=!0;break}tt&&(C.preventDefault(),n.update())}function at(){if(g.length===1)u.set(g[0].pageX,g[0].pageY);else{const C=.5*(g[0].pageX+g[1].pageX),tt=.5*(g[0].pageY+g[1].pageY);u.set(C,tt)}}function ft(){if(g.length===1)y.set(g[0].pageX,g[0].pageY);else{const C=.5*(g[0].pageX+g[1].pageX),tt=.5*(g[0].pageY+g[1].pageY);y.set(C,tt)}}function yt(){const C=g[0].pageX-g[1].pageX,tt=g[0].pageY-g[1].pageY,rt=Math.sqrt(C*C+tt*tt);Z.set(0,rt)}function Ct(){n.enableZoom&&yt(),n.enablePan&&ft()}function Ht(){n.enableZoom&&yt(),n.enableRotate&&at()}function It(C){if(g.length==1)b.set(C.pageX,C.pageY);else{const rt=dt(C),D=.5*(C.pageX+rt.x),Gt=.5*(C.pageY+rt.y);b.set(D,Gt)}x.subVectors(b,u).multiplyScalar(n.rotateSpeed);const tt=n.domElement;G(2*Math.PI*x.x/tt.clientHeight),W(2*Math.PI*x.y/tt.clientHeight),u.copy(b)}function ae(C){if(g.length===1)m.set(C.pageX,C.pageY);else{const tt=dt(C),rt=.5*(C.pageX+tt.x),D=.5*(C.pageY+tt.y);m.set(rt,D)}d.subVectors(m,y).multiplyScalar(n.panSpeed),Y(d.x,d.y),y.copy(m)}function kt(C){const tt=dt(C),rt=C.pageX-tt.x,D=C.pageY-tt.y,Gt=Math.sqrt(rt*rt+D*D);L.set(0,Gt),T.set(0,Math.pow(L.y/Z.y,n.zoomSpeed)),U(T.y),Z.copy(L)}function P(C){n.enableZoom&&kt(C),n.enablePan&&ae(C)}function de(C){n.enableZoom&&kt(C),n.enableRotate&&It(C)}function vt(C){n.enabled!==!1&&(g.length===0&&(n.domElement.setPointerCapture(C.pointerId),n.domElement.addEventListener("pointermove",Yt),n.domElement.addEventListener("pointerup",zt)),X(C),C.pointerType==="touch"?he(C):qt(C))}function Yt(C){n.enabled!==!1&&(C.pointerType==="touch"?ue(C):Ft(C))}function zt(C){J(C),g.length===0&&(n.domElement.releasePointerCapture(C.pointerId),n.domElement.removeEventListener("pointermove",Yt),n.domElement.removeEventListener("pointerup",zt)),n.dispatchEvent(rr),i=a.NONE}function qt(C){let tt;switch(C.button){case 0:tt=n.mouseButtons.LEFT;break;case 1:tt=n.mouseButtons.MIDDLE;break;case 2:tt=n.mouseButtons.RIGHT;break;default:tt=-1}switch(tt){case $n.DOLLY:if(n.enableZoom===!1)return;j(C),i=a.DOLLY;break;case $n.ROTATE:if(C.ctrlKey||C.metaKey||C.shiftKey){if(n.enablePan===!1)return;q(C),i=a.PAN}else{if(n.enableRotate===!1)return;nt(C),i=a.ROTATE}break;case $n.PAN:if(C.ctrlKey||C.metaKey||C.shiftKey){if(n.enableRotate===!1)return;nt(C),i=a.ROTATE}else{if(n.enablePan===!1)return;q(C),i=a.PAN}break;default:i=a.NONE}i!==a.NONE&&n.dispatchEvent(pa)}function Ft(C){switch(i){case a.ROTATE:if(n.enableRotate===!1)return;lt(C);break;case a.DOLLY:if(n.enableZoom===!1)return;et(C);break;case a.PAN:if(n.enablePan===!1)return;St(C);break}}function wt(C){n.enabled===!1||n.enableZoom===!1||i!==a.NONE||(C.preventDefault(),n.dispatchEvent(pa),F(C),n.dispatchEvent(rr))}function Qt(C){n.enabled===!1||n.enablePan===!1||st(C)}function he(C){switch(ct(C),g.length){case 1:switch(n.touches.ONE){case ti.ROTATE:if(n.enableRotate===!1)return;at(),i=a.TOUCH_ROTATE;break;case ti.PAN:if(n.enablePan===!1)return;ft(),i=a.TOUCH_PAN;break;default:i=a.NONE}break;case 2:switch(n.touches.TWO){case ti.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Ct(),i=a.TOUCH_DOLLY_PAN;break;case ti.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;Ht(),i=a.TOUCH_DOLLY_ROTATE;break;default:i=a.NONE}break;default:i=a.NONE}i!==a.NONE&&n.dispatchEvent(pa)}function ue(C){switch(ct(C),i){case a.TOUCH_ROTATE:if(n.enableRotate===!1)return;It(C),n.update();break;case a.TOUCH_PAN:if(n.enablePan===!1)return;ae(C),n.update();break;case a.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;P(C),n.update();break;case a.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;de(C),n.update();break;default:i=a.NONE}}function R(C){n.enabled!==!1&&C.preventDefault()}function X(C){g.push(C)}function J(C){delete v[C.pointerId];for(let tt=0;tt<g.length;tt++)if(g[tt].pointerId==C.pointerId){g.splice(tt,1);return}}function ct(C){let tt=v[C.pointerId];tt===void 0&&(tt=new Kt,v[C.pointerId]=tt),tt.set(C.pageX,C.pageY)}function dt(C){const tt=C.pointerId===g[0].pointerId?g[1]:g[0];return v[tt.pointerId]}n.domElement.addEventListener("contextmenu",R),n.domElement.addEventListener("pointerdown",vt),n.domElement.addEventListener("pointercancel",zt),n.domElement.addEventListener("wheel",wt,{passive:!1}),this.update()}}const Xm=function(){function s(n,a){function i(){this.constructor=n}i.prototype=a.prototype,n.prototype=new i}function t(n,a,i,r){this.message=n,this.expected=a,this.found=i,this.location=r,this.name="SyntaxError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,t)}s(t,Error),t.buildMessage=function(n,a){var i={literal:function(u){return'"'+o(u.text)+'"'},class:function(u){var b="",x;for(x=0;x<u.parts.length;x++)b+=u.parts[x]instanceof Array?l(u.parts[x][0])+"-"+l(u.parts[x][1]):l(u.parts[x]);return"["+(u.inverted?"^":"")+b+"]"},any:function(u){return"any character"},end:function(u){return"end of input"},other:function(u){return u.description}};function r(u){return u.charCodeAt(0).toString(16).toUpperCase()}function o(u){return u.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(b){return"\\x0"+r(b)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(b){return"\\x"+r(b)})}function l(u){return u.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(b){return"\\x0"+r(b)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(b){return"\\x"+r(b)})}function c(u){return i[u.type](u)}function h(u){var b=new Array(u.length),x,y;for(x=0;x<u.length;x++)b[x]=c(u[x]);if(b.sort(),b.length>0){for(x=1,y=1;x<b.length;x++)b[x-1]!==b[x]&&(b[y]=b[x],y++);b.length=y}switch(b.length){case 1:return b[0];case 2:return b[0]+" or "+b[1];default:return b.slice(0,-1).join(", ")+", or "+b[b.length-1]}}function p(u){return u?'"'+o(u)+'"':"end of input"}return"Expected "+h(n)+" but "+p(a)+" found."};function e(n,a){a=a!==void 0?a:{};var i={},r={start:Wi},o=Wi,l="UNITS",c=xt("UNITS",!1),h="MM",p=xt("MM",!1),u="CM",b=xt("CM",!1),x="M",y=xt("M",!1),m="FT",d=xt("FT",!1),Z="IN",L=xt("IN",!1),T="STOCK",g=xt("STOCK",!1),v="R",N=xt("R",!1),K="D",G=xt("D",!1),W="A",Q=xt("A",!1),$="TOOL",Y=xt("TOOL",!1),U="RECT",A=xt("RECT",!1),nt="ROUND",j=xt("ROUND",!1),q="ANG",lt=xt("ANG",!1),et="L",St=xt("L",!1),F="H",st=xt("H",!1),at="NA",ft=xt("NA",!1),yt="DEPTH",Ct=xt("DEPTH",!1),Ht="CUT",It=xt("CUT",!1),ae="FINISH",kt=xt("FINISH",!1),P="FEED",de=xt("FEED",!1),vt="MOVE",Yt=xt("MOVE",!1),zt="PASS",qt=xt("PASS",!1),Ft="PART",wt=xt("PART",!1),Qt="MODE",he=xt("MODE",!1),ue="FACE",R=xt("FACE",!1),X="TURN",J=xt("TURN",!1),ct="AXES",dt=xt("AXES",!1),C="LEFT",tt=xt("LEFT",!1),rt="RIGHT",D=xt("RIGHT",!1),Gt="UP",Zt=xt("UP",!1),gt="DOWN",Xt=xt("DOWN",!1),Mt="INSIDE",Vt=xt("INSIDE",!1),Dt="DS",I=xt("DS",!1),pt="RS",k=xt("RS",!1),ht="DE",bt=xt("DE",!1),jt="RE",oe=xt("RE",!1),re="CONV",rn=xt("CONV",!1),ie="CONC",He=xt("CONC",!1),Xe=";",ki=xt(";",!1),Ri=De(),Cs=function(M){return te().substring(1).trim()},jn=".",Di=xt(".",!1),Qn=function(){return parseFloat(te())},Ai=/^[0-9]/,vs=Ie([["0","9"]],!1,!1),zs=function(){return null},Ns=" ",S=xt(" ",!1),H="\r",B=xt("\r",!1),w=`
`,O=xt(`
`,!1),f=0,Rt=0,Nt=[{line:1,column:1}],Wt=0,_t=[],it=0,Et;if("startRule"in a){if(!(a.startRule in r))throw new Error(`Can't start parsing from rule "`+a.startRule+'".');o=r[a.startRule]}function te(){return n.substring(Rt,f)}function xt(M,z){return{type:"literal",text:M,ignoreCase:z}}function Ie(M,z,E){return{type:"class",parts:M,inverted:z,ignoreCase:E}}function De(){return{type:"any"}}function le(){return{type:"end"}}function Bt(M){var z=Nt[M],E;if(z)return z;for(E=M-1;!Nt[E];)E--;for(z=Nt[E],z={line:z.line,column:z.column};E<M;)n.charCodeAt(E)===10?(z.line++,z.column=1):z.column++,E++;return Nt[M]=z,z}function qn(M,z){var E=Bt(M),_=Bt(z);return{start:{offset:M,line:E.line,column:E.column},end:{offset:z,line:_.line,column:_.column}}}function mt(M){f<Wt||(f>Wt&&(Wt=f,_t=[]),_t.push(M))}function ln(M,z,E){return new t(t.buildMessage(M,z),M,z,E)}function Wi(){var M,z,E,_,ot,Lt,Pt,ee,Ve,Oi,dn,ji,hn,Qi,un,qi,ne,ce,se,Ni,We,Fe,ze;for(M=f,z=[],E=Ot();E!==i;)z.push(E),E=Ot();if(z!==i)if(E=Nn(),E===i&&(E=null),E!==i){for(_=[],ot=Ot();ot!==i;)_.push(ot),ot=Ot();if(_!==i)if(ot=Le(),ot===i&&(ot=null),ot!==i){for(Lt=[],Pt=Ot();Pt!==i;)Lt.push(Pt),Pt=Ot();if(Lt!==i)if(Pt=vi(),Pt===i&&(Pt=null),Pt!==i){for(ee=[],Ve=Ot();Ve!==i;)ee.push(Ve),Ve=Ot();if(ee!==i)if(Ve=Is(),Ve===i&&(Ve=null),Ve!==i){for(Oi=[],dn=Ot();dn!==i;)Oi.push(dn),dn=Ot();if(Oi!==i)if(dn=sl(),dn===i&&(dn=null),dn!==i){for(ji=[],hn=Ot();hn!==i;)ji.push(hn),hn=Ot();if(ji!==i)if(hn=ol(),hn===i&&(hn=null),hn!==i){for(Qi=[],un=Ot();un!==i;)Qi.push(un),un=Ot();if(Qi!==i)if(un=ll(),un===i&&(un=null),un!==i){for(qi=[],ne=f,ce=[],se=Ot();se!==i;)ce.push(se),se=Ot();for(ce!==i?(se=Bi(),se!==i?(ce=[ce,se],ne=ce):(f=ne,ne=i)):(f=ne,ne=i);ne!==i;){for(qi.push(ne),ne=f,ce=[],se=Ot();se!==i;)ce.push(se),se=Ot();ce!==i?(se=Bi(),se!==i?(ce=[ce,se],ne=ce):(f=ne,ne=i)):(f=ne,ne=i)}if(qi!==i){for(ne=f,ce=[],se=Ot();se!==i;)ce.push(se),se=Ot();if(ce!==i)if(se=dl(),se!==i){for(Ni=[],We=f,Fe=[],ze=Ot();ze!==i;)Fe.push(ze),ze=Ot();if(Fe!==i?(ze=Bi(),ze!==i?(Fe=[Fe,ze],We=Fe):(f=We,We=i)):(f=We,We=i),We!==i)for(;We!==i;){for(Ni.push(We),We=f,Fe=[],ze=Ot();ze!==i;)Fe.push(ze),ze=Ot();Fe!==i?(ze=Bi(),ze!==i?(Fe=[Fe,ze],We=Fe):(f=We,We=i)):(f=We,We=i)}else Ni=i;Ni!==i?(ce=[ce,se,Ni],ne=ce):(f=ne,ne=i)}else f=ne,ne=i;else f=ne,ne=i;if(ne===i&&(ne=null),ne!==i){for(ce=[],se=Ot();se!==i;)ce.push(se),se=Ot();ce!==i?(z=[z,E,_,ot,Lt,Pt,ee,Ve,Oi,dn,ji,hn,Qi,un,qi,ne,ce],M=z):(f=M,M=i)}else f=M,M=i}else f=M,M=i}else f=M,M=i;else f=M,M=i}else f=M,M=i;else f=M,M=i}else f=M,M=i;else f=M,M=i}else f=M,M=i;else f=M,M=i}else f=M,M=i;else f=M,M=i}else f=M,M=i;else f=M,M=i}else f=M,M=i;else f=M,M=i;return M}function Nn(){var M,z,E,_,ot;return M=f,n.substr(f,5)===l?(z=l,f+=5):(z=i,it===0&&mt(c)),z!==i?(E=Ae(),E!==i?(_=Ci(),_!==i?(ot=Ot(),ot!==i?(z=[z,E,_,ot],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function Ci(){var M;return n.substr(f,2)===h?(M=h,f+=2):(M=i,it===0&&mt(p)),M===i&&(n.substr(f,2)===u?(M=u,f+=2):(M=i,it===0&&mt(b)),M===i&&(n.charCodeAt(f)===77?(M=x,f++):(M=i,it===0&&mt(y)),M===i&&(n.substr(f,2)===m?(M=m,f+=2):(M=i,it===0&&mt(d)),M===i&&(n.substr(f,2)===Z?(M=Z,f+=2):(M=i,it===0&&mt(L)))))),M}function Le(){var M,z,E,_,ot;return M=f,n.substr(f,5)===T?(z=T,f+=5):(z=i,it===0&&mt(g)),z!==i?(E=Ae(),E!==i?(_=cn(),_!==i?(ot=Ot(),ot!==i?(z=[z,E,_,ot],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function cn(){var M,z,E,_,ot,Lt;return M=f,n.charCodeAt(f)===82?(z=v,f++):(z=i,it===0&&mt(N)),z===i&&(n.charCodeAt(f)===68?(z=K,f++):(z=i,it===0&&mt(G))),z!==i?(E=ye(),E!==i?(_=f,n.charCodeAt(f)===65?(ot=W,f++):(ot=i,it===0&&mt(Q)),ot!==i?(Lt=ye(),Lt!==i?(ot=[ot,Lt],_=ot):(f=_,_=i)):(f=_,_=i),_===i&&(_=null),_!==i?(z=[z,E,_],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function vi(){var M,z,E,_,ot,Lt,Pt;return M=f,n.substr(f,4)===$?(z=$,f+=4):(z=i,it===0&&mt(Y)),z!==i?(E=Ae(),E!==i?(_=Re(),_!==i?(ot=Ae(),ot!==i?(Lt=zi(),Lt!==i?(Pt=Ot(),Pt!==i?(z=[z,E,_,ot,Lt,Pt],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function Re(){var M;return n.substr(f,4)===U?(M=U,f+=4):(M=i,it===0&&mt(A)),M===i&&(n.substr(f,5)===nt?(M=nt,f+=5):(M=i,it===0&&mt(j)),M===i&&(n.substr(f,3)===q?(M=q,f+=3):(M=i,it===0&&mt(lt)))),M}function zi(){var M,z,E,_,ot,Lt,Pt,ee;return M=f,z=f,n.charCodeAt(f)===82?(E=v,f++):(E=i,it===0&&mt(N)),E!==i?(_=ye(),_!==i?(E=[E,_],z=E):(f=z,z=i)):(f=z,z=i),z===i&&(z=null),z!==i?(E=f,n.charCodeAt(f)===76?(_=et,f++):(_=i,it===0&&mt(St)),_!==i?(ot=ye(),ot!==i?(_=[_,ot],E=_):(f=E,E=i)):(f=E,E=i),E===i&&(E=null),E!==i?(_=f,n.charCodeAt(f)===72?(ot=F,f++):(ot=i,it===0&&mt(st)),ot!==i?(Lt=ye(),Lt!==i?(ot=[ot,Lt],_=ot):(f=_,_=i)):(f=_,_=i),_===i&&(_=null),_!==i?(ot=f,n.charCodeAt(f)===65?(Lt=W,f++):(Lt=i,it===0&&mt(Q)),Lt!==i?(Pt=ye(),Pt!==i?(Lt=[Lt,Pt],ot=Lt):(f=ot,ot=i)):(f=ot,ot=i),ot===i&&(ot=null),ot!==i?(Lt=f,n.substr(f,2)===at?(Pt=at,f+=2):(Pt=i,it===0&&mt(ft)),Pt!==i?(ee=ye(),ee!==i?(Pt=[Pt,ee],Lt=Pt):(f=Lt,Lt=i)):(f=Lt,Lt=i),Lt===i&&(Lt=null),Lt!==i?(z=[z,E,_,ot,Lt],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function Is(){var M,z,E,_,ot;return M=f,n.substr(f,5)===yt?(z=yt,f+=5):(z=i,it===0&&mt(Ct)),z!==i?(E=Ae(),E!==i?(_=Ji(),_!==i?(ot=Ot(),ot!==i?(z=[z,E,_,ot],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function Ji(){var M,z,E,_,ot;return M=f,z=f,n.substr(f,3)===Ht?(E=Ht,f+=3):(E=i,it===0&&mt(It)),E!==i?(_=ye(),_!==i?(E=[E,_],z=E):(f=z,z=i)):(f=z,z=i),z===i&&(z=null),z!==i?(E=f,n.substr(f,6)===ae?(_=ae,f+=6):(_=i,it===0&&mt(kt)),_!==i?(ot=ye(),ot!==i?(_=[_,ot],E=_):(f=E,E=i)):(f=E,E=i),E===i&&(E=null),E!==i?(z=[z,E],M=z):(f=M,M=i)):(f=M,M=i),M}function sl(){var M,z,E,_,ot;return M=f,n.substr(f,4)===P?(z=P,f+=4):(z=i,it===0&&mt(de)),z!==i?(E=Ae(),E!==i?(_=al(),_!==i?(ot=Ot(),ot!==i?(z=[z,E,_,ot],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function al(){var M,z,E,_,ot,Lt;return M=f,z=f,n.substr(f,4)===vt?(E=vt,f+=4):(E=i,it===0&&mt(Yt)),E!==i?(_=ye(),_!==i?(E=[E,_],z=E):(f=z,z=i)):(f=z,z=i),z===i&&(z=null),z!==i?(E=f,n.substr(f,4)===zt?(_=zt,f+=4):(_=i,it===0&&mt(qt)),_!==i?(ot=ye(),ot!==i?(_=[_,ot],E=_):(f=E,E=i)):(f=E,E=i),E===i&&(E=null),E!==i?(_=f,n.substr(f,4)===Ft?(ot=Ft,f+=4):(ot=i,it===0&&mt(wt)),ot!==i?(Lt=ye(),Lt!==i?(ot=[ot,Lt],_=ot):(f=_,_=i)):(f=_,_=i),_===i&&(_=null),_!==i?(z=[z,E,_],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function ol(){var M,z,E,_,ot;return M=f,n.substr(f,4)===Qt?(z=Qt,f+=4):(z=i,it===0&&mt(he)),z!==i?(E=Ae(),E!==i?(_=rl(),_!==i?(ot=Ot(),ot!==i?(z=[z,E,_,ot],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function rl(){var M;return n.substr(f,4)===ue?(M=ue,f+=4):(M=i,it===0&&mt(R)),M===i&&(n.substr(f,4)===X?(M=X,f+=4):(M=i,it===0&&mt(J))),M}function ll(){var M,z,E,_,ot;return M=f,n.substr(f,4)===ct?(z=ct,f+=4):(z=i,it===0&&mt(dt)),z!==i?(E=Ae(),E!==i?(_=cl(),_!==i?(ot=Ot(),ot!==i?(z=[z,E,_,ot],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function cl(){var M,z,E,_;return M=f,n.substr(f,4)===C?(z=C,f+=4):(z=i,it===0&&mt(tt)),z===i&&(n.substr(f,5)===rt?(z=rt,f+=5):(z=i,it===0&&mt(D))),z!==i?(E=Ae(),E!==i?(n.substr(f,2)===Gt?(_=Gt,f+=2):(_=i,it===0&&mt(Zt)),_===i&&(n.substr(f,4)===gt?(_=gt,f+=4):(_=i,it===0&&mt(Xt))),_!==i?(z=[z,E,_],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function dl(){var M,z,E;return M=f,n.substr(f,6)===Mt?(z=Mt,f+=6):(z=i,it===0&&mt(Vt)),z!==i?(E=Ot(),E!==i?(z=[z,E],M=z):(f=M,M=i)):(f=M,M=i),M}function Bi(){var M,z,E,_,ot,Lt,Pt,ee,Ve;return M=f,n.charCodeAt(f)===76?(z=et,f++):(z=i,it===0&&mt(St)),z!==i?(E=ye(),E!==i?(_=Ot(),_!==i?(z=[z,E,_],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M===i&&(M=f,n.charCodeAt(f)===76?(z=et,f++):(z=i,it===0&&mt(St)),z!==i?(E=ye(),E!==i?(n.charCodeAt(f)===68?(_=K,f++):(_=i,it===0&&mt(G)),_===i&&(n.charCodeAt(f)===82?(_=v,f++):(_=i,it===0&&mt(N))),_!==i?(ot=ye(),ot!==i?(Lt=Ot(),Lt!==i?(z=[z,E,_,ot,Lt],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M===i&&(M=f,n.charCodeAt(f)===76?(z=et,f++):(z=i,it===0&&mt(St)),z!==i?(E=ye(),E!==i?(n.substr(f,2)===Dt?(_=Dt,f+=2):(_=i,it===0&&mt(I)),_===i&&(n.substr(f,2)===pt?(_=pt,f+=2):(_=i,it===0&&mt(k))),_!==i?(ot=ye(),ot!==i?(n.substr(f,2)===ht?(Lt=ht,f+=2):(Lt=i,it===0&&mt(bt)),Lt===i&&(n.substr(f,2)===jt?(Lt=jt,f+=2):(Lt=i,it===0&&mt(oe))),Lt!==i?(Pt=ye(),Pt!==i?(ee=hl(),ee===i&&(ee=null),ee!==i?(Ve=Ot(),Ve!==i?(z=[z,E,_,ot,Lt,Pt,ee,Ve],M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i)):(f=M,M=i))),M}function hl(){var M;return n.substr(f,4)===re?(M=re,f+=4):(M=i,it===0&&mt(rn)),M===i&&(n.substr(f,4)===ie?(M=ie,f+=4):(M=i,it===0&&mt(He))),M}function Ot(){var M,z,E,_,ot,Lt,Pt,ee;if(M=f,z=Ae(),z!==i){if(E=f,n.charCodeAt(f)===59?(_=Xe,f++):(_=i,it===0&&mt(ki)),_!==i){for(ot=[],Lt=f,Pt=f,it++,ee=Vs(),it--,ee===i?Pt=void 0:(f=Pt,Pt=i),Pt!==i?(n.length>f?(ee=n.charAt(f),f++):(ee=i,it===0&&mt(Ri)),ee!==i?(Pt=[Pt,ee],Lt=Pt):(f=Lt,Lt=i)):(f=Lt,Lt=i);Lt!==i;)ot.push(Lt),Lt=f,Pt=f,it++,ee=Vs(),it--,ee===i?Pt=void 0:(f=Pt,Pt=i),Pt!==i?(n.length>f?(ee=n.charAt(f),f++):(ee=i,it===0&&mt(Ri)),ee!==i?(Pt=[Pt,ee],Lt=Pt):(f=Lt,Lt=i)):(f=Lt,Lt=i);ot!==i?(_=[_,ot],E=_):(f=E,E=i)}else f=E,E=i;E===i&&(E=null),E!==i?(_=Vs(),_!==i?(Rt=M,z=Cs(),M=z):(f=M,M=i)):(f=M,M=i)}else f=M,M=i;return M}function ye(){var M,z,E,_,ot;return M=f,z=Ea(),z!==i?(E=f,n.charCodeAt(f)===46?(_=jn,f++):(_=i,it===0&&mt(Di)),_!==i?(ot=Ea(),ot!==i?(_=[_,ot],E=_):(f=E,E=i)):(f=E,E=i),E===i&&(E=null),E!==i?(_=Ae(),_!==i?(Rt=M,z=Qn(),M=z):(f=M,M=i)):(f=M,M=i)):(f=M,M=i),M}function Ea(){var M,z;if(M=[],z=Pa(),z!==i)for(;z!==i;)M.push(z),z=Pa();else M=i;return M}function Pa(){var M;return Ai.test(n.charAt(f))?(M=n.charAt(f),f++):(M=i,it===0&&mt(vs)),M}function Ae(){var M,z,E;for(M=f,z=[],E=Ya();E!==i;)z.push(E),E=Ya();return z!==i&&(Rt=M,z=zs()),M=z,M}function Ya(){var M;return n.charCodeAt(f)===32?(M=Ns,f++):(M=i,it===0&&mt(S)),M}function Vs(){var M,z,E;return M=f,n.charCodeAt(f)===13?(z=H,f++):(z=i,it===0&&mt(B)),z===i&&(z=null),z!==i?(n.charCodeAt(f)===10?(E=w,f++):(E=i,it===0&&mt(O)),E!==i?(z=[z,E],M=z):(f=M,M=i)):(f=M,M=i),M}if(Et=o(),Et!==i&&f===n.length)return Et;throw Et!==i&&f<n.length&&mt(le()),ln(_t,Wt<n.length?n.charAt(Wt):null,Wt<n.length?qn(Wt,Wt+1):qn(Wt,Wt))}return{SyntaxError:t,parse:e}}();class xe{constructor(t,e){this.x=t,this.z=e}isEqual(t){return this.x===t.x&&this.z===t.z}toString(){return`${this.x},${this.z}`}offsetBy(t,e=0){return new xe(this.x+t,this.z+e)}}class ke{constructor(t,e,n){this.type=t,this.start=e,this.end=n}isEqual(t){return this.type===t.type&&this.start.isEqual(t.start)&&this.end.isEqual(t.end)}isColinear(t){if(this.type!=="LINE"||this.type!==t.type)return;const e=this.end.x-this.start.x,n=t.end.x-t.start.x,a=(this.end.z-this.start.z)/e,i=(t.end.z-t.start.z)/n;return!(e===0&&n===0)&&Math.abs(a-i)>1e-5?!1:(this.start.x-t.start.x)*(this.end.z-this.start.z)===e*(this.start.z-t.start.z)}isEmpty(){return this.start.isEqual(this.end)}toString(){return`${this.type}:${this.start}-${this.end}`}offsetBy(t,e){return new ke(this.type,this.start.offsetBy(t,e),this.end.offsetBy(t,e))}}class Lm{constructor(t,e){this.diameter=t,this.length=e}getSegments(){return[new ke("LINE",new xe(0,0),new xe(this.diameter/2,0)),new ke("LINE",new xe(this.diameter/2,0),new xe(this.diameter/2,this.length)),new ke("LINE",new xe(this.diameter/2,this.length),new xe(0,this.length)),new ke("LINE",new xe(0,this.length),new xe(0,0))]}}class Xs{constructor(t,e,n,a,i,r){this.type=t,this.widthMm=e,this.heightMm=n,this.cornerRadiusMm=a,this.angleDeg=i,this.noseAngleDeg=r}}class Sm{constructor(t,e,n){this.moveMmMin=t,this.passMmMin=e,this.partMmMin=n}}class gm{constructor(t,e){this.cutMm=t,this.finishMm=e}}const Tm={MM:1,CM:10,M:1e3,FT:304.8,IN:25.4};class lr{constructor(t){Tt(this,"data");Tt(this,"unitsMultiplier",1);Tt(this,"outsideMaxRadius",0);Tt(this,"outside");Tt(this,"outsideSegments");Tt(this,"inside");Tt(this,"insideSegments");this.text=t,this.data=Xm.parse(t+`
`),this.unitsMultiplier=this.data[1]?Tm[this.data[1][2]]:1,this.outside=this.getSegmentsForSide(this.data[this.data.length-3],0),this.outsideMaxRadius=this.outside.length?Math.max.apply(null,this.outside.map(e=>Math.max(e.start.x,e.end.x))):0,this.inside=this.data[this.data.length-2]?this.getSegmentsForSide(this.data[this.data.length-2][2],this.getStockDiameter()/2):[],this.outsideSegments=this.closeLoop(this.outside,0),this.insideSegments=this.getStockDiameter()>0?this.closeLoop(this.inside,this.getStockDiameter()/2):[],this.getTool()}getText(){return this.text}getTitle(){return this.data[0][1]||""}getStock(){const t=this.getStockDiameter(),e=this.getStockLength();return t>0&&e>0?new Lm(t,e):null}getTool(){if(!this.data[5])return new Xs("RECT",3,3,.4);const t=this.data[5][2],e=this.data[5][4],n=e[0]?e[0][1]*this.unitsMultiplier:0,a=e[1]?e[1][1]*this.unitsMultiplier:0,i=e[2]?e[2][1]*this.unitsMultiplier:0,r=e[3]?e[3][1]*this.unitsMultiplier:0,o=e[4]?e[4][1]*this.unitsMultiplier:0;if(t==="RECT"){if(r)throw new Error("A not implemented for TOOL RECT");if(o)throw new Error("NA not supported for TOOL RECT");return new Xs("RECT",a||3,i||a||3,n)}else if(t==="ROUND"){if(a)throw new Error("TOOL ROUND L is already defined by R");if(i)throw new Error("TOOL ROUND H is already defined by R");return new Xs("ROUND",n*2,n*2,n)}else if(t==="ANG"){if(o<=0)throw new Error("Specify positive tool nose angle NA");if(i)throw new Error("TOOL ANG H is ignored, use L");return new Xs("ANG",a||10,i||10,n,r,o)}throw new Error("Unknown tool "+t)}getFeed(){const t=this.data[9]?this.data[9][2]:[];return new Sm((t[0]?t[0][1]:0)*this.unitsMultiplier||200,(t[1]?t[1][1]:0)*this.unitsMultiplier||50,(t[2]?t[2][1]:0)*this.unitsMultiplier||10)}getDepth(){const t=this.data[7]?this.data[7][2]:[],e=t[0],n=t[1];return new gm((e?e[1]:0)*this.unitsMultiplier||.5,(n?n[1]:0)*this.unitsMultiplier||.1)}getMode(){var t;return(t=this.data[11])!=null&&t.length?this.data[11][2]:"FACE"}getZDirection(){return!this.data[13]||!this.data[13][2]?"LEFT":this.data[13][2][0]}getXDirection(){return!this.data[13]||!this.data[13][2]?"UP":this.data[13][2][2]}isNanoElsCompatible(){return this.getZDirection()==="LEFT"&&this.getXDirection()==="UP"}getOutsideSegments(){return this.outsideSegments.concat()}getInsideSegments(){return this.insideSegments.concat()}getCutoffStarts(){const t=[];let e=!1,n=0;for(let a of this.data[this.data.length-3]){let i=a[1];dr(i)&&e?t.push(n):e=!0,n+=i[1]*this.unitsMultiplier}return t}getStockLength(){let t=1/0,e=-1/0;for(let n of[...this.outside,...this.inside])n.start.z<t&&(t=n.start.z),n.end.z<t&&(t=n.end.z),n.start.z>e&&(e=n.start.z),n.end.z>e&&(e=n.end.z);return e-t}getStockDiameter(){if(!this.data||!this.data[3])return this.outsideMaxRadius*2;const t=this.data[3][2];return t[1]*(t[0]=="D"?1:2)*this.unitsMultiplier}closeLoop(t,e){if(!t.length)return[];const n=t.at(0),a=t.at(-1);let i=cr(Ta(cr([new ke("LINE",new xe(e,n.start.z),n.start),...t,new ke("LINE",a.end,new xe(e,a.end.z)),new ke("LINE",new xe(e,a.end.z),new xe(e,n.start.z))])));return i.length&&(i.unshift(i.pop()),i=Ta(i)),i.length<3?[]:i}getSegmentsForSide(t,e){const n=[];let a=0;for(let i of t){let r=i[1],o,l;if(r[2]==="R")o=l=r[3]*this.unitsMultiplier;else if(r[2]==="D")o=l=r[3]/2*this.unitsMultiplier;else if(r[2]==="DS"||r[2]==="RS")o=r[3]/(r[2]==="DS"?2:1)*this.unitsMultiplier,l=r[5]/(r[4]==="DE"?2:1)*this.unitsMultiplier;else if(dr(r))o=e,l=e;else throw new Error("unimplemented "+r);const c=new xe(o,a);if(n.length){const h=n.at(-1).end;h.isEqual(c)||n.push(new ke("LINE",h,c))}n.push(new ke(r[6]||"LINE",c,new xe(l,a+=r[1]*this.unitsMultiplier)))}return n}}function Ta(s){for(let t=0;t<s.length-1;t++){const e=s[t],n=s[t+1];if(e.isColinear(n)){const a=s.concat();return a.splice(t,2,new ke(e.type,e.start,n.end)),Ta(a)}}return s}function cr(s){const t=[];for(let e of s)e.isEmpty()||t.push(e);return t}function dr(s){return s.length===3||s[2]==="D"&&!s[3]}class jr extends bm{constructor(e){super();Tt(this,"camera");Tt(this,"renderer",new Or);Tt(this,"controls");Tt(this,"latheCode",null);Tt(this,"latheMesh",null);Tt(this,"stock",null);this.container=e,this.background=new $t(16777215),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=xr,this.renderer.setSize(500,500),this.addLight(),e.appendChild(this.renderer.domElement),this.renderer.domElement.addEventListener("click",()=>{this.controls.autoRotate=!1}),this.camera=new Ia(-7,7,-7,7,0,1e3),this.camera.position.z=5,this.controls=new Gm(this.camera,this.renderer.domElement),this.controls.autoRotate=!0,this.animate(),this.rotation.z=-8.5,this.rotation.y=1,this.rotation.x=1.5}getLatheMesh(){return this.latheMesh}fit(e){const n=new On().setFromObject(e),a=new V;n.getSize(a);const r=Math.max(a.x,a.y,a.z)*.7,o=Math.max(1/r,1);this.camera.left=-r,this.camera.right=r,this.camera.top=r,this.camera.bottom=-r,this.camera.zoom=o,this.camera.near=-1e5,this.camera.far=1e5,this.camera.updateProjectionMatrix()}addLight(){let e;e=new ua(16777215,1),e.castShadow=!0,e.position.set(0,1,0),this.add(e),e=new ua(16777215,.8),e.castShadow=!0,e.position.set(1,0,0),this.add(e),e=new ua(16777215,.6),e.castShadow=!0,e.position.set(0,0,1),this.add(e)}animate(){requestAnimationFrame(()=>this.animate()),this.controls.update(),this.renderer.render(this,this.camera)}setLatheCode(e){if(this.latheCode&&(this.setLatheMesh(null),this.setStock(null)),this.latheCode=e,this.latheCode){const n=this.createStock();this.setStock(Zm(n));const a=this.createLatheMesh();a.position.set(n.position.x,n.position.y-this.latheCode.getStock().length/2,n.position.z),this.setLatheMesh(a),this.fit(n)}}setLatheMesh(e){this.latheMesh&&this.remove(this.latheMesh),this.latheMesh=e,this.latheMesh&&this.add(this.latheMesh)}setStock(e){this.stock&&this.remove(this.stock),this.stock=e,this.stock&&this.add(this.stock)}createLatheMesh(){var o,l;const e=((o=this.latheCode)==null?void 0:o.getOutsideSegments())||[],n=((l=this.latheCode)==null?void 0:l.getInsideSegments())||[];if(e.length&&n.length)throw new Error("editor does not support both inside and outside profiles at the same time yet");const a=e.length?e:n;if(!(a!=null&&a.length))throw new Error("Unable to build the profile");const i=a.map(c=>Wm(c)).flat(),r=new Ka(i,256,0);return new sn(r,Rm())}createStock(){const e=this.latheCode.getStock();if(!e)throw new Error("stock is required");const n=new wa(e.diameter/2,e.diameter/2,e.length,256),a=new va({color:65280,transparent:!0,opacity:.3});return new sn(n,a)}}function Zm(s){const t=new On().setFromObject(s);return s.position.sub(t.getCenter(new V)),s}function Rm(){return new fm({color:16777215,roughness:1,metalness:.8,side:nn,transparent:!1,opacity:.8})}function Wm(s){const t=(s.type==="CONV"||s.type==="CONC")&&s.start.x===s.end.x;if(s.type==="LINE"||t)return[new Kt(s.start.x,s.start.z),new Kt(s.end.x,s.end.z)];if(s.type==="CONV"||s.type==="CONC")return Cm(s.start,s.end,s.type==="CONV",Math.max(10,(s.end.z-s.start.z)*10));throw new Error(`Approximation of segment of type ${s.type} is not implemented`)}function Cm(s,t,e,n){const a=Math.abs(t.x-s.x),i=Math.abs(t.z-s.z),r=t.x>s.x,o=r===e?new xe(s.x,t.z):new xe(t.x,s.z);let l=1,c=0,h=!1;r&&e?(l=1,c=0):r&&!e?(l=1,c=2):!r&&e?(l=-1,c=0):!r&&!e&&(l=-1,c=2,h=!0);const p=[];for(let u=0;u<=n;u++){const b=Math.PI/2*(l*u/n+c);p.push(new Kt(o.x+a*Math.cos(b),o.z-i*Math.sin(b)))}return h?p.reverse():p}function Qr(s){s.rotation.set(-Math.PI/2,0,0);for(let t of s.children)Qr(t);return s.updateMatrix(),s.updateMatrixWorld(!0),s}class vm{parse(t,e={}){e=Object.assign({binary:!1},e);const n=e.binary,a=[];let i=0;t.traverse(function(d){if(d.isMesh){const Z=d.geometry,L=Z.index,T=Z.getAttribute("position");i+=L!==null?L.count/3:T.count/3,a.push({object3d:d,geometry:Z})}});let r,o=80;if(n===!0){const d=i*2+i*3*4*4+80+4,Z=new ArrayBuffer(d);r=new DataView(Z),r.setUint32(o,i,!0),o+=4}else r="",r+=`solid exported
`;const l=new V,c=new V,h=new V,p=new V,u=new V,b=new V;for(let d=0,Z=a.length;d<Z;d++){const L=a[d].object3d,T=a[d].geometry,g=T.index,v=T.getAttribute("position");if(g!==null)for(let N=0;N<g.count;N+=3){const K=g.getX(N+0),G=g.getX(N+1),W=g.getX(N+2);x(K,G,W,v,L)}else for(let N=0;N<v.count;N+=3){const K=N+0,G=N+1,W=N+2;x(K,G,W,v,L)}}return n===!1&&(r+=`endsolid exported
`),r;function x(d,Z,L,T,g){l.fromBufferAttribute(T,d),c.fromBufferAttribute(T,Z),h.fromBufferAttribute(T,L),g.isSkinnedMesh===!0&&(g.applyBoneTransform(d,l),g.applyBoneTransform(Z,c),g.applyBoneTransform(L,h)),l.applyMatrix4(g.matrixWorld),c.applyMatrix4(g.matrixWorld),h.applyMatrix4(g.matrixWorld),y(l,c,h),m(l),m(c),m(h),n===!0?(r.setUint16(o,0,!0),o+=2):(r+=`		endloop
`,r+=`	endfacet
`)}function y(d,Z,L){p.subVectors(L,Z),u.subVectors(d,Z),p.cross(u).normalize(),b.copy(p).normalize(),n===!0?(r.setFloat32(o,b.x,!0),o+=4,r.setFloat32(o,b.y,!0),o+=4,r.setFloat32(o,b.z,!0),o+=4):(r+="	facet normal "+b.x+" "+b.y+" "+b.z+`
`,r+=`		outer loop
`)}function m(d){n===!0?(r.setFloat32(o,d.x,!0),o+=4,r.setFloat32(o,d.y,!0),o+=4,r.setFloat32(o,d.z,!0),o+=4):r+="			vertex "+d.x+" "+d.y+" "+d.z+`
`}}}function zm(s,t){const n=new vm().parse(Qr(s.clone()),{binary:!0}),a=new Blob([n],{type:"application/octet-stream"}),i=URL.createObjectURL(a),r=document.createElement("a");return r.href=i,r.download=Nm(t||`lathecode_${Date.now()}`),r}function Nm(s){const t=s.replace(/[<>:"/\\|?*\x00-\x1F]/g,"_");return t.toLowerCase().endsWith(".stl")?t:t+".stl"}class Im{constructor(t){Tt(this,"port",null);Tt(this,"readTimeout",0);Tt(this,"reader",null);Tt(this,"writer",null);Tt(this,"isOn",!1);Tt(this,"waitForOkOrError",!1);Tt(this,"lines",[]);Tt(this,"lineIndex",0);Tt(this,"unparsedResponse","");Tt(this,"error","");Tt(this,"mode","run");Tt(this,"h4Version",0);Tt(this,"statusReceived",!1);Tt(this,"z",0);Tt(this,"x",0);Tt(this,"feed",0);Tt(this,"rpm",0);this.statusChangeCallback=t}getStatus(){return{condition:this.port?this.isOn?"run":"idle":"disconnected",error:this.error,progress:this.lines.length?this.lineIndex/this.lines.length:0,z:this.z,x:this.x,feed:this.feed,rpm:this.rpm}}setStatus(t){t.startsWith("<")&&(t=t.substring(1)),t.endsWith(">")&&(t=t.slice(0,-1));const e=t.split("|");if(e.length>=3){if(this.statusReceived=!0,e[1].startsWith("WPos:")){const n=e[1].substring(5).split(",");this.z=Number(n[2]),this.x=Number(n[0])}if(e[2].startsWith("FS:")){const n=e[2].substring(3).split(",");this.feed=Number(n[0]),this.rpm=Number(n[1])}}e[3]&&e[3].startsWith("Id:H4V")&&(this.h4Version=Number(e[3].substring(6))||0),this.statusChangeCallback()}setError(t){this.error=t,this.statusChangeCallback()}async start(t,e){if(t&&(this.isOn&&this.stop(),!(!this.port&&(await this.selectPort(),!this.port)))){if(await this.askForStatus(),!await Vm(()=>this.statusReceived)){this.setError("Device is not reponding, is it in GCODE mode?");return}if(e=="save"&&this.h4Version<11){this.setError("Update H4 to at least version 11 to be able to save programs");return}if(this.mode=e,e=="run"&&!this.rpm){this.setError("Spindle is not running, turn it on first");return}this.lines=t.split(`
`),this.lineIndex=0,this.isOn=!0,this.setError(""),this.waitForOkOrError=!1,this.unparsedResponse="",e=="run"&&this.write("~"),this.writeCurrentLine(),this.statusChangeCallback()}}async stop(){this.mode=="run"&&await this.write("!"),this.isOn&&(this.isOn=!1,this.askForStatus(),this.statusChangeCallback())}async write(t){if(this.port){if(console.log("command: ",t),!this.port.writable){t!="?"&&this.setError("Port is not writable, try reconnecting the USB and switching to GCODE mode.");return}if(!this.writer)try{const e=new TextEncoderStream;e.readable.pipeTo(this.port.writable),this.writer=e.writable.getWriter()}catch(e){this.setError("Failed to write: "+e);return}await this.writer.write(t)}}async writeCurrentLine(){if(!this.isOn||this.waitForOkOrError)return;if(this.lineIndex>=this.lines.length){this.stop();return}const t=this.lines[this.lineIndex].split(";")[0].trim();if(!t){this.lineIndex++,this.writeCurrentLine();return}this.waitForOkOrError=!0,await this.write(t+`
`),await this.readFromPort()}async processResponse(t){this.unparsedResponse=(this.unparsedResponse+t).trimStart(),console.log(`response: "${t}"`);const e=this.unparsedResponse.match(/(<[^>]+>)/);if(e&&e.length>1){e.shift();for(const n of e)this.unparsedResponse=this.unparsedResponse.replace(n,"");this.setStatus(e.pop())}this.unparsedResponse.startsWith("error:")?(this.setError(this.unparsedResponse),this.unparsedResponse="",this.stop()):this.unparsedResponse.startsWith("ok")&&(this.unparsedResponse="",this.waitForOkOrError=!1,this.lineIndex++,this.statusChangeCallback(),this.isOn&&await this.writeCurrentLine())}async selectPort(){if(this.port&&this.closePort(),navigator.serial?this.port=await navigator.serial.requestPort():(this.error="This browser does not support Serial API, try Chrome or Edge",this.statusChangeCallback()),this.port)try{await this.port.open({baudRate:115200}),this.statusChangeCallback(),this.readSoon()}catch(t){this.setError(`Unable to open port - likely some other app is using it - try closing Arduino IDE.
${t}`),this.closePort()}}async askForStatus(){try{await this.write("?")}catch(t){this.setError(`Device disconnected? ${t}`),this.closePort()}}readSoon(){clearTimeout(this.readTimeout),this.readTimeout=window.setTimeout(()=>this.readFromPort(),1)}async readFromPort(){if(this.port)try{if(!this.port.readable){this.readSoon();return}if(!this.reader){const e=new TextDecoderStream;this.port.readable.pipeTo(e.writable),this.reader=e.readable.getReader()}const{value:t}=await this.reader.read();if(!t){this.readSoon();return}await this.processResponse(t),this.readSoon()}catch(t){this.setError(t.message||String(t)),this.closePort()}}async closePort(){if(this.port){clearTimeout(this.readTimeout),this.readTimeout=0,this.reader&&(this.reader.releaseLock&&this.reader.releaseLock(),this.reader=null),this.writer&&(this.writer.releaseLock&&this.writer.releaseLock(),this.writer=null);try{await this.port.close()}catch{}this.port=null,this.statusReceived=!1,this.z=0,this.x=0,this.feed=0,this.rpm=0}}}function Vm(s){return new Promise(t=>{let e=0;function n(){s()?t(!0):e>=10?t(!1):(e++,setTimeout(n,1))}n()})}function Km(s,t){let e=s.getFeed().moveMmMin;const n=t[0],a=wm(t),i=[...s.getText().trim().split(`
`).map(l=>l.startsWith(";")?l:`; ${l}`),"","; Run time $duration min, cutting $cutPercent% of time",`; Working area ${a.widthMm.toFixed(2)} by ${a.heightMm.toFixed(2)} mm`,"","G21 ; metric","G18 ; ZX plane","G90 ; absolute positioning",hr(e),`X${n.yStartMm} ; zero your tool X on centerline`,"Z0 ; zero your tool Z at the right edge of the stock","G91 ; relative positioning"];let r=0,o=0;for(const l of t){const c=Pm(l,s.getFeed(),s.getTool());e!==c&&(e=c,i.push("",hr(e))),i.push(Em(s,l));const h=Ym(l,e);r+=h,l.cutAreaMmSq&&(o+=h)}return i.join(`
`).replace("$duration",r.toFixed(1)).replace("$cutPercent",(o*100/r).toFixed(0))}function wm(s){let t=1/0,e=-1/0,n=1/0,a=-1/0;return s.forEach(i=>{t=Math.min(i.xStartMm,i.xStartMm+i.xDeltaMm,t),e=Math.max(i.xStartMm,i.xStartMm+i.xDeltaMm,e),n=Math.min(i.yStartMm,i.yStartMm+i.yDeltaMm,n),a=Math.max(i.yStartMm,i.yStartMm+i.yDeltaMm,a)}),{widthMm:e-t,heightMm:a-n}}function Em(s,t){const e="Z",n="X",a=[];return t.xDeltaMm&&a.push(e+ma(t.xDeltaMm*(s.getZDirection()==="LEFT"?1:-1),3)),t.yDeltaMm&&a.push(n+ma(t.yDeltaMm*(s.getXDirection()==="UP"?1:-1),3)),t.cutAreaMmSq&&(a.push(`; cut ${ma(t.cutAreaMmSq,4)} mm2`),t.xDeltaMm*t.yDeltaMm!==0&&!t.isBasic()&&a.push(`at ${(Math.atan(t.xDeltaMm/t.yDeltaMm)*180/Math.PI).toFixed(2)}`)),a.join(" ")}function Pm(s,t,e){return s.cutAreaMmSq<=.001?t.moveMmMin:!s.xDeltaMm&&s.cutAreaMmSq/s.yDeltaMm>e.widthMm/2?t.partMmMin:t.passMmMin}function hr(s){return"F"+s.toFixed(3).replace(/\.?0+$/,"")}function ma(s,t){return s.toFixed(t).replace(/\.?0+$/,"")}function Ym(s,t){return Math.sqrt(s.xDeltaMm*s.xDeltaMm+s.yDeltaMm*s.yDeltaMm)/t}class Hm{constructor(t){Tt(this,"runTextarea");Tt(this,"sendButton");Tt(this,"saveGcodeButton");Tt(this,"stopButton");Tt(this,"whatLink");Tt(this,"senderError");Tt(this,"runProgress");Tt(this,"sender",null);Tt(this,"saveName","Part 1");Tt(this,"latheCode",null);this.container=t,t.style.display="none",this.runTextarea=t.getElementsByTagName("textarea")[0],this.senderError=t.querySelector(".senderError"),this.runProgress=t.getElementsByTagName("progress")[0],this.sendButton=t.querySelector(".sendButton"),this.sendButton.addEventListener("click",()=>{this.send(this.runTextarea.value,"run")}),this.saveGcodeButton=t.querySelector(".saveGcodeButton"),this.saveGcodeButton.addEventListener("click",()=>{if(this.saveName=(prompt("Please enter a short name for this part",this.saveName)||"").trim(),!!this.saveName){if(this.saveName.length<2){alert("Name should contain at least 2 characters");return}if(!/^[0-9a-zA-Z +\-_]+$/.test(this.saveName)){alert("Name can only consist of English alpha-numericals, space and +-_");return}this.send(`"${this.saveName}
${this.runTextarea.value}"`,"save")}}),this.stopButton=t.querySelector(".stopButton"),this.stopButton.addEventListener("click",()=>this.sender.stop()),this.stopButton.style.display="none",this.whatLink=t.querySelector(".whatLink")}send(t,e){var n;if(!((n=this.latheCode)!=null&&n.isNanoElsCompatible())){alert("This lathecode is not complatible with NanoEls due to axis direction");return}this.sender||(this.sender=new Im(()=>this.senderStatusChange())),this.sender.start(t,e)}hide(){this.container.style.display="none"}show(t,e){this.latheCode=t,this.runTextarea.value=Km(t,e),this.container.style.display="block",this.runTextarea.scrollIntoView({behavior:"smooth"})}senderStatusChange(){if(!this.sender)return;const t=this.sender.getStatus(),e=t.condition==="run";this.runProgress&&(this.runProgress.value=t.progress,this.runProgress.style.display=e?"block":"none"),t.condition!=="disconnected"&&this.whatLink.parentNode&&this.whatLink.remove(),this.stopButton&&(this.stopButton.style.display=e?"inline-block":"none"),this.sendButton&&(this.sendButton.style.display=e?"none":"inline-block"),this.saveGcodeButton&&(this.saveGcodeButton.style.display=e?"none":"inline-block"),this.senderError&&(this.senderError.style.display=t.error?"block":"none",this.senderError.innerText=t.error||"")}}const qr="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGoodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsImRlZmF1bHQiKT90LmRlZmF1bHQ6dH12YXIgTj17ZXhwb3J0czp7fX0sUD17YWxpY2VibHVlOlsyNDAsMjQ4LDI1NV0sYW50aXF1ZXdoaXRlOlsyNTAsMjM1LDIxNV0sYXF1YTpbMCwyNTUsMjU1XSxhcXVhbWFyaW5lOlsxMjcsMjU1LDIxMl0sYXp1cmU6WzI0MCwyNTUsMjU1XSxiZWlnZTpbMjQ1LDI0NSwyMjBdLGJpc3F1ZTpbMjU1LDIyOCwxOTZdLGJsYWNrOlswLDAsMF0sYmxhbmNoZWRhbG1vbmQ6WzI1NSwyMzUsMjA1XSxibHVlOlswLDAsMjU1XSxibHVldmlvbGV0OlsxMzgsNDMsMjI2XSxicm93bjpbMTY1LDQyLDQyXSxidXJseXdvb2Q6WzIyMiwxODQsMTM1XSxjYWRldGJsdWU6Wzk1LDE1OCwxNjBdLGNoYXJ0cmV1c2U6WzEyNywyNTUsMF0sY2hvY29sYXRlOlsyMTAsMTA1LDMwXSxjb3JhbDpbMjU1LDEyNyw4MF0sY29ybmZsb3dlcmJsdWU6WzEwMCwxNDksMjM3XSxjb3Juc2lsazpbMjU1LDI0OCwyMjBdLGNyaW1zb246WzIyMCwyMCw2MF0sY3lhbjpbMCwyNTUsMjU1XSxkYXJrYmx1ZTpbMCwwLDEzOV0sZGFya2N5YW46WzAsMTM5LDEzOV0sZGFya2dvbGRlbnJvZDpbMTg0LDEzNCwxMV0sZGFya2dyYXk6WzE2OSwxNjksMTY5XSxkYXJrZ3JlZW46WzAsMTAwLDBdLGRhcmtncmV5OlsxNjksMTY5LDE2OV0sZGFya2toYWtpOlsxODksMTgzLDEwN10sZGFya21hZ2VudGE6WzEzOSwwLDEzOV0sZGFya29saXZlZ3JlZW46Wzg1LDEwNyw0N10sZGFya29yYW5nZTpbMjU1LDE0MCwwXSxkYXJrb3JjaGlkOlsxNTMsNTAsMjA0XSxkYXJrcmVkOlsxMzksMCwwXSxkYXJrc2FsbW9uOlsyMzMsMTUwLDEyMl0sZGFya3NlYWdyZWVuOlsxNDMsMTg4LDE0M10sZGFya3NsYXRlYmx1ZTpbNzIsNjEsMTM5XSxkYXJrc2xhdGVncmF5Ols0Nyw3OSw3OV0sZGFya3NsYXRlZ3JleTpbNDcsNzksNzldLGRhcmt0dXJxdW9pc2U6WzAsMjA2LDIwOV0sZGFya3Zpb2xldDpbMTQ4LDAsMjExXSxkZWVwcGluazpbMjU1LDIwLDE0N10sZGVlcHNreWJsdWU6WzAsMTkxLDI1NV0sZGltZ3JheTpbMTA1LDEwNSwxMDVdLGRpbWdyZXk6WzEwNSwxMDUsMTA1XSxkb2RnZXJibHVlOlszMCwxNDQsMjU1XSxmaXJlYnJpY2s6WzE3OCwzNCwzNF0sZmxvcmFsd2hpdGU6WzI1NSwyNTAsMjQwXSxmb3Jlc3RncmVlbjpbMzQsMTM5LDM0XSxmdWNoc2lhOlsyNTUsMCwyNTVdLGdhaW5zYm9ybzpbMjIwLDIyMCwyMjBdLGdob3N0d2hpdGU6WzI0OCwyNDgsMjU1XSxnb2xkOlsyNTUsMjE1LDBdLGdvbGRlbnJvZDpbMjE4LDE2NSwzMl0sZ3JheTpbMTI4LDEyOCwxMjhdLGdyZWVuOlswLDEyOCwwXSxncmVlbnllbGxvdzpbMTczLDI1NSw0N10sZ3JleTpbMTI4LDEyOCwxMjhdLGhvbmV5ZGV3OlsyNDAsMjU1LDI0MF0saG90cGluazpbMjU1LDEwNSwxODBdLGluZGlhbnJlZDpbMjA1LDkyLDkyXSxpbmRpZ286Wzc1LDAsMTMwXSxpdm9yeTpbMjU1LDI1NSwyNDBdLGtoYWtpOlsyNDAsMjMwLDE0MF0sbGF2ZW5kZXI6WzIzMCwyMzAsMjUwXSxsYXZlbmRlcmJsdXNoOlsyNTUsMjQwLDI0NV0sbGF3bmdyZWVuOlsxMjQsMjUyLDBdLGxlbW9uY2hpZmZvbjpbMjU1LDI1MCwyMDVdLGxpZ2h0Ymx1ZTpbMTczLDIxNiwyMzBdLGxpZ2h0Y29yYWw6WzI0MCwxMjgsMTI4XSxsaWdodGN5YW46WzIyNCwyNTUsMjU1XSxsaWdodGdvbGRlbnJvZHllbGxvdzpbMjUwLDI1MCwyMTBdLGxpZ2h0Z3JheTpbMjExLDIxMSwyMTFdLGxpZ2h0Z3JlZW46WzE0NCwyMzgsMTQ0XSxsaWdodGdyZXk6WzIxMSwyMTEsMjExXSxsaWdodHBpbms6WzI1NSwxODIsMTkzXSxsaWdodHNhbG1vbjpbMjU1LDE2MCwxMjJdLGxpZ2h0c2VhZ3JlZW46WzMyLDE3OCwxNzBdLGxpZ2h0c2t5Ymx1ZTpbMTM1LDIwNiwyNTBdLGxpZ2h0c2xhdGVncmF5OlsxMTksMTM2LDE1M10sbGlnaHRzbGF0ZWdyZXk6WzExOSwxMzYsMTUzXSxsaWdodHN0ZWVsYmx1ZTpbMTc2LDE5NiwyMjJdLGxpZ2h0eWVsbG93OlsyNTUsMjU1LDIyNF0sbGltZTpbMCwyNTUsMF0sbGltZWdyZWVuOls1MCwyMDUsNTBdLGxpbmVuOlsyNTAsMjQwLDIzMF0sbWFnZW50YTpbMjU1LDAsMjU1XSxtYXJvb246WzEyOCwwLDBdLG1lZGl1bWFxdWFtYXJpbmU6WzEwMiwyMDUsMTcwXSxtZWRpdW1ibHVlOlswLDAsMjA1XSxtZWRpdW1vcmNoaWQ6WzE4Niw4NSwyMTFdLG1lZGl1bXB1cnBsZTpbMTQ3LDExMiwyMTldLG1lZGl1bXNlYWdyZWVuOls2MCwxNzksMTEzXSxtZWRpdW1zbGF0ZWJsdWU6WzEyMywxMDQsMjM4XSxtZWRpdW1zcHJpbmdncmVlbjpbMCwyNTAsMTU0XSxtZWRpdW10dXJxdW9pc2U6WzcyLDIwOSwyMDRdLG1lZGl1bXZpb2xldHJlZDpbMTk5LDIxLDEzM10sbWlkbmlnaHRibHVlOlsyNSwyNSwxMTJdLG1pbnRjcmVhbTpbMjQ1LDI1NSwyNTBdLG1pc3R5cm9zZTpbMjU1LDIyOCwyMjVdLG1vY2Nhc2luOlsyNTUsMjI4LDE4MV0sbmF2YWpvd2hpdGU6WzI1NSwyMjIsMTczXSxuYXZ5OlswLDAsMTI4XSxvbGRsYWNlOlsyNTMsMjQ1LDIzMF0sb2xpdmU6WzEyOCwxMjgsMF0sb2xpdmVkcmFiOlsxMDcsMTQyLDM1XSxvcmFuZ2U6WzI1NSwxNjUsMF0sb3JhbmdlcmVkOlsyNTUsNjksMF0sb3JjaGlkOlsyMTgsMTEyLDIxNF0scGFsZWdvbGRlbnJvZDpbMjM4LDIzMiwxNzBdLHBhbGVncmVlbjpbMTUyLDI1MSwxNTJdLHBhbGV0dXJxdW9pc2U6WzE3NSwyMzgsMjM4XSxwYWxldmlvbGV0cmVkOlsyMTksMTEyLDE0N10scGFwYXlhd2hpcDpbMjU1LDIzOSwyMTNdLHBlYWNocHVmZjpbMjU1LDIxOCwxODVdLHBlcnU6WzIwNSwxMzMsNjNdLHBpbms6WzI1NSwxOTIsMjAzXSxwbHVtOlsyMjEsMTYwLDIyMV0scG93ZGVyYmx1ZTpbMTc2LDIyNCwyMzBdLHB1cnBsZTpbMTI4LDAsMTI4XSxyZWJlY2NhcHVycGxlOlsxMDIsNTEsMTUzXSxyZWQ6WzI1NSwwLDBdLHJvc3licm93bjpbMTg4LDE0MywxNDNdLHJveWFsYmx1ZTpbNjUsMTA1LDIyNV0sc2FkZGxlYnJvd246WzEzOSw2OSwxOV0sc2FsbW9uOlsyNTAsMTI4LDExNF0sc2FuZHlicm93bjpbMjQ0LDE2NCw5Nl0sc2VhZ3JlZW46WzQ2LDEzOSw4N10sc2Vhc2hlbGw6WzI1NSwyNDUsMjM4XSxzaWVubmE6WzE2MCw4Miw0NV0sc2lsdmVyOlsxOTIsMTkyLDE5Ml0sc2t5Ymx1ZTpbMTM1LDIwNiwyMzVdLHNsYXRlYmx1ZTpbMTA2LDkwLDIwNV0sc2xhdGVncmF5OlsxMTIsMTI4LDE0NF0sc2xhdGVncmV5OlsxMTIsMTI4LDE0NF0sc25vdzpbMjU1LDI1MCwyNTBdLHNwcmluZ2dyZWVuOlswLDI1NSwxMjddLHN0ZWVsYmx1ZTpbNzAsMTMwLDE4MF0sdGFuOlsyMTAsMTgwLDE0MF0sdGVhbDpbMCwxMjgsMTI4XSx0aGlzdGxlOlsyMTYsMTkxLDIxNl0sdG9tYXRvOlsyNTUsOTksNzFdLHR1cnF1b2lzZTpbNjQsMjI0LDIwOF0sdmlvbGV0OlsyMzgsMTMwLDIzOF0sd2hlYXQ6WzI0NSwyMjIsMTc5XSx3aGl0ZTpbMjU1LDI1NSwyNTVdLHdoaXRlc21va2U6WzI0NSwyNDUsMjQ1XSx5ZWxsb3c6WzI1NSwyNTUsMF0seWVsbG93Z3JlZW46WzE1NCwyMDUsNTBdfSxUPXtleHBvcnRzOnt9fSxYPWZ1bmN0aW9uKGUpe3JldHVybiFlfHx0eXBlb2YgZT09InN0cmluZyI/ITE6ZSBpbnN0YW5jZW9mIEFycmF5fHxBcnJheS5pc0FycmF5KGUpfHxlLmxlbmd0aD49MCYmKGUuc3BsaWNlIGluc3RhbmNlb2YgRnVuY3Rpb258fE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxlLmxlbmd0aC0xKSYmZS5jb25zdHJ1Y3Rvci5uYW1lIT09IlN0cmluZyIpfSxfPVgsVj1BcnJheS5wcm90b3R5cGUuY29uY2F0LEc9QXJyYXkucHJvdG90eXBlLnNsaWNlLEI9VC5leHBvcnRzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgbj1bXSxyPTAscz1lLmxlbmd0aDtyPHM7cisrKXt2YXIgbz1lW3JdO18obyk/bj1WLmNhbGwobixHLmNhbGwobykpOm4ucHVzaChvKX1yZXR1cm4gbn07Qi53cmFwPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KEIoYXJndW1lbnRzKSl9fTt2YXIgSj1ULmV4cG9ydHMsaz1QLEQ9SixVPU9iamVjdC5oYXNPd25Qcm9wZXJ0eSxMPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKHZhciBPIGluIGspVS5jYWxsKGssTykmJihMW2tbT11dPU8pO3ZhciBiPU4uZXhwb3J0cz17dG86e30sZ2V0Ont9fTtiLmdldD1mdW5jdGlvbih0KXt2YXIgZT10LnN1YnN0cmluZygwLDMpLnRvTG93ZXJDYXNlKCksbixyO3N3aXRjaChlKXtjYXNlImhzbCI6bj1iLmdldC5oc2wodCkscj0iaHNsIjticmVhaztjYXNlImh3YiI6bj1iLmdldC5od2IodCkscj0iaHdiIjticmVhaztkZWZhdWx0Om49Yi5nZXQucmdiKHQpLHI9InJnYiI7YnJlYWt9cmV0dXJuIG4/e21vZGVsOnIsdmFsdWU6bn06bnVsbH0sYi5nZXQucmdiPWZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiBudWxsO3ZhciBlPS9eIyhbYS1mMC05XXszLDR9KSQvaSxuPS9eIyhbYS1mMC05XXs2fSkoW2EtZjAtOV17Mn0pPyQvaSxyPS9ecmdiYT9cKFxzKihbKy1dP1xkKykoPz1bXHMsXSlccyooPzosXHMqKT8oWystXT9cZCspKD89W1xzLF0pXHMqKD86LFxzKik/KFsrLV0/XGQrKVxzKig/OlssfFwvXVxzKihbKy1dP1tcZFwuXSspKCU/KVxzKik/XCkkLyxzPS9ecmdiYT9cKFxzKihbKy1dP1tcZFwuXSspXCVccyosP1xzKihbKy1dP1tcZFwuXSspXCVccyosP1xzKihbKy1dP1tcZFwuXSspXCVccyooPzpbLHxcL11ccyooWystXT9bXGRcLl0rKSglPylccyopP1wpJC8sbz0vXihcdyspJC8sYT1bMCwwLDAsMV0sbCxpLGg7aWYobD10Lm1hdGNoKG4pKXtmb3IoaD1sWzJdLGw9bFsxXSxpPTA7aTwzO2krKyl7dmFyIGQ9aSoyO2FbaV09cGFyc2VJbnQobC5zbGljZShkLGQrMiksMTYpfWgmJihhWzNdPXBhcnNlSW50KGgsMTYpLzI1NSl9ZWxzZSBpZihsPXQubWF0Y2goZSkpe2ZvcihsPWxbMV0saD1sWzNdLGk9MDtpPDM7aSsrKWFbaV09cGFyc2VJbnQobFtpXStsW2ldLDE2KTtoJiYoYVszXT1wYXJzZUludChoK2gsMTYpLzI1NSl9ZWxzZSBpZihsPXQubWF0Y2gocikpe2ZvcihpPTA7aTwzO2krKylhW2ldPXBhcnNlSW50KGxbaSsxXSwwKTtsWzRdJiYobFs1XT9hWzNdPXBhcnNlRmxvYXQobFs0XSkqLjAxOmFbM109cGFyc2VGbG9hdChsWzRdKSl9ZWxzZSBpZihsPXQubWF0Y2gocykpe2ZvcihpPTA7aTwzO2krKylhW2ldPU1hdGgucm91bmQocGFyc2VGbG9hdChsW2krMV0pKjIuNTUpO2xbNF0mJihsWzVdP2FbM109cGFyc2VGbG9hdChsWzRdKSouMDE6YVszXT1wYXJzZUZsb2F0KGxbNF0pKX1lbHNlIHJldHVybihsPXQubWF0Y2gobykpP2xbMV09PT0idHJhbnNwYXJlbnQiP1swLDAsMCwwXTpVLmNhbGwoayxsWzFdKT8oYT1rW2xbMV1dLGFbM109MSxhKTpudWxsOm51bGw7Zm9yKGk9MDtpPDM7aSsrKWFbaV09bShhW2ldLDAsMjU1KTtyZXR1cm4gYVszXT1tKGFbM10sMCwxKSxhfSxiLmdldC5oc2w9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIG51bGw7dmFyIGU9L15oc2xhP1woXHMqKFsrLV0/KD86XGR7MCwzfVwuKT9cZCspKD86ZGVnKT9ccyosP1xzKihbKy1dP1tcZFwuXSspJVxzKiw/XHMqKFsrLV0/W1xkXC5dKyklXHMqKD86Wyx8XC9dXHMqKFsrLV0/KD89XC5cZHxcZCkoPzowfFsxLTldXGQqKT8oPzpcLlxkKik/KD86W2VFXVsrLV0/XGQrKT8pXHMqKT9cKSQvLG49dC5tYXRjaChlKTtpZihuKXt2YXIgcj1wYXJzZUZsb2F0KG5bNF0pLHM9KHBhcnNlRmxvYXQoblsxXSklMzYwKzM2MCklMzYwLG89bShwYXJzZUZsb2F0KG5bMl0pLDAsMTAwKSxhPW0ocGFyc2VGbG9hdChuWzNdKSwwLDEwMCksbD1tKGlzTmFOKHIpPzE6ciwwLDEpO3JldHVybltzLG8sYSxsXX1yZXR1cm4gbnVsbH0sYi5nZXQuaHdiPWZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiBudWxsO3ZhciBlPS9eaHdiXChccyooWystXT9cZHswLDN9KD86XC5cZCspPykoPzpkZWcpP1xzKixccyooWystXT9bXGRcLl0rKSVccyosXHMqKFsrLV0/W1xkXC5dKyklXHMqKD86LFxzKihbKy1dPyg/PVwuXGR8XGQpKD86MHxbMS05XVxkKik/KD86XC5cZCopPyg/OltlRV1bKy1dP1xkKyk/KVxzKik/XCkkLyxuPXQubWF0Y2goZSk7aWYobil7dmFyIHI9cGFyc2VGbG9hdChuWzRdKSxzPShwYXJzZUZsb2F0KG5bMV0pJTM2MCszNjApJTM2MCxvPW0ocGFyc2VGbG9hdChuWzJdKSwwLDEwMCksYT1tKHBhcnNlRmxvYXQoblszXSksMCwxMDApLGw9bShpc05hTihyKT8xOnIsMCwxKTtyZXR1cm5bcyxvLGEsbF19cmV0dXJuIG51bGx9LGIudG8uaGV4PWZ1bmN0aW9uKCl7dmFyIHQ9RChhcmd1bWVudHMpO3JldHVybiIjIitBKHRbMF0pK0EodFsxXSkrQSh0WzJdKSsodFszXTwxP0EoTWF0aC5yb3VuZCh0WzNdKjI1NSkpOiIiKX0sYi50by5yZ2I9ZnVuY3Rpb24oKXt2YXIgdD1EKGFyZ3VtZW50cyk7cmV0dXJuIHQubGVuZ3RoPDR8fHRbM109PT0xPyJyZ2IoIitNYXRoLnJvdW5kKHRbMF0pKyIsICIrTWF0aC5yb3VuZCh0WzFdKSsiLCAiK01hdGgucm91bmQodFsyXSkrIikiOiJyZ2JhKCIrTWF0aC5yb3VuZCh0WzBdKSsiLCAiK01hdGgucm91bmQodFsxXSkrIiwgIitNYXRoLnJvdW5kKHRbMl0pKyIsICIrdFszXSsiKSJ9LGIudG8ucmdiLnBlcmNlbnQ9ZnVuY3Rpb24oKXt2YXIgdD1EKGFyZ3VtZW50cyksZT1NYXRoLnJvdW5kKHRbMF0vMjU1KjEwMCksbj1NYXRoLnJvdW5kKHRbMV0vMjU1KjEwMCkscj1NYXRoLnJvdW5kKHRbMl0vMjU1KjEwMCk7cmV0dXJuIHQubGVuZ3RoPDR8fHRbM109PT0xPyJyZ2IoIitlKyIlLCAiK24rIiUsICIrcisiJSkiOiJyZ2JhKCIrZSsiJSwgIituKyIlLCAiK3IrIiUsICIrdFszXSsiKSJ9LGIudG8uaHNsPWZ1bmN0aW9uKCl7dmFyIHQ9RChhcmd1bWVudHMpO3JldHVybiB0Lmxlbmd0aDw0fHx0WzNdPT09MT8iaHNsKCIrdFswXSsiLCAiK3RbMV0rIiUsICIrdFsyXSsiJSkiOiJoc2xhKCIrdFswXSsiLCAiK3RbMV0rIiUsICIrdFsyXSsiJSwgIit0WzNdKyIpIn0sYi50by5od2I9ZnVuY3Rpb24oKXt2YXIgdD1EKGFyZ3VtZW50cyksZT0iIjtyZXR1cm4gdC5sZW5ndGg+PTQmJnRbM10hPT0xJiYoZT0iLCAiK3RbM10pLCJod2IoIit0WzBdKyIsICIrdFsxXSsiJSwgIit0WzJdKyIlIitlKyIpIn0sYi50by5rZXl3b3JkPWZ1bmN0aW9uKHQpe3JldHVybiBMW3Quc2xpY2UoMCwzKV19O2Z1bmN0aW9uIG0odCxlLG4pe3JldHVybiBNYXRoLm1pbihNYXRoLm1heChlLHQpLG4pfWZ1bmN0aW9uIEEodCl7dmFyIGU9TWF0aC5yb3VuZCh0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtyZXR1cm4gZS5sZW5ndGg8Mj8iMCIrZTplfXZhciBRPU4uZXhwb3J0cztjb25zdCBTPVAsUj17fTtmb3IoY29uc3QgdCBvZiBPYmplY3Qua2V5cyhTKSlSW1NbdF1dPXQ7Y29uc3QgYz17cmdiOntjaGFubmVsczozLGxhYmVsczoicmdiIn0saHNsOntjaGFubmVsczozLGxhYmVsczoiaHNsIn0saHN2OntjaGFubmVsczozLGxhYmVsczoiaHN2In0saHdiOntjaGFubmVsczozLGxhYmVsczoiaHdiIn0sY215azp7Y2hhbm5lbHM6NCxsYWJlbHM6ImNteWsifSx4eXo6e2NoYW5uZWxzOjMsbGFiZWxzOiJ4eXoifSxsYWI6e2NoYW5uZWxzOjMsbGFiZWxzOiJsYWIifSxsY2g6e2NoYW5uZWxzOjMsbGFiZWxzOiJsY2gifSxoZXg6e2NoYW5uZWxzOjEsbGFiZWxzOlsiaGV4Il19LGtleXdvcmQ6e2NoYW5uZWxzOjEsbGFiZWxzOlsia2V5d29yZCJdfSxhbnNpMTY6e2NoYW5uZWxzOjEsbGFiZWxzOlsiYW5zaTE2Il19LGFuc2kyNTY6e2NoYW5uZWxzOjEsbGFiZWxzOlsiYW5zaTI1NiJdfSxoY2c6e2NoYW5uZWxzOjMsbGFiZWxzOlsiaCIsImMiLCJnIl19LGFwcGxlOntjaGFubmVsczozLGxhYmVsczpbInIxNiIsImcxNiIsImIxNiJdfSxncmF5OntjaGFubmVsczoxLGxhYmVsczpbImdyYXkiXX19O3ZhciBIPWM7Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmtleXMoYykpe2lmKCEoImNoYW5uZWxzImluIGNbdF0pKXRocm93IG5ldyBFcnJvcigibWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogIit0KTtpZighKCJsYWJlbHMiaW4gY1t0XSkpdGhyb3cgbmV3IEVycm9yKCJtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiAiK3QpO2lmKGNbdF0ubGFiZWxzLmxlbmd0aCE9PWNbdF0uY2hhbm5lbHMpdGhyb3cgbmV3IEVycm9yKCJjaGFubmVsIGFuZCBsYWJlbCBjb3VudHMgbWlzbWF0Y2g6ICIrdCk7Y29uc3R7Y2hhbm5lbHM6ZSxsYWJlbHM6bn09Y1t0XTtkZWxldGUgY1t0XS5jaGFubmVscyxkZWxldGUgY1t0XS5sYWJlbHMsT2JqZWN0LmRlZmluZVByb3BlcnR5KGNbdF0sImNoYW5uZWxzIix7dmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjW3RdLCJsYWJlbHMiLHt2YWx1ZTpufSl9Yy5yZ2IuaHNsPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFswXS8yNTUsbj10WzFdLzI1NSxyPXRbMl0vMjU1LHM9TWF0aC5taW4oZSxuLHIpLG89TWF0aC5tYXgoZSxuLHIpLGE9by1zO2xldCBsLGk7bz09PXM/bD0wOmU9PT1vP2w9KG4tcikvYTpuPT09bz9sPTIrKHItZSkvYTpyPT09byYmKGw9NCsoZS1uKS9hKSxsPU1hdGgubWluKGwqNjAsMzYwKSxsPDAmJihsKz0zNjApO2NvbnN0IGg9KHMrbykvMjtyZXR1cm4gbz09PXM/aT0wOmg8PS41P2k9YS8obytzKTppPWEvKDItby1zKSxbbCxpKjEwMCxoKjEwMF19LGMucmdiLmhzdj1mdW5jdGlvbih0KXtsZXQgZSxuLHIscyxvO2NvbnN0IGE9dFswXS8yNTUsbD10WzFdLzI1NSxpPXRbMl0vMjU1LGg9TWF0aC5tYXgoYSxsLGkpLGQ9aC1NYXRoLm1pbihhLGwsaSkscD1mdW5jdGlvbihxKXtyZXR1cm4oaC1xKS82L2QrMS8yfTtyZXR1cm4gZD09PTA/KHM9MCxvPTApOihvPWQvaCxlPXAoYSksbj1wKGwpLHI9cChpKSxhPT09aD9zPXItbjpsPT09aD9zPTEvMytlLXI6aT09PWgmJihzPTIvMytuLWUpLHM8MD9zKz0xOnM+MSYmKHMtPTEpKSxbcyozNjAsbyoxMDAsaCoxMDBdfSxjLnJnYi5od2I9ZnVuY3Rpb24odCl7Y29uc3QgZT10WzBdLG49dFsxXTtsZXQgcj10WzJdO2NvbnN0IHM9Yy5yZ2IuaHNsKHQpWzBdLG89MS8yNTUqTWF0aC5taW4oZSxNYXRoLm1pbihuLHIpKTtyZXR1cm4gcj0xLTEvMjU1Kk1hdGgubWF4KGUsTWF0aC5tYXgobixyKSksW3MsbyoxMDAscioxMDBdfSxjLnJnYi5jbXlrPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFswXS8yNTUsbj10WzFdLzI1NSxyPXRbMl0vMjU1LHM9TWF0aC5taW4oMS1lLDEtbiwxLXIpLG89KDEtZS1zKS8oMS1zKXx8MCxhPSgxLW4tcykvKDEtcyl8fDAsbD0oMS1yLXMpLygxLXMpfHwwO3JldHVybltvKjEwMCxhKjEwMCxsKjEwMCxzKjEwMF19O2Z1bmN0aW9uIFcodCxlKXtyZXR1cm4odFswXS1lWzBdKSoqMisodFsxXS1lWzFdKSoqMisodFsyXS1lWzJdKSoqMn1jLnJnYi5rZXl3b3JkPWZ1bmN0aW9uKHQpe2NvbnN0IGU9Ult0XTtpZihlKXJldHVybiBlO2xldCBuPTEvMCxyO2Zvcihjb25zdCBzIG9mIE9iamVjdC5rZXlzKFMpKXtjb25zdCBvPVNbc10sYT1XKHQsbyk7YTxuJiYobj1hLHI9cyl9cmV0dXJuIHJ9LGMua2V5d29yZC5yZ2I9ZnVuY3Rpb24odCl7cmV0dXJuIFNbdF19LGMucmdiLnh5ej1mdW5jdGlvbih0KXtsZXQgZT10WzBdLzI1NSxuPXRbMV0vMjU1LHI9dFsyXS8yNTU7ZT1lPi4wNDA0NT8oKGUrLjA1NSkvMS4wNTUpKioyLjQ6ZS8xMi45MixuPW4+LjA0MDQ1PygobisuMDU1KS8xLjA1NSkqKjIuNDpuLzEyLjkyLHI9cj4uMDQwNDU/KChyKy4wNTUpLzEuMDU1KSoqMi40OnIvMTIuOTI7Y29uc3Qgcz1lKi40MTI0K24qLjM1NzYrciouMTgwNSxvPWUqLjIxMjYrbiouNzE1MityKi4wNzIyLGE9ZSouMDE5MytuKi4xMTkyK3IqLjk1MDU7cmV0dXJuW3MqMTAwLG8qMTAwLGEqMTAwXX0sYy5yZ2IubGFiPWZ1bmN0aW9uKHQpe2NvbnN0IGU9Yy5yZ2IueHl6KHQpO2xldCBuPWVbMF0scj1lWzFdLHM9ZVsyXTtuLz05NS4wNDcsci89MTAwLHMvPTEwOC44ODMsbj1uPi4wMDg4NTY/bioqKDEvMyk6Ny43ODcqbisxNi8xMTYscj1yPi4wMDg4NTY/cioqKDEvMyk6Ny43ODcqcisxNi8xMTYscz1zPi4wMDg4NTY/cyoqKDEvMyk6Ny43ODcqcysxNi8xMTY7Y29uc3Qgbz0xMTYqci0xNixhPTUwMCoobi1yKSxsPTIwMCooci1zKTtyZXR1cm5bbyxhLGxdfSxjLmhzbC5yZ2I9ZnVuY3Rpb24odCl7Y29uc3QgZT10WzBdLzM2MCxuPXRbMV0vMTAwLHI9dFsyXS8xMDA7bGV0IHMsbyxhO2lmKG49PT0wKXJldHVybiBhPXIqMjU1LFthLGEsYV07cjwuNT9zPXIqKDErbik6cz1yK24tcipuO2NvbnN0IGw9MipyLXMsaT1bMCwwLDBdO2ZvcihsZXQgaD0wO2g8MztoKyspbz1lKzEvMyotKGgtMSksbzwwJiZvKyssbz4xJiZvLS0sNipvPDE/YT1sKyhzLWwpKjYqbzoyKm88MT9hPXM6MypvPDI/YT1sKyhzLWwpKigyLzMtbykqNjphPWwsaVtoXT1hKjI1NTtyZXR1cm4gaX0sYy5oc2wuaHN2PWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFswXTtsZXQgbj10WzFdLzEwMCxyPXRbMl0vMTAwLHM9bjtjb25zdCBvPU1hdGgubWF4KHIsLjAxKTtyKj0yLG4qPXI8PTE/cjoyLXIscyo9bzw9MT9vOjItbztjb25zdCBhPShyK24pLzIsbD1yPT09MD8yKnMvKG8rcyk6MipuLyhyK24pO3JldHVybltlLGwqMTAwLGEqMTAwXX0sYy5oc3YucmdiPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFswXS82MCxuPXRbMV0vMTAwO2xldCByPXRbMl0vMTAwO2NvbnN0IHM9TWF0aC5mbG9vcihlKSU2LG89ZS1NYXRoLmZsb29yKGUpLGE9MjU1KnIqKDEtbiksbD0yNTUqciooMS1uKm8pLGk9MjU1KnIqKDEtbiooMS1vKSk7c3dpdGNoKHIqPTI1NSxzKXtjYXNlIDA6cmV0dXJuW3IsaSxhXTtjYXNlIDE6cmV0dXJuW2wscixhXTtjYXNlIDI6cmV0dXJuW2EscixpXTtjYXNlIDM6cmV0dXJuW2EsbCxyXTtjYXNlIDQ6cmV0dXJuW2ksYSxyXTtjYXNlIDU6cmV0dXJuW3IsYSxsXX19LGMuaHN2LmhzbD1mdW5jdGlvbih0KXtjb25zdCBlPXRbMF0sbj10WzFdLzEwMCxyPXRbMl0vMTAwLHM9TWF0aC5tYXgociwuMDEpO2xldCBvLGE7YT0oMi1uKSpyO2NvbnN0IGw9KDItbikqcztyZXR1cm4gbz1uKnMsby89bDw9MT9sOjItbCxvPW98fDAsYS89MixbZSxvKjEwMCxhKjEwMF19LGMuaHdiLnJnYj1mdW5jdGlvbih0KXtjb25zdCBlPXRbMF0vMzYwO2xldCBuPXRbMV0vMTAwLHI9dFsyXS8xMDA7Y29uc3Qgcz1uK3I7bGV0IG87cz4xJiYobi89cyxyLz1zKTtjb25zdCBhPU1hdGguZmxvb3IoNiplKSxsPTEtcjtvPTYqZS1hLGEmMSYmKG89MS1vKTtjb25zdCBpPW4rbyoobC1uKTtsZXQgaCxkLHA7c3dpdGNoKGEpe2RlZmF1bHQ6Y2FzZSA2OmNhc2UgMDpoPWwsZD1pLHA9bjticmVhaztjYXNlIDE6aD1pLGQ9bCxwPW47YnJlYWs7Y2FzZSAyOmg9bixkPWwscD1pO2JyZWFrO2Nhc2UgMzpoPW4sZD1pLHA9bDticmVhaztjYXNlIDQ6aD1pLGQ9bixwPWw7YnJlYWs7Y2FzZSA1Omg9bCxkPW4scD1pO2JyZWFrfXJldHVybltoKjI1NSxkKjI1NSxwKjI1NV19LGMuY215ay5yZ2I9ZnVuY3Rpb24odCl7Y29uc3QgZT10WzBdLzEwMCxuPXRbMV0vMTAwLHI9dFsyXS8xMDAscz10WzNdLzEwMCxvPTEtTWF0aC5taW4oMSxlKigxLXMpK3MpLGE9MS1NYXRoLm1pbigxLG4qKDEtcykrcyksbD0xLU1hdGgubWluKDEsciooMS1zKStzKTtyZXR1cm5bbyoyNTUsYSoyNTUsbCoyNTVdfSxjLnh5ei5yZ2I9ZnVuY3Rpb24odCl7Y29uc3QgZT10WzBdLzEwMCxuPXRbMV0vMTAwLHI9dFsyXS8xMDA7bGV0IHMsbyxhO3JldHVybiBzPWUqMy4yNDA2K24qLTEuNTM3MityKi0uNDk4NixvPWUqLS45Njg5K24qMS44NzU4K3IqLjA0MTUsYT1lKi4wNTU3K24qLS4yMDQrcioxLjA1NyxzPXM+LjAwMzEzMDg/MS4wNTUqcyoqKDEvMi40KS0uMDU1OnMqMTIuOTIsbz1vPi4wMDMxMzA4PzEuMDU1Km8qKigxLzIuNCktLjA1NTpvKjEyLjkyLGE9YT4uMDAzMTMwOD8xLjA1NSphKiooMS8yLjQpLS4wNTU6YSoxMi45MixzPU1hdGgubWluKE1hdGgubWF4KDAscyksMSksbz1NYXRoLm1pbihNYXRoLm1heCgwLG8pLDEpLGE9TWF0aC5taW4oTWF0aC5tYXgoMCxhKSwxKSxbcyoyNTUsbyoyNTUsYSoyNTVdfSxjLnh5ei5sYWI9ZnVuY3Rpb24odCl7bGV0IGU9dFswXSxuPXRbMV0scj10WzJdO2UvPTk1LjA0NyxuLz0xMDAsci89MTA4Ljg4MyxlPWU+LjAwODg1Nj9lKiooMS8zKTo3Ljc4NyplKzE2LzExNixuPW4+LjAwODg1Nj9uKiooMS8zKTo3Ljc4NypuKzE2LzExNixyPXI+LjAwODg1Nj9yKiooMS8zKTo3Ljc4NypyKzE2LzExNjtjb25zdCBzPTExNipuLTE2LG89NTAwKihlLW4pLGE9MjAwKihuLXIpO3JldHVybltzLG8sYV19LGMubGFiLnh5ej1mdW5jdGlvbih0KXtjb25zdCBlPXRbMF0sbj10WzFdLHI9dFsyXTtsZXQgcyxvLGE7bz0oZSsxNikvMTE2LHM9bi81MDArbyxhPW8tci8yMDA7Y29uc3QgbD1vKiozLGk9cyoqMyxoPWEqKjM7cmV0dXJuIG89bD4uMDA4ODU2P2w6KG8tMTYvMTE2KS83Ljc4NyxzPWk+LjAwODg1Nj9pOihzLTE2LzExNikvNy43ODcsYT1oPi4wMDg4NTY/aDooYS0xNi8xMTYpLzcuNzg3LHMqPTk1LjA0NyxvKj0xMDAsYSo9MTA4Ljg4MyxbcyxvLGFdfSxjLmxhYi5sY2g9ZnVuY3Rpb24odCl7Y29uc3QgZT10WzBdLG49dFsxXSxyPXRbMl07bGV0IHM7cz1NYXRoLmF0YW4yKHIsbikqMzYwLzIvTWF0aC5QSSxzPDAmJihzKz0zNjApO2NvbnN0IGE9TWF0aC5zcXJ0KG4qbityKnIpO3JldHVybltlLGEsc119LGMubGNoLmxhYj1mdW5jdGlvbih0KXtjb25zdCBlPXRbMF0sbj10WzFdLHM9dFsyXS8zNjAqMipNYXRoLlBJLG89bipNYXRoLmNvcyhzKSxhPW4qTWF0aC5zaW4ocyk7cmV0dXJuW2UsbyxhXX0sYy5yZ2IuYW5zaTE2PWZ1bmN0aW9uKHQsZT1udWxsKXtjb25zdFtuLHIsc109dDtsZXQgbz1lPT09bnVsbD9jLnJnYi5oc3YodClbMl06ZTtpZihvPU1hdGgucm91bmQoby81MCksbz09PTApcmV0dXJuIDMwO2xldCBhPTMwKyhNYXRoLnJvdW5kKHMvMjU1KTw8MnxNYXRoLnJvdW5kKHIvMjU1KTw8MXxNYXRoLnJvdW5kKG4vMjU1KSk7cmV0dXJuIG89PT0yJiYoYSs9NjApLGF9LGMuaHN2LmFuc2kxNj1mdW5jdGlvbih0KXtyZXR1cm4gYy5yZ2IuYW5zaTE2KGMuaHN2LnJnYih0KSx0WzJdKX0sYy5yZ2IuYW5zaTI1Nj1mdW5jdGlvbih0KXtjb25zdCBlPXRbMF0sbj10WzFdLHI9dFsyXTtyZXR1cm4gZT09PW4mJm49PT1yP2U8OD8xNjplPjI0OD8yMzE6TWF0aC5yb3VuZCgoZS04KS8yNDcqMjQpKzIzMjoxNiszNipNYXRoLnJvdW5kKGUvMjU1KjUpKzYqTWF0aC5yb3VuZChuLzI1NSo1KStNYXRoLnJvdW5kKHIvMjU1KjUpfSxjLmFuc2kxNi5yZ2I9ZnVuY3Rpb24odCl7bGV0IGU9dCUxMDtpZihlPT09MHx8ZT09PTcpcmV0dXJuIHQ+NTAmJihlKz0zLjUpLGU9ZS8xMC41KjI1NSxbZSxlLGVdO2NvbnN0IG49KH5+KHQ+NTApKzEpKi41LHI9KGUmMSkqbioyNTUscz0oZT4+MSYxKSpuKjI1NSxvPShlPj4yJjEpKm4qMjU1O3JldHVybltyLHMsb119LGMuYW5zaTI1Ni5yZ2I9ZnVuY3Rpb24odCl7aWYodD49MjMyKXtjb25zdCBvPSh0LTIzMikqMTArODtyZXR1cm5bbyxvLG9dfXQtPTE2O2xldCBlO2NvbnN0IG49TWF0aC5mbG9vcih0LzM2KS81KjI1NSxyPU1hdGguZmxvb3IoKGU9dCUzNikvNikvNSoyNTUscz1lJTYvNSoyNTU7cmV0dXJuW24scixzXX0sYy5yZ2IuaGV4PWZ1bmN0aW9uKHQpe2NvbnN0IG49KCgoTWF0aC5yb3VuZCh0WzBdKSYyNTUpPDwxNikrKChNYXRoLnJvdW5kKHRbMV0pJjI1NSk8PDgpKyhNYXRoLnJvdW5kKHRbMl0pJjI1NSkpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiIwMDAwMDAiLnN1YnN0cmluZyhuLmxlbmd0aCkrbn0sYy5oZXgucmdiPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO2lmKCFlKXJldHVyblswLDAsMF07bGV0IG49ZVswXTtlWzBdLmxlbmd0aD09PTMmJihuPW4uc3BsaXQoIiIpLm1hcChsPT5sK2wpLmpvaW4oIiIpKTtjb25zdCByPXBhcnNlSW50KG4sMTYpLHM9cj4+MTYmMjU1LG89cj4+OCYyNTUsYT1yJjI1NTtyZXR1cm5bcyxvLGFdfSxjLnJnYi5oY2c9ZnVuY3Rpb24odCl7Y29uc3QgZT10WzBdLzI1NSxuPXRbMV0vMjU1LHI9dFsyXS8yNTUscz1NYXRoLm1heChNYXRoLm1heChlLG4pLHIpLG89TWF0aC5taW4oTWF0aC5taW4oZSxuKSxyKSxhPXMtbztsZXQgbCxpO3JldHVybiBhPDE/bD1vLygxLWEpOmw9MCxhPD0wP2k9MDpzPT09ZT9pPShuLXIpL2ElNjpzPT09bj9pPTIrKHItZSkvYTppPTQrKGUtbikvYSxpLz02LGklPTEsW2kqMzYwLGEqMTAwLGwqMTAwXX0sYy5oc2wuaGNnPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFsxXS8xMDAsbj10WzJdLzEwMCxyPW48LjU/MiplKm46MiplKigxLW4pO2xldCBzPTA7cmV0dXJuIHI8MSYmKHM9KG4tLjUqcikvKDEtcikpLFt0WzBdLHIqMTAwLHMqMTAwXX0sYy5oc3YuaGNnPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFsxXS8xMDAsbj10WzJdLzEwMCxyPWUqbjtsZXQgcz0wO3JldHVybiByPDEmJihzPShuLXIpLygxLXIpKSxbdFswXSxyKjEwMCxzKjEwMF19LGMuaGNnLnJnYj1mdW5jdGlvbih0KXtjb25zdCBlPXRbMF0vMzYwLG49dFsxXS8xMDAscj10WzJdLzEwMDtpZihuPT09MClyZXR1cm5bcioyNTUscioyNTUscioyNTVdO2NvbnN0IHM9WzAsMCwwXSxvPWUlMSo2LGE9byUxLGw9MS1hO2xldCBpPTA7c3dpdGNoKE1hdGguZmxvb3Iobykpe2Nhc2UgMDpzWzBdPTEsc1sxXT1hLHNbMl09MDticmVhaztjYXNlIDE6c1swXT1sLHNbMV09MSxzWzJdPTA7YnJlYWs7Y2FzZSAyOnNbMF09MCxzWzFdPTEsc1syXT1hO2JyZWFrO2Nhc2UgMzpzWzBdPTAsc1sxXT1sLHNbMl09MTticmVhaztjYXNlIDQ6c1swXT1hLHNbMV09MCxzWzJdPTE7YnJlYWs7ZGVmYXVsdDpzWzBdPTEsc1sxXT0wLHNbMl09bH1yZXR1cm4gaT0oMS1uKSpyLFsobipzWzBdK2kpKjI1NSwobipzWzFdK2kpKjI1NSwobipzWzJdK2kpKjI1NV19LGMuaGNnLmhzdj1mdW5jdGlvbih0KXtjb25zdCBlPXRbMV0vMTAwLG49dFsyXS8xMDAscj1lK24qKDEtZSk7bGV0IHM9MDtyZXR1cm4gcj4wJiYocz1lL3IpLFt0WzBdLHMqMTAwLHIqMTAwXX0sYy5oY2cuaHNsPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFsxXS8xMDAscj10WzJdLzEwMCooMS1lKSsuNSplO2xldCBzPTA7cmV0dXJuIHI+MCYmcjwuNT9zPWUvKDIqcik6cj49LjUmJnI8MSYmKHM9ZS8oMiooMS1yKSkpLFt0WzBdLHMqMTAwLHIqMTAwXX0sYy5oY2cuaHdiPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFsxXS8xMDAsbj10WzJdLzEwMCxyPWUrbiooMS1lKTtyZXR1cm5bdFswXSwoci1lKSoxMDAsKDEtcikqMTAwXX0sYy5od2IuaGNnPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dFsxXS8xMDAscj0xLXRbMl0vMTAwLHM9ci1lO2xldCBvPTA7cmV0dXJuIHM8MSYmKG89KHItcykvKDEtcykpLFt0WzBdLHMqMTAwLG8qMTAwXX0sYy5hcHBsZS5yZ2I9ZnVuY3Rpb24odCl7cmV0dXJuW3RbMF0vNjU1MzUqMjU1LHRbMV0vNjU1MzUqMjU1LHRbMl0vNjU1MzUqMjU1XX0sYy5yZ2IuYXBwbGU9ZnVuY3Rpb24odCl7cmV0dXJuW3RbMF0vMjU1KjY1NTM1LHRbMV0vMjU1KjY1NTM1LHRbMl0vMjU1KjY1NTM1XX0sYy5ncmF5LnJnYj1mdW5jdGlvbih0KXtyZXR1cm5bdFswXS8xMDAqMjU1LHRbMF0vMTAwKjI1NSx0WzBdLzEwMCoyNTVdfSxjLmdyYXkuaHNsPWZ1bmN0aW9uKHQpe3JldHVyblswLDAsdFswXV19LGMuZ3JheS5oc3Y9Yy5ncmF5LmhzbCxjLmdyYXkuaHdiPWZ1bmN0aW9uKHQpe3JldHVyblswLDEwMCx0WzBdXX0sYy5ncmF5LmNteWs9ZnVuY3Rpb24odCl7cmV0dXJuWzAsMCwwLHRbMF1dfSxjLmdyYXkubGFiPWZ1bmN0aW9uKHQpe3JldHVyblt0WzBdLDAsMF19LGMuZ3JheS5oZXg9ZnVuY3Rpb24odCl7Y29uc3QgZT1NYXRoLnJvdW5kKHRbMF0vMTAwKjI1NSkmMjU1LHI9KChlPDwxNikrKGU8PDgpK2UpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiIwMDAwMDAiLnN1YnN0cmluZyhyLmxlbmd0aCkrcn0sYy5yZ2IuZ3JheT1mdW5jdGlvbih0KXtyZXR1cm5bKHRbMF0rdFsxXSt0WzJdKS8zLzI1NSoxMDBdfTtjb25zdCBGPUg7ZnVuY3Rpb24gWigpe2NvbnN0IHQ9e30sZT1PYmplY3Qua2V5cyhGKTtmb3IobGV0IG49ZS5sZW5ndGgscj0wO3I8bjtyKyspdFtlW3JdXT17ZGlzdGFuY2U6LTEscGFyZW50Om51bGx9O3JldHVybiB0fWZ1bmN0aW9uIHR0KHQpe2NvbnN0IGU9WigpLG49W3RdO2ZvcihlW3RdLmRpc3RhbmNlPTA7bi5sZW5ndGg7KXtjb25zdCByPW4ucG9wKCkscz1PYmplY3Qua2V5cyhGW3JdKTtmb3IobGV0IG89cy5sZW5ndGgsYT0wO2E8bzthKyspe2NvbnN0IGw9c1thXSxpPWVbbF07aS5kaXN0YW5jZT09PS0xJiYoaS5kaXN0YW5jZT1lW3JdLmRpc3RhbmNlKzEsaS5wYXJlbnQ9cixuLnVuc2hpZnQobCkpfX1yZXR1cm4gZX1mdW5jdGlvbiBldCh0LGUpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gZSh0KG4pKX19ZnVuY3Rpb24gbnQodCxlKXtjb25zdCBuPVtlW3RdLnBhcmVudCx0XTtsZXQgcj1GW2VbdF0ucGFyZW50XVt0XSxzPWVbdF0ucGFyZW50O2Zvcig7ZVtzXS5wYXJlbnQ7KW4udW5zaGlmdChlW3NdLnBhcmVudCkscj1ldChGW2Vbc10ucGFyZW50XVtzXSxyKSxzPWVbc10ucGFyZW50O3JldHVybiByLmNvbnZlcnNpb249bixyfXZhciBydD1mdW5jdGlvbih0KXtjb25zdCBlPXR0KHQpLG49e30scj1PYmplY3Qua2V5cyhlKTtmb3IobGV0IHM9ci5sZW5ndGgsbz0wO288cztvKyspe2NvbnN0IGE9cltvXTtlW2FdLnBhcmVudCE9PW51bGwmJihuW2FdPW50KGEsZSkpfXJldHVybiBufTtjb25zdCB6PUgsc3Q9cnQsdj17fSxhdD1PYmplY3Qua2V5cyh6KTtmdW5jdGlvbiBvdCh0KXtjb25zdCBlPWZ1bmN0aW9uKC4uLm4pe2NvbnN0IHI9blswXTtyZXR1cm4gcj09bnVsbD9yOihyLmxlbmd0aD4xJiYobj1yKSx0KG4pKX07cmV0dXJuImNvbnZlcnNpb24iaW4gdCYmKGUuY29udmVyc2lvbj10LmNvbnZlcnNpb24pLGV9ZnVuY3Rpb24gbHQodCl7Y29uc3QgZT1mdW5jdGlvbiguLi5uKXtjb25zdCByPW5bMF07aWYocj09bnVsbClyZXR1cm4gcjtyLmxlbmd0aD4xJiYobj1yKTtjb25zdCBzPXQobik7aWYodHlwZW9mIHM9PSJvYmplY3QiKWZvcihsZXQgbz1zLmxlbmd0aCxhPTA7YTxvO2ErKylzW2FdPU1hdGgucm91bmQoc1thXSk7cmV0dXJuIHN9O3JldHVybiJjb252ZXJzaW9uImluIHQmJihlLmNvbnZlcnNpb249dC5jb252ZXJzaW9uKSxlfWF0LmZvckVhY2godD0+e3ZbdF09e30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHZbdF0sImNoYW5uZWxzIix7dmFsdWU6elt0XS5jaGFubmVsc30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2W3RdLCJsYWJlbHMiLHt2YWx1ZTp6W3RdLmxhYmVsc30pO2NvbnN0IGU9c3QodCk7T2JqZWN0LmtleXMoZSkuZm9yRWFjaChyPT57Y29uc3Qgcz1lW3JdO3ZbdF1bcl09bHQocyksdlt0XVtyXS5yYXc9b3Qocyl9KX0pO3ZhciBpdD12O2NvbnN0IHg9USx5PWl0LFk9WyJrZXl3b3JkIiwiZ3JheSIsImhleCJdLEU9e307Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmtleXMoeSkpRVtbLi4ueVt0XS5sYWJlbHNdLnNvcnQoKS5qb2luKCIiKV09dDtjb25zdCAkPXt9O2Z1bmN0aW9uIGcodCxlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBnKSlyZXR1cm4gbmV3IGcodCxlKTtpZihlJiZlIGluIFkmJihlPW51bGwpLGUmJiEoZSBpbiB5KSl0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gbW9kZWw6ICIrZSk7bGV0IG4scjtpZih0PT1udWxsKXRoaXMubW9kZWw9InJnYiIsdGhpcy5jb2xvcj1bMCwwLDBdLHRoaXMudmFscGhhPTE7ZWxzZSBpZih0IGluc3RhbmNlb2YgZyl0aGlzLm1vZGVsPXQubW9kZWwsdGhpcy5jb2xvcj1bLi4udC5jb2xvcl0sdGhpcy52YWxwaGE9dC52YWxwaGE7ZWxzZSBpZih0eXBlb2YgdD09InN0cmluZyIpe2NvbnN0IHM9eC5nZXQodCk7aWYocz09PW51bGwpdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBzdHJpbmc6ICIrdCk7dGhpcy5tb2RlbD1zLm1vZGVsLHI9eVt0aGlzLm1vZGVsXS5jaGFubmVscyx0aGlzLmNvbG9yPXMudmFsdWUuc2xpY2UoMCxyKSx0aGlzLnZhbHBoYT10eXBlb2Ygcy52YWx1ZVtyXT09Im51bWJlciI/cy52YWx1ZVtyXToxfWVsc2UgaWYodC5sZW5ndGg+MCl7dGhpcy5tb2RlbD1lfHwicmdiIixyPXlbdGhpcy5tb2RlbF0uY2hhbm5lbHM7Y29uc3Qgcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LDAscik7dGhpcy5jb2xvcj1DKHMsciksdGhpcy52YWxwaGE9dHlwZW9mIHRbcl09PSJudW1iZXIiP3Rbcl06MX1lbHNlIGlmKHR5cGVvZiB0PT0ibnVtYmVyIil0aGlzLm1vZGVsPSJyZ2IiLHRoaXMuY29sb3I9W3Q+PjE2JjI1NSx0Pj44JjI1NSx0JjI1NV0sdGhpcy52YWxwaGE9MTtlbHNle3RoaXMudmFscGhhPTE7Y29uc3Qgcz1PYmplY3Qua2V5cyh0KTsiYWxwaGEiaW4gdCYmKHMuc3BsaWNlKHMuaW5kZXhPZigiYWxwaGEiKSwxKSx0aGlzLnZhbHBoYT10eXBlb2YgdC5hbHBoYT09Im51bWJlciI/dC5hbHBoYTowKTtjb25zdCBvPXMuc29ydCgpLmpvaW4oIiIpO2lmKCEobyBpbiBFKSl0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIG9iamVjdDogIitKU09OLnN0cmluZ2lmeSh0KSk7dGhpcy5tb2RlbD1FW29dO2NvbnN0e2xhYmVsczphfT15W3RoaXMubW9kZWxdLGw9W107Zm9yKG49MDtuPGEubGVuZ3RoO24rKylsLnB1c2godFthW25dXSk7dGhpcy5jb2xvcj1DKGwpfWlmKCRbdGhpcy5tb2RlbF0pZm9yKHI9eVt0aGlzLm1vZGVsXS5jaGFubmVscyxuPTA7bjxyO24rKyl7Y29uc3Qgcz0kW3RoaXMubW9kZWxdW25dO3MmJih0aGlzLmNvbG9yW25dPXModGhpcy5jb2xvcltuXSkpfXRoaXMudmFscGhhPU1hdGgubWF4KDAsTWF0aC5taW4oMSx0aGlzLnZhbHBoYSkpLE9iamVjdC5mcmVlemUmJk9iamVjdC5mcmVlemUodGhpcyl9Zy5wcm90b3R5cGU9e3RvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc3RyaW5nKCl9LHRvSlNPTigpe3JldHVybiB0aGlzW3RoaXMubW9kZWxdKCl9LHN0cmluZyh0KXtsZXQgZT10aGlzLm1vZGVsIGluIHgudG8/dGhpczp0aGlzLnJnYigpO2U9ZS5yb3VuZCh0eXBlb2YgdD09Im51bWJlciI/dDoxKTtjb25zdCBuPWUudmFscGhhPT09MT9lLmNvbG9yOlsuLi5lLmNvbG9yLHRoaXMudmFscGhhXTtyZXR1cm4geC50b1tlLm1vZGVsXShuKX0scGVyY2VudFN0cmluZyh0KXtjb25zdCBlPXRoaXMucmdiKCkucm91bmQodHlwZW9mIHQ9PSJudW1iZXIiP3Q6MSksbj1lLnZhbHBoYT09PTE/ZS5jb2xvcjpbLi4uZS5jb2xvcix0aGlzLnZhbHBoYV07cmV0dXJuIHgudG8ucmdiLnBlcmNlbnQobil9LGFycmF5KCl7cmV0dXJuIHRoaXMudmFscGhhPT09MT9bLi4udGhpcy5jb2xvcl06Wy4uLnRoaXMuY29sb3IsdGhpcy52YWxwaGFdfSxvYmplY3QoKXtjb25zdCB0PXt9LHtjaGFubmVsczplfT15W3RoaXMubW9kZWxdLHtsYWJlbHM6bn09eVt0aGlzLm1vZGVsXTtmb3IobGV0IHI9MDtyPGU7cisrKXRbbltyXV09dGhpcy5jb2xvcltyXTtyZXR1cm4gdGhpcy52YWxwaGEhPT0xJiYodC5hbHBoYT10aGlzLnZhbHBoYSksdH0sdW5pdEFycmF5KCl7Y29uc3QgdD10aGlzLnJnYigpLmNvbG9yO3JldHVybiB0WzBdLz0yNTUsdFsxXS89MjU1LHRbMl0vPTI1NSx0aGlzLnZhbHBoYSE9PTEmJnQucHVzaCh0aGlzLnZhbHBoYSksdH0sdW5pdE9iamVjdCgpe2NvbnN0IHQ9dGhpcy5yZ2IoKS5vYmplY3QoKTtyZXR1cm4gdC5yLz0yNTUsdC5nLz0yNTUsdC5iLz0yNTUsdGhpcy52YWxwaGEhPT0xJiYodC5hbHBoYT10aGlzLnZhbHBoYSksdH0scm91bmQodCl7cmV0dXJuIHQ9TWF0aC5tYXgodHx8MCwwKSxuZXcgZyhbLi4udGhpcy5jb2xvci5tYXAoaHQodCkpLHRoaXMudmFscGhhXSx0aGlzLm1vZGVsKX0sYWxwaGEodCl7cmV0dXJuIHQhPT12b2lkIDA/bmV3IGcoWy4uLnRoaXMuY29sb3IsTWF0aC5tYXgoMCxNYXRoLm1pbigxLHQpKV0sdGhpcy5tb2RlbCk6dGhpcy52YWxwaGF9LHJlZDp1KCJyZ2IiLDAsZigyNTUpKSxncmVlbjp1KCJyZ2IiLDEsZigyNTUpKSxibHVlOnUoInJnYiIsMixmKDI1NSkpLGh1ZTp1KFsiaHNsIiwiaHN2IiwiaHNsIiwiaHdiIiwiaGNnIl0sMCx0PT4odCUzNjArMzYwKSUzNjApLHNhdHVyYXRpb25sOnUoImhzbCIsMSxmKDEwMCkpLGxpZ2h0bmVzczp1KCJoc2wiLDIsZigxMDApKSxzYXR1cmF0aW9udjp1KCJoc3YiLDEsZigxMDApKSx2YWx1ZTp1KCJoc3YiLDIsZigxMDApKSxjaHJvbWE6dSgiaGNnIiwxLGYoMTAwKSksZ3JheTp1KCJoY2ciLDIsZigxMDApKSx3aGl0ZTp1KCJod2IiLDEsZigxMDApKSx3YmxhY2s6dSgiaHdiIiwyLGYoMTAwKSksY3lhbjp1KCJjbXlrIiwwLGYoMTAwKSksbWFnZW50YTp1KCJjbXlrIiwxLGYoMTAwKSkseWVsbG93OnUoImNteWsiLDIsZigxMDApKSxibGFjazp1KCJjbXlrIiwzLGYoMTAwKSkseDp1KCJ4eXoiLDAsZig5NS4wNDcpKSx5OnUoInh5eiIsMSxmKDEwMCkpLHo6dSgieHl6IiwyLGYoMTA4LjgzMykpLGw6dSgibGFiIiwwLGYoMTAwKSksYTp1KCJsYWIiLDEpLGI6dSgibGFiIiwyKSxrZXl3b3JkKHQpe3JldHVybiB0IT09dm9pZCAwP25ldyBnKHQpOnlbdGhpcy5tb2RlbF0ua2V5d29yZCh0aGlzLmNvbG9yKX0saGV4KHQpe3JldHVybiB0IT09dm9pZCAwP25ldyBnKHQpOngudG8uaGV4KHRoaXMucmdiKCkucm91bmQoKS5jb2xvcil9LGhleGEodCl7aWYodCE9PXZvaWQgMClyZXR1cm4gbmV3IGcodCk7Y29uc3QgZT10aGlzLnJnYigpLnJvdW5kKCkuY29sb3I7bGV0IG49TWF0aC5yb3VuZCh0aGlzLnZhbHBoYSoyNTUpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiBuLmxlbmd0aD09PTEmJihuPSIwIituKSx4LnRvLmhleChlKStufSxyZ2JOdW1iZXIoKXtjb25zdCB0PXRoaXMucmdiKCkuY29sb3I7cmV0dXJuKHRbMF0mMjU1KTw8MTZ8KHRbMV0mMjU1KTw8OHx0WzJdJjI1NX0sbHVtaW5vc2l0eSgpe2NvbnN0IHQ9dGhpcy5yZ2IoKS5jb2xvcixlPVtdO2Zvcihjb25zdFtuLHJdb2YgdC5lbnRyaWVzKCkpe2NvbnN0IHM9ci8yNTU7ZVtuXT1zPD0uMDQwNDU/cy8xMi45MjooKHMrLjA1NSkvMS4wNTUpKioyLjR9cmV0dXJuIC4yMTI2KmVbMF0rLjcxNTIqZVsxXSsuMDcyMiplWzJdfSxjb250cmFzdCh0KXtjb25zdCBlPXRoaXMubHVtaW5vc2l0eSgpLG49dC5sdW1pbm9zaXR5KCk7cmV0dXJuIGU+bj8oZSsuMDUpLyhuKy4wNSk6KG4rLjA1KS8oZSsuMDUpfSxsZXZlbCh0KXtjb25zdCBlPXRoaXMuY29udHJhc3QodCk7cmV0dXJuIGU+PTc/IkFBQSI6ZT49NC41PyJBQSI6IiJ9LGlzRGFyaygpe2NvbnN0IHQ9dGhpcy5yZ2IoKS5jb2xvcjtyZXR1cm4odFswXSoyMTI2K3RbMV0qNzE1Mit0WzJdKjcyMikvMWU0PDEyOH0saXNMaWdodCgpe3JldHVybiF0aGlzLmlzRGFyaygpfSxuZWdhdGUoKXtjb25zdCB0PXRoaXMucmdiKCk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl0LmNvbG9yW2VdPTI1NS10LmNvbG9yW2VdO3JldHVybiB0fSxsaWdodGVuKHQpe2NvbnN0IGU9dGhpcy5oc2woKTtyZXR1cm4gZS5jb2xvclsyXSs9ZS5jb2xvclsyXSp0LGV9LGRhcmtlbih0KXtjb25zdCBlPXRoaXMuaHNsKCk7cmV0dXJuIGUuY29sb3JbMl0tPWUuY29sb3JbMl0qdCxlfSxzYXR1cmF0ZSh0KXtjb25zdCBlPXRoaXMuaHNsKCk7cmV0dXJuIGUuY29sb3JbMV0rPWUuY29sb3JbMV0qdCxlfSxkZXNhdHVyYXRlKHQpe2NvbnN0IGU9dGhpcy5oc2woKTtyZXR1cm4gZS5jb2xvclsxXS09ZS5jb2xvclsxXSp0LGV9LHdoaXRlbih0KXtjb25zdCBlPXRoaXMuaHdiKCk7cmV0dXJuIGUuY29sb3JbMV0rPWUuY29sb3JbMV0qdCxlfSxibGFja2VuKHQpe2NvbnN0IGU9dGhpcy5od2IoKTtyZXR1cm4gZS5jb2xvclsyXSs9ZS5jb2xvclsyXSp0LGV9LGdyYXlzY2FsZSgpe2NvbnN0IHQ9dGhpcy5yZ2IoKS5jb2xvcixlPXRbMF0qLjMrdFsxXSouNTkrdFsyXSouMTE7cmV0dXJuIGcucmdiKGUsZSxlKX0sZmFkZSh0KXtyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYS10aGlzLnZhbHBoYSp0KX0sb3BhcXVlcih0KXtyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSt0aGlzLnZhbHBoYSp0KX0scm90YXRlKHQpe2NvbnN0IGU9dGhpcy5oc2woKTtsZXQgbj1lLmNvbG9yWzBdO3JldHVybiBuPShuK3QpJTM2MCxuPW48MD8zNjArbjpuLGUuY29sb3JbMF09bixlfSxtaXgodCxlKXtpZighdHx8IXQucmdiKXRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gIm1peCIgd2FzIG5vdCBhIENvbG9yIGluc3RhbmNlLCBidXQgcmF0aGVyIGFuIGluc3RhbmNlIG9mICcrdHlwZW9mIHQpO2NvbnN0IG49dC5yZ2IoKSxyPXRoaXMucmdiKCkscz1lPT09dm9pZCAwPy41OmUsbz0yKnMtMSxhPW4uYWxwaGEoKS1yLmFscGhhKCksbD0oKG8qYT09PS0xP286KG8rYSkvKDErbyphKSkrMSkvMixpPTEtbDtyZXR1cm4gZy5yZ2IobCpuLnJlZCgpK2kqci5yZWQoKSxsKm4uZ3JlZW4oKStpKnIuZ3JlZW4oKSxsKm4uYmx1ZSgpK2kqci5ibHVlKCksbi5hbHBoYSgpKnMrci5hbHBoYSgpKigxLXMpKX19O2Zvcihjb25zdCB0IG9mIE9iamVjdC5rZXlzKHkpKXtpZihZLmluY2x1ZGVzKHQpKWNvbnRpbnVlO2NvbnN0e2NoYW5uZWxzOmV9PXlbdF07Zy5wcm90b3R5cGVbdF09ZnVuY3Rpb24oLi4ubil7cmV0dXJuIHRoaXMubW9kZWw9PT10P25ldyBnKHRoaXMpOm4ubGVuZ3RoPjA/bmV3IGcobix0KTpuZXcgZyhbLi4udXQoeVt0aGlzLm1vZGVsXVt0XS5yYXcodGhpcy5jb2xvcikpLHRoaXMudmFscGhhXSx0KX0sZ1t0XT1mdW5jdGlvbiguLi5uKXtsZXQgcj1uWzBdO3JldHVybiB0eXBlb2Ygcj09Im51bWJlciImJihyPUMobixlKSksbmV3IGcocix0KX19ZnVuY3Rpb24gY3QodCxlKXtyZXR1cm4gTnVtYmVyKHQudG9GaXhlZChlKSl9ZnVuY3Rpb24gaHQodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBjdChlLHQpfX1mdW5jdGlvbiB1KHQsZSxuKXt0PUFycmF5LmlzQXJyYXkodCk/dDpbdF07Zm9yKGNvbnN0IHIgb2YgdCkoJFtyXXx8KCRbcl09W10pKVtlXT1uO3JldHVybiB0PXRbMF0sZnVuY3Rpb24ocil7bGV0IHM7cmV0dXJuIHIhPT12b2lkIDA/KG4mJihyPW4ocikpLHM9dGhpc1t0XSgpLHMuY29sb3JbZV09cixzKToocz10aGlzW3RdKCkuY29sb3JbZV0sbiYmKHM9bihzKSkscyl9fWZ1bmN0aW9uIGYodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLm1heCgwLE1hdGgubWluKHQsZSkpfX1mdW5jdGlvbiB1dCh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT90Olt0XX1mdW5jdGlvbiBDKHQsZSl7Zm9yKGxldCBuPTA7bjxlO24rKyl0eXBlb2YgdFtuXSE9Im51bWJlciImJih0W25dPTApO3JldHVybiB0fXZhciBmdD1nLE09aihmdCk7TSgiI2NjY2NjYyIpLE0oIiMwMGZmMDAiKSxNKCIjZmZmZjAwIiksTSgiIzAwODg4OCIpLE0oIiNmZjAwMDAiKSxNKCIjZjAwMDAwIik7Y2xhc3MgZ3R7Y29uc3RydWN0b3IoZSxuLHIscyxvKXt0aGlzLnhTdGFydE1tPWUsdGhpcy55U3RhcnRNbT1uLHRoaXMueERlbHRhTW09cix0aGlzLnlEZWx0YU1tPXMsdGhpcy5jdXRBcmVhTW1TcT1vfXRvU3RyaW5nKCl7cmV0dXJuYCR7dGhpcy54RGVsdGFNbX0sJHt0aGlzLnlEZWx0YU1tfToke3RoaXMuY3V0QXJlYU1tU3F9YH10b0NvbnN0cnVjdG9yU3RyaW5nKCl7cmV0dXJuYG5ldyBNb3ZlKCR7dGhpcy54U3RhcnRNbX0sICR7dGhpcy55U3RhcnRNbX0sICR7dGhpcy54RGVsdGFNbX0sICR7dGhpcy55RGVsdGFNbX0sICR7dGhpcy5jdXRBcmVhTW1TcX0pYH1pc0VtcHR5KCl7cmV0dXJuIXRoaXMueERlbHRhTW0mJiF0aGlzLnlEZWx0YU1tfWlzQmFzaWMoKXtyZXR1cm4gTWF0aC5hYnModGhpcy54RGVsdGFNbSk8PS4wMSYmTWF0aC5hYnModGhpcy55RGVsdGFNbSk8PS4wMX10b0xhdGhlQ29kZSgpe2lmKCF0aGlzLnhEZWx0YU1tKXJldHVybiIiO2NvbnN0IGU9bj0+TWF0aC5hYnMobikudG9GaXhlZCgzKTtyZXR1cm4gdGhpcy55RGVsdGFNbT9gTCR7ZSh0aGlzLnhEZWx0YU1tKX0gUlMke2UodGhpcy55U3RhcnRNbSl9IFJFJHtlKHRoaXMueVN0YXJ0TW0rdGhpcy55RGVsdGFNbSl9YDpgTCR7ZSh0aGlzLnhEZWx0YU1tKX0gUiR7ZSh0aGlzLnlTdGFydE1tKX1gfX1jbGFzcyB3e2NvbnN0cnVjdG9yKGUsbixyLHMsbyxhKXt0aGlzLnhTdGFydD1lLHRoaXMueVN0YXJ0PW4sdGhpcy54RGVsdGE9cix0aGlzLnlEZWx0YT1zLHRoaXMuY3V0QXJlYT1vLHRoaXMuY3V0UGl4ZWxzPWF9c3RhdGljIHdpdGhvdXRDdXQoZSxuLHIscyl7cmV0dXJuIG5ldyB3KGUsbixyLHMsMCxbXSl9dG9TdHJpbmcoKXtyZXR1cm5gJHt0aGlzLnhEZWx0YX0sJHt0aGlzLnlEZWx0YX06JHt0aGlzLmN1dEFyZWF9YH10b0NvbnN0cnVjdG9yU3RyaW5nKCl7cmV0dXJuYG5ldyBQaXhlbE1vdmUoJHt0aGlzLnhTdGFydH0sICR7dGhpcy55U3RhcnR9LCAke3RoaXMueERlbHRhfSwgJHt0aGlzLnlEZWx0YX0sICR7dGhpcy5jdXRBcmVhfSwgW10pYH10b01vdmUoZSl7cmV0dXJuIG5ldyBndCgtdGhpcy54U3RhcnQvZSwtdGhpcy55U3RhcnQvZSwtdGhpcy54RGVsdGEvZSwtdGhpcy55RGVsdGEvZSx0aGlzLmN1dEFyZWEvZS9lKX1pc0VtcHR5KCl7cmV0dXJuIXRoaXMueERlbHRhJiYhdGhpcy55RGVsdGF9aXNCYXNpYygpe3JldHVybih0aGlzLnhEZWx0YT09PTF8fHRoaXMueERlbHRhPT09MHx8dGhpcy54RGVsdGE9PT0tMSkmJih0aGlzLnlEZWx0YT09PTF8fHRoaXMueURlbHRhPT09MHx8dGhpcy55RGVsdGE9PT0tMSl9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLnhEZWx0YSp0aGlzLnhEZWx0YSt0aGlzLnlEZWx0YSp0aGlzLnlEZWx0YSl9aXNIb3Jpem9udGFsT3JWZXJ0aWNhbCgpe3JldHVybiB0aGlzLnhEZWx0YSp0aGlzLnlEZWx0YT09PTAmJiF0aGlzLmlzRW1wdHkoKX1nZXRBbmdsZURlZ3JlZXMoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO2xldCBlPU1hdGguYXRhbjIodGhpcy55RGVsdGEsdGhpcy54RGVsdGEpKjE4MC9NYXRoLlBJO3JldHVybiBlPDAmJihlKz0zNjApLGV9Z2V0QW5nbGVUb0RlZ3JlZXMoZSl7bGV0IG49TWF0aC5hYnModGhpcy5nZXRBbmdsZURlZ3JlZXMoKS1lLmdldEFuZ2xlRGVncmVlcygpKTtyZXR1cm4gMzYwLW48bj8zNjAtbjpufW1lcmdlKGUpe2lmKHRoaXMueFN0YXJ0K3RoaXMueERlbHRhIT09ZS54U3RhcnR8fHRoaXMueVN0YXJ0K3RoaXMueURlbHRhIT09ZS55U3RhcnQpdGhyb3cgbmV3IEVycm9yKGBtZXJnZSBlcnJvcjogJHt0aGlzfSArICR7ZX1gKTtyZXR1cm4gbmV3IHcodGhpcy54U3RhcnQsdGhpcy55U3RhcnQsdGhpcy54RGVsdGErZS54RGVsdGEsdGhpcy55RGVsdGErZS55RGVsdGEsdGhpcy5jdXRBcmVhK2UuY3V0QXJlYSx0aGlzLmN1dFBpeGVscy5jb25jYXQoZS5jdXRQaXhlbHMpKX1nZXRDdXQoKXtpZighdGhpcy5jdXRBcmVhKXJldHVybnt3aWR0aDowLGhlaWdodDowfTtsZXQgZT0xLzAsbj0tMS8wLHI9MS8wLHM9LTEvMDtmb3IobGV0IG8gb2YgdGhpcy5jdXRQaXhlbHMpby54PGUmJihlPW8ueCksby54Pm4mJihuPW8ueCksby55PHImJihyPW8ueSksby55PnMmJihzPW8ueSk7cmV0dXJue3dpZHRoOm4tZSsxLGhlaWdodDpzLXIrMX19fWNvbnN0IGR0PS4wNSxidD0uOTtmdW5jdGlvbiB5dCh0LGUsbil7Y29uc3Qgcz10Lm1lcmdlKGUpLmdldEFuZ2xlVG9EZWdyZWVzKHQpO3JldHVybiBzPT09MTgwPyExOk1hdGguc2luKHMvMTgwKk1hdGguUEkpKnQubGVuZ3RoKCk8PW59ZnVuY3Rpb24gSSh0LGUpe2NvbnN0IG49W107bGV0IHI9MDtmb3IoO3I8dC5sZW5ndGg7KXtsZXQgcz10W3JdO2lmKHIrMTx0Lmxlbmd0aCYmeXQodFtyXSx0W3IrMV0sZSkpe24ucHVzaCh0W3JdLm1lcmdlKHRbcisxXSkpLHIrPTI7Y29udGludWV9bi5wdXNoKHMpLHIrK31yZXR1cm4gbi5sZW5ndGg8dC5sZW5ndGg/SShuLGUpOm59ZnVuY3Rpb24gSyh0LGUpe2NvbnN0IG49W107bGV0IHI9MDtmb3IoO3I8dC5sZW5ndGg7KXtsZXQgcz10W3JdO2lmKHMuaXNFbXB0eSgpKXtyKys7Y29udGludWV9aWYoIXMuY3V0QXJlYSl7Y29uc3QgYT1wdCh0LHIpO2lmKGEubGVuZ3RoPjEmJmEubW92ZXMubGVuZ3RoPGEubGVuZ3RoKXtuLnB1c2goLi4uYS5tb3Zlcykscis9YS5sZW5ndGg7Y29udGludWV9fWNvbnN0IG89d3QodCxyKTtpZihvLmxlbmd0aD4xKXtuLnB1c2goby5tb3ZlKSxyKz1vLmxlbmd0aDtjb250aW51ZX1pZihyKzE8dC5sZW5ndGgmJnRbcl0uaXNCYXNpYygpJiZ0W3IrMV0uaXNIb3Jpem9udGFsT3JWZXJ0aWNhbCgpKXtsZXQgYT0xO2Zvcig7cisxK2EqMjx0Lmxlbmd0aDspe2NvbnN0IGw9cithKjI7aWYodFtsXS5pc0Jhc2ljKCkmJnRbbCsxXS5pc0hvcml6b250YWxPclZlcnRpY2FsKCkmJnRbbC0yXS5tZXJnZSh0W2wtMV0pLmdldEFuZ2xlVG9EZWdyZWVzKHRbbF0ubWVyZ2UodFtsKzFdKSk8ZHQpYSsrO2Vsc2UgYnJlYWt9aWYoYT4xKXtuLnB1c2godnQodCxyLDIqYSkpLHIrPTIqYTtjb250aW51ZX19bi5wdXNoKHMpLHIrK31yZXR1cm4gbi5sZW5ndGg8dC5sZW5ndGg/SyhuKTpJKG4sYnQpfWZ1bmN0aW9uIHB0KHQsZSl7aWYodFtlXS5jdXRBcmVhKXRocm93IG5ldyBFcnJvcigiZXhwZWN0aW5nIGEgdHJhdmVsIG1vdmUiKTtsZXQgbj1lO2Zvcig7bjx0Lmxlbmd0aC0xJiYhdFtuKzFdLmN1dEFyZWE7KW4rKztyZXR1cm57bW92ZXM6bXQodC5zbGljZShlLG4rMSkpLGxlbmd0aDpuLWUrMX19ZnVuY3Rpb24gbXQodCl7Y29uc3QgZT1bXSxuPXRbMF0scj1NYXRoLm1heC5hcHBseShudWxsLHQubWFwKGk9PmkueVN0YXJ0K2kueURlbHRhKSkscz10LmF0KC0xKSxvPXMueFN0YXJ0K3MueERlbHRhLGE9cy55U3RhcnQrcy55RGVsdGE7bGV0IGw9bi55U3RhcnQ7cmV0dXJuIG8hPW4ueFN0YXJ0JiYobi55U3RhcnQhPT1yJiYoZS5wdXNoKHcud2l0aG91dEN1dChuLnhTdGFydCxuLnlTdGFydCwwLHItbi55U3RhcnQpKSxsPXIpLGUucHVzaCh3LndpdGhvdXRDdXQobi54U3RhcnQscixvLW4ueFN0YXJ0LDApKSksYSE9bCYmZS5wdXNoKHcud2l0aG91dEN1dChvLGwsMCxhLWwpKSxlfWZ1bmN0aW9uIHd0KHQsZSl7bGV0IG49dFtlXSxyPTE7Zm9yKDtlPHQubGVuZ3RoLTE7KXtjb25zdCBzPXRbZSsxXTtpZighcy5nZXRBbmdsZVRvRGVncmVlcyhuKSluPW4ubWVyZ2UocykscisrLGUrKztlbHNlIGJyZWFrfXJldHVybnttb3ZlOm4sbGVuZ3RoOnJ9fWZ1bmN0aW9uIHZ0KHQsZSxuKXtsZXQgcj10W2VdO2ZvcihsZXQgcz0xO3M8bjtzKyspcj1yLm1lcmdlKHRbZStzXSk7cmV0dXJuIHJ9c2VsZi5vbm1lc3NhZ2U9YXN5bmMgdD0+e2NvbnN0IGU9dC5kYXRhO2xldCBuPW5ldyBVaW50OEFycmF5KGUuaW1hZ2UpO2NvbnN0IHI9bmV3IEJsb2IoW25dLHt0eXBlOiJpbWFnZS8qIn0pO2xldCBzPWF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKHIpO2NvbnN0IG89a3QoTXQocykpO2xldCBhPXh0KG8uZ2V0Q29udGV4dCgiMmQiKSk7YT1JKGEsZS5zbW9vdGhFcHNpbG9ufHwyKSxwb3N0TWVzc2FnZSh7bW92ZXM6SyhhKX0pfTtmdW5jdGlvbiB4dCh0KXtjb25zdCBlPXQuZ2V0SW1hZ2VEYXRhKDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpLHt3aWR0aDpuLGhlaWdodDpyLGRhdGE6c309ZSxvPVtdO2xldCBhPTA7Zm9yKGxldCBsPW4tMTtsPj0wO2wtLSl7bGV0IGk9ci0xO2Zvcig7aT4wO2ktLSl7Y29uc3QgaD0oaSpuK2wpKjQsZD1zW2hdLHA9c1toKzFdLHE9c1toKzJdLER0PXNbaCszXTtpZihkPD0xMjgmJnA8PTEyOCYmcTw9MTI4JiZEdD49MTI4KWJyZWFrfW8ucHVzaChuZXcgdyhsLGEsLTEsaS1hLDEsW10pKSxhPWl9cmV0dXJuIG99ZnVuY3Rpb24gTXQodCl7Y29uc3QgZT1uZXcgT2Zmc2NyZWVuQ2FudmFzKHQuaGVpZ2h0LHQud2lkdGgpLG49ZS5nZXRDb250ZXh0KCIyZCIpO3JldHVybiBuLnRyYW5zbGF0ZShlLndpZHRoLzIsZS5oZWlnaHQvMiksbi5yb3RhdGUoOTAqTWF0aC5QSS8xODApLG4uZHJhd0ltYWdlKHQsLXQud2lkdGgvMiwtdC5oZWlnaHQvMiksZX1mdW5jdGlvbiBrdCh0KXtjb25zdCBlPW5ldyBPZmZzY3JlZW5DYW52YXModC53aWR0aCx0LmhlaWdodC8yKTtyZXR1cm4gZS5nZXRDb250ZXh0KCIyZCIpLmRyYXdJbWFnZSh0LDAsdC5oZWlnaHQvMix0LndpZHRoLHQuaGVpZ2h0LzIsMCwwLHQud2lkdGgsdC5oZWlnaHQvMiksZX19KSgpOwo=",ur=typeof window<"u"&&window.Blob&&new Blob([atob(qr)],{type:"text/javascript;charset=utf-8"});function Fm(){let s;try{if(s=ur&&(window.URL||window.webkitURL).createObjectURL(ur),!s)throw"";return new Worker(s)}catch{return new Worker("data:application/javascript;base64,"+qr)}finally{s&&(window.URL||window.webkitURL).revokeObjectURL(s)}}const $r="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGVzKHIpe3JldHVybiByJiZyLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLCJkZWZhdWx0Iik/ci5kZWZhdWx0OnJ9dmFyIEZlPXtleHBvcnRzOnt9fSxTZT17YWxpY2VibHVlOlsyNDAsMjQ4LDI1NV0sYW50aXF1ZXdoaXRlOlsyNTAsMjM1LDIxNV0sYXF1YTpbMCwyNTUsMjU1XSxhcXVhbWFyaW5lOlsxMjcsMjU1LDIxMl0sYXp1cmU6WzI0MCwyNTUsMjU1XSxiZWlnZTpbMjQ1LDI0NSwyMjBdLGJpc3F1ZTpbMjU1LDIyOCwxOTZdLGJsYWNrOlswLDAsMF0sYmxhbmNoZWRhbG1vbmQ6WzI1NSwyMzUsMjA1XSxibHVlOlswLDAsMjU1XSxibHVldmlvbGV0OlsxMzgsNDMsMjI2XSxicm93bjpbMTY1LDQyLDQyXSxidXJseXdvb2Q6WzIyMiwxODQsMTM1XSxjYWRldGJsdWU6Wzk1LDE1OCwxNjBdLGNoYXJ0cmV1c2U6WzEyNywyNTUsMF0sY2hvY29sYXRlOlsyMTAsMTA1LDMwXSxjb3JhbDpbMjU1LDEyNyw4MF0sY29ybmZsb3dlcmJsdWU6WzEwMCwxNDksMjM3XSxjb3Juc2lsazpbMjU1LDI0OCwyMjBdLGNyaW1zb246WzIyMCwyMCw2MF0sY3lhbjpbMCwyNTUsMjU1XSxkYXJrYmx1ZTpbMCwwLDEzOV0sZGFya2N5YW46WzAsMTM5LDEzOV0sZGFya2dvbGRlbnJvZDpbMTg0LDEzNCwxMV0sZGFya2dyYXk6WzE2OSwxNjksMTY5XSxkYXJrZ3JlZW46WzAsMTAwLDBdLGRhcmtncmV5OlsxNjksMTY5LDE2OV0sZGFya2toYWtpOlsxODksMTgzLDEwN10sZGFya21hZ2VudGE6WzEzOSwwLDEzOV0sZGFya29saXZlZ3JlZW46Wzg1LDEwNyw0N10sZGFya29yYW5nZTpbMjU1LDE0MCwwXSxkYXJrb3JjaGlkOlsxNTMsNTAsMjA0XSxkYXJrcmVkOlsxMzksMCwwXSxkYXJrc2FsbW9uOlsyMzMsMTUwLDEyMl0sZGFya3NlYWdyZWVuOlsxNDMsMTg4LDE0M10sZGFya3NsYXRlYmx1ZTpbNzIsNjEsMTM5XSxkYXJrc2xhdGVncmF5Ols0Nyw3OSw3OV0sZGFya3NsYXRlZ3JleTpbNDcsNzksNzldLGRhcmt0dXJxdW9pc2U6WzAsMjA2LDIwOV0sZGFya3Zpb2xldDpbMTQ4LDAsMjExXSxkZWVwcGluazpbMjU1LDIwLDE0N10sZGVlcHNreWJsdWU6WzAsMTkxLDI1NV0sZGltZ3JheTpbMTA1LDEwNSwxMDVdLGRpbWdyZXk6WzEwNSwxMDUsMTA1XSxkb2RnZXJibHVlOlszMCwxNDQsMjU1XSxmaXJlYnJpY2s6WzE3OCwzNCwzNF0sZmxvcmFsd2hpdGU6WzI1NSwyNTAsMjQwXSxmb3Jlc3RncmVlbjpbMzQsMTM5LDM0XSxmdWNoc2lhOlsyNTUsMCwyNTVdLGdhaW5zYm9ybzpbMjIwLDIyMCwyMjBdLGdob3N0d2hpdGU6WzI0OCwyNDgsMjU1XSxnb2xkOlsyNTUsMjE1LDBdLGdvbGRlbnJvZDpbMjE4LDE2NSwzMl0sZ3JheTpbMTI4LDEyOCwxMjhdLGdyZWVuOlswLDEyOCwwXSxncmVlbnllbGxvdzpbMTczLDI1NSw0N10sZ3JleTpbMTI4LDEyOCwxMjhdLGhvbmV5ZGV3OlsyNDAsMjU1LDI0MF0saG90cGluazpbMjU1LDEwNSwxODBdLGluZGlhbnJlZDpbMjA1LDkyLDkyXSxpbmRpZ286Wzc1LDAsMTMwXSxpdm9yeTpbMjU1LDI1NSwyNDBdLGtoYWtpOlsyNDAsMjMwLDE0MF0sbGF2ZW5kZXI6WzIzMCwyMzAsMjUwXSxsYXZlbmRlcmJsdXNoOlsyNTUsMjQwLDI0NV0sbGF3bmdyZWVuOlsxMjQsMjUyLDBdLGxlbW9uY2hpZmZvbjpbMjU1LDI1MCwyMDVdLGxpZ2h0Ymx1ZTpbMTczLDIxNiwyMzBdLGxpZ2h0Y29yYWw6WzI0MCwxMjgsMTI4XSxsaWdodGN5YW46WzIyNCwyNTUsMjU1XSxsaWdodGdvbGRlbnJvZHllbGxvdzpbMjUwLDI1MCwyMTBdLGxpZ2h0Z3JheTpbMjExLDIxMSwyMTFdLGxpZ2h0Z3JlZW46WzE0NCwyMzgsMTQ0XSxsaWdodGdyZXk6WzIxMSwyMTEsMjExXSxsaWdodHBpbms6WzI1NSwxODIsMTkzXSxsaWdodHNhbG1vbjpbMjU1LDE2MCwxMjJdLGxpZ2h0c2VhZ3JlZW46WzMyLDE3OCwxNzBdLGxpZ2h0c2t5Ymx1ZTpbMTM1LDIwNiwyNTBdLGxpZ2h0c2xhdGVncmF5OlsxMTksMTM2LDE1M10sbGlnaHRzbGF0ZWdyZXk6WzExOSwxMzYsMTUzXSxsaWdodHN0ZWVsYmx1ZTpbMTc2LDE5NiwyMjJdLGxpZ2h0eWVsbG93OlsyNTUsMjU1LDIyNF0sbGltZTpbMCwyNTUsMF0sbGltZWdyZWVuOls1MCwyMDUsNTBdLGxpbmVuOlsyNTAsMjQwLDIzMF0sbWFnZW50YTpbMjU1LDAsMjU1XSxtYXJvb246WzEyOCwwLDBdLG1lZGl1bWFxdWFtYXJpbmU6WzEwMiwyMDUsMTcwXSxtZWRpdW1ibHVlOlswLDAsMjA1XSxtZWRpdW1vcmNoaWQ6WzE4Niw4NSwyMTFdLG1lZGl1bXB1cnBsZTpbMTQ3LDExMiwyMTldLG1lZGl1bXNlYWdyZWVuOls2MCwxNzksMTEzXSxtZWRpdW1zbGF0ZWJsdWU6WzEyMywxMDQsMjM4XSxtZWRpdW1zcHJpbmdncmVlbjpbMCwyNTAsMTU0XSxtZWRpdW10dXJxdW9pc2U6WzcyLDIwOSwyMDRdLG1lZGl1bXZpb2xldHJlZDpbMTk5LDIxLDEzM10sbWlkbmlnaHRibHVlOlsyNSwyNSwxMTJdLG1pbnRjcmVhbTpbMjQ1LDI1NSwyNTBdLG1pc3R5cm9zZTpbMjU1LDIyOCwyMjVdLG1vY2Nhc2luOlsyNTUsMjI4LDE4MV0sbmF2YWpvd2hpdGU6WzI1NSwyMjIsMTczXSxuYXZ5OlswLDAsMTI4XSxvbGRsYWNlOlsyNTMsMjQ1LDIzMF0sb2xpdmU6WzEyOCwxMjgsMF0sb2xpdmVkcmFiOlsxMDcsMTQyLDM1XSxvcmFuZ2U6WzI1NSwxNjUsMF0sb3JhbmdlcmVkOlsyNTUsNjksMF0sb3JjaGlkOlsyMTgsMTEyLDIxNF0scGFsZWdvbGRlbnJvZDpbMjM4LDIzMiwxNzBdLHBhbGVncmVlbjpbMTUyLDI1MSwxNTJdLHBhbGV0dXJxdW9pc2U6WzE3NSwyMzgsMjM4XSxwYWxldmlvbGV0cmVkOlsyMTksMTEyLDE0N10scGFwYXlhd2hpcDpbMjU1LDIzOSwyMTNdLHBlYWNocHVmZjpbMjU1LDIxOCwxODVdLHBlcnU6WzIwNSwxMzMsNjNdLHBpbms6WzI1NSwxOTIsMjAzXSxwbHVtOlsyMjEsMTYwLDIyMV0scG93ZGVyYmx1ZTpbMTc2LDIyNCwyMzBdLHB1cnBsZTpbMTI4LDAsMTI4XSxyZWJlY2NhcHVycGxlOlsxMDIsNTEsMTUzXSxyZWQ6WzI1NSwwLDBdLHJvc3licm93bjpbMTg4LDE0MywxNDNdLHJveWFsYmx1ZTpbNjUsMTA1LDIyNV0sc2FkZGxlYnJvd246WzEzOSw2OSwxOV0sc2FsbW9uOlsyNTAsMTI4LDExNF0sc2FuZHlicm93bjpbMjQ0LDE2NCw5Nl0sc2VhZ3JlZW46WzQ2LDEzOSw4N10sc2Vhc2hlbGw6WzI1NSwyNDUsMjM4XSxzaWVubmE6WzE2MCw4Miw0NV0sc2lsdmVyOlsxOTIsMTkyLDE5Ml0sc2t5Ymx1ZTpbMTM1LDIwNiwyMzVdLHNsYXRlYmx1ZTpbMTA2LDkwLDIwNV0sc2xhdGVncmF5OlsxMTIsMTI4LDE0NF0sc2xhdGVncmV5OlsxMTIsMTI4LDE0NF0sc25vdzpbMjU1LDI1MCwyNTBdLHNwcmluZ2dyZWVuOlswLDI1NSwxMjddLHN0ZWVsYmx1ZTpbNzAsMTMwLDE4MF0sdGFuOlsyMTAsMTgwLDE0MF0sdGVhbDpbMCwxMjgsMTI4XSx0aGlzdGxlOlsyMTYsMTkxLDIxNl0sdG9tYXRvOlsyNTUsOTksNzFdLHR1cnF1b2lzZTpbNjQsMjI0LDIwOF0sdmlvbGV0OlsyMzgsMTMwLDIzOF0sd2hlYXQ6WzI0NSwyMjIsMTc5XSx3aGl0ZTpbMjU1LDI1NSwyNTVdLHdoaXRlc21va2U6WzI0NSwyNDUsMjQ1XSx5ZWxsb3c6WzI1NSwyNTUsMF0seWVsbG93Z3JlZW46WzE1NCwyMDUsNTBdfSxrZT17ZXhwb3J0czp7fX0sc3M9ZnVuY3Rpb24odCl7cmV0dXJuIXR8fHR5cGVvZiB0PT0ic3RyaW5nIj8hMTp0IGluc3RhbmNlb2YgQXJyYXl8fEFycmF5LmlzQXJyYXkodCl8fHQubGVuZ3RoPj0wJiYodC5zcGxpY2UgaW5zdGFuY2VvZiBGdW5jdGlvbnx8T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHQubGVuZ3RoLTEpJiZ0LmNvbnN0cnVjdG9yLm5hbWUhPT0iU3RyaW5nIil9LGlzPXNzLHJzPUFycmF5LnByb3RvdHlwZS5jb25jYXQsbnM9QXJyYXkucHJvdG90eXBlLnNsaWNlLEVlPWtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHM9MCxpPXQubGVuZ3RoO3M8aTtzKyspe3ZhciBuPXRbc107aXMobik/ZT1ycy5jYWxsKGUsbnMuY2FsbChuKSk6ZS5wdXNoKG4pfXJldHVybiBlfTtFZS53cmFwPWZ1bmN0aW9uKHIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiByKEVlKGFyZ3VtZW50cykpfX07dmFyIGFzPWtlLmV4cG9ydHMsQnQ9U2UsdnQ9YXMsQ2U9T2JqZWN0Lmhhc093blByb3BlcnR5LEJlPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKHZhciByZSBpbiBCdClDZS5jYWxsKEJ0LHJlKSYmKEJlW0J0W3JlXV09cmUpO3ZhciBXPUZlLmV4cG9ydHM9e3RvOnt9LGdldDp7fX07Vy5nZXQ9ZnVuY3Rpb24ocil7dmFyIHQ9ci5zdWJzdHJpbmcoMCwzKS50b0xvd2VyQ2FzZSgpLGUscztzd2l0Y2godCl7Y2FzZSJoc2wiOmU9Vy5nZXQuaHNsKHIpLHM9ImhzbCI7YnJlYWs7Y2FzZSJod2IiOmU9Vy5nZXQuaHdiKHIpLHM9Imh3YiI7YnJlYWs7ZGVmYXVsdDplPVcuZ2V0LnJnYihyKSxzPSJyZ2IiO2JyZWFrfXJldHVybiBlP3ttb2RlbDpzLHZhbHVlOmV9Om51bGx9LFcuZ2V0LnJnYj1mdW5jdGlvbihyKXtpZighcilyZXR1cm4gbnVsbDt2YXIgdD0vXiMoW2EtZjAtOV17Myw0fSkkL2ksZT0vXiMoW2EtZjAtOV17Nn0pKFthLWYwLTldezJ9KT8kL2kscz0vXnJnYmE/XChccyooWystXT9cZCspKD89W1xzLF0pXHMqKD86LFxzKik/KFsrLV0/XGQrKSg/PVtccyxdKVxzKig/OixccyopPyhbKy1dP1xkKylccyooPzpbLHxcL11ccyooWystXT9bXGRcLl0rKSglPylccyopP1wpJC8saT0vXnJnYmE/XChccyooWystXT9bXGRcLl0rKVwlXHMqLD9ccyooWystXT9bXGRcLl0rKVwlXHMqLD9ccyooWystXT9bXGRcLl0rKVwlXHMqKD86Wyx8XC9dXHMqKFsrLV0/W1xkXC5dKykoJT8pXHMqKT9cKSQvLG49L14oXHcrKSQvLGE9WzAsMCwwLDFdLG8saCxsO2lmKG89ci5tYXRjaChlKSl7Zm9yKGw9b1syXSxvPW9bMV0saD0wO2g8MztoKyspe3ZhciBjPWgqMjthW2hdPXBhcnNlSW50KG8uc2xpY2UoYyxjKzIpLDE2KX1sJiYoYVszXT1wYXJzZUludChsLDE2KS8yNTUpfWVsc2UgaWYobz1yLm1hdGNoKHQpKXtmb3Iobz1vWzFdLGw9b1szXSxoPTA7aDwzO2grKylhW2hdPXBhcnNlSW50KG9baF0rb1toXSwxNik7bCYmKGFbM109cGFyc2VJbnQobCtsLDE2KS8yNTUpfWVsc2UgaWYobz1yLm1hdGNoKHMpKXtmb3IoaD0wO2g8MztoKyspYVtoXT1wYXJzZUludChvW2grMV0sMCk7b1s0XSYmKG9bNV0/YVszXT1wYXJzZUZsb2F0KG9bNF0pKi4wMTphWzNdPXBhcnNlRmxvYXQob1s0XSkpfWVsc2UgaWYobz1yLm1hdGNoKGkpKXtmb3IoaD0wO2g8MztoKyspYVtoXT1NYXRoLnJvdW5kKHBhcnNlRmxvYXQob1toKzFdKSoyLjU1KTtvWzRdJiYob1s1XT9hWzNdPXBhcnNlRmxvYXQob1s0XSkqLjAxOmFbM109cGFyc2VGbG9hdChvWzRdKSl9ZWxzZSByZXR1cm4obz1yLm1hdGNoKG4pKT9vWzFdPT09InRyYW5zcGFyZW50Ij9bMCwwLDAsMF06Q2UuY2FsbChCdCxvWzFdKT8oYT1CdFtvWzFdXSxhWzNdPTEsYSk6bnVsbDpudWxsO2ZvcihoPTA7aDwzO2grKylhW2hdPW90KGFbaF0sMCwyNTUpO3JldHVybiBhWzNdPW90KGFbM10sMCwxKSxhfSxXLmdldC5oc2w9ZnVuY3Rpb24ocil7aWYoIXIpcmV0dXJuIG51bGw7dmFyIHQ9L15oc2xhP1woXHMqKFsrLV0/KD86XGR7MCwzfVwuKT9cZCspKD86ZGVnKT9ccyosP1xzKihbKy1dP1tcZFwuXSspJVxzKiw/XHMqKFsrLV0/W1xkXC5dKyklXHMqKD86Wyx8XC9dXHMqKFsrLV0/KD89XC5cZHxcZCkoPzowfFsxLTldXGQqKT8oPzpcLlxkKik/KD86W2VFXVsrLV0/XGQrKT8pXHMqKT9cKSQvLGU9ci5tYXRjaCh0KTtpZihlKXt2YXIgcz1wYXJzZUZsb2F0KGVbNF0pLGk9KHBhcnNlRmxvYXQoZVsxXSklMzYwKzM2MCklMzYwLG49b3QocGFyc2VGbG9hdChlWzJdKSwwLDEwMCksYT1vdChwYXJzZUZsb2F0KGVbM10pLDAsMTAwKSxvPW90KGlzTmFOKHMpPzE6cywwLDEpO3JldHVybltpLG4sYSxvXX1yZXR1cm4gbnVsbH0sVy5nZXQuaHdiPWZ1bmN0aW9uKHIpe2lmKCFyKXJldHVybiBudWxsO3ZhciB0PS9eaHdiXChccyooWystXT9cZHswLDN9KD86XC5cZCspPykoPzpkZWcpP1xzKixccyooWystXT9bXGRcLl0rKSVccyosXHMqKFsrLV0/W1xkXC5dKyklXHMqKD86LFxzKihbKy1dPyg/PVwuXGR8XGQpKD86MHxbMS05XVxkKik/KD86XC5cZCopPyg/OltlRV1bKy1dP1xkKyk/KVxzKik/XCkkLyxlPXIubWF0Y2godCk7aWYoZSl7dmFyIHM9cGFyc2VGbG9hdChlWzRdKSxpPShwYXJzZUZsb2F0KGVbMV0pJTM2MCszNjApJTM2MCxuPW90KHBhcnNlRmxvYXQoZVsyXSksMCwxMDApLGE9b3QocGFyc2VGbG9hdChlWzNdKSwwLDEwMCksbz1vdChpc05hTihzKT8xOnMsMCwxKTtyZXR1cm5baSxuLGEsb119cmV0dXJuIG51bGx9LFcudG8uaGV4PWZ1bmN0aW9uKCl7dmFyIHI9dnQoYXJndW1lbnRzKTtyZXR1cm4iIyIrVXQoclswXSkrVXQoclsxXSkrVXQoclsyXSkrKHJbM108MT9VdChNYXRoLnJvdW5kKHJbM10qMjU1KSk6IiIpfSxXLnRvLnJnYj1mdW5jdGlvbigpe3ZhciByPXZ0KGFyZ3VtZW50cyk7cmV0dXJuIHIubGVuZ3RoPDR8fHJbM109PT0xPyJyZ2IoIitNYXRoLnJvdW5kKHJbMF0pKyIsICIrTWF0aC5yb3VuZChyWzFdKSsiLCAiK01hdGgucm91bmQoclsyXSkrIikiOiJyZ2JhKCIrTWF0aC5yb3VuZChyWzBdKSsiLCAiK01hdGgucm91bmQoclsxXSkrIiwgIitNYXRoLnJvdW5kKHJbMl0pKyIsICIrclszXSsiKSJ9LFcudG8ucmdiLnBlcmNlbnQ9ZnVuY3Rpb24oKXt2YXIgcj12dChhcmd1bWVudHMpLHQ9TWF0aC5yb3VuZChyWzBdLzI1NSoxMDApLGU9TWF0aC5yb3VuZChyWzFdLzI1NSoxMDApLHM9TWF0aC5yb3VuZChyWzJdLzI1NSoxMDApO3JldHVybiByLmxlbmd0aDw0fHxyWzNdPT09MT8icmdiKCIrdCsiJSwgIitlKyIlLCAiK3MrIiUpIjoicmdiYSgiK3QrIiUsICIrZSsiJSwgIitzKyIlLCAiK3JbM10rIikifSxXLnRvLmhzbD1mdW5jdGlvbigpe3ZhciByPXZ0KGFyZ3VtZW50cyk7cmV0dXJuIHIubGVuZ3RoPDR8fHJbM109PT0xPyJoc2woIityWzBdKyIsICIrclsxXSsiJSwgIityWzJdKyIlKSI6ImhzbGEoIityWzBdKyIsICIrclsxXSsiJSwgIityWzJdKyIlLCAiK3JbM10rIikifSxXLnRvLmh3Yj1mdW5jdGlvbigpe3ZhciByPXZ0KGFyZ3VtZW50cyksdD0iIjtyZXR1cm4gci5sZW5ndGg+PTQmJnJbM10hPT0xJiYodD0iLCAiK3JbM10pLCJod2IoIityWzBdKyIsICIrclsxXSsiJSwgIityWzJdKyIlIit0KyIpIn0sVy50by5rZXl3b3JkPWZ1bmN0aW9uKHIpe3JldHVybiBCZVtyLnNsaWNlKDAsMyldfTtmdW5jdGlvbiBvdChyLHQsZSl7cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHQsciksZSl9ZnVuY3Rpb24gVXQocil7dmFyIHQ9TWF0aC5yb3VuZChyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtyZXR1cm4gdC5sZW5ndGg8Mj8iMCIrdDp0fXZhciBvcz1GZS5leHBvcnRzO2NvbnN0IER0PVNlLHZlPXt9O2Zvcihjb25zdCByIG9mIE9iamVjdC5rZXlzKER0KSl2ZVtEdFtyXV09cjtjb25zdCBiPXtyZ2I6e2NoYW5uZWxzOjMsbGFiZWxzOiJyZ2IifSxoc2w6e2NoYW5uZWxzOjMsbGFiZWxzOiJoc2wifSxoc3Y6e2NoYW5uZWxzOjMsbGFiZWxzOiJoc3YifSxod2I6e2NoYW5uZWxzOjMsbGFiZWxzOiJod2IifSxjbXlrOntjaGFubmVsczo0LGxhYmVsczoiY215ayJ9LHh5ejp7Y2hhbm5lbHM6MyxsYWJlbHM6Inh5eiJ9LGxhYjp7Y2hhbm5lbHM6MyxsYWJlbHM6ImxhYiJ9LGxjaDp7Y2hhbm5lbHM6MyxsYWJlbHM6ImxjaCJ9LGhleDp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJoZXgiXX0sa2V5d29yZDp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJrZXl3b3JkIl19LGFuc2kxNjp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJhbnNpMTYiXX0sYW5zaTI1Njp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJhbnNpMjU2Il19LGhjZzp7Y2hhbm5lbHM6MyxsYWJlbHM6WyJoIiwiYyIsImciXX0sYXBwbGU6e2NoYW5uZWxzOjMsbGFiZWxzOlsicjE2IiwiZzE2IiwiYjE2Il19LGdyYXk6e2NoYW5uZWxzOjEsbGFiZWxzOlsiZ3JheSJdfX07dmFyIERlPWI7Zm9yKGNvbnN0IHIgb2YgT2JqZWN0LmtleXMoYikpe2lmKCEoImNoYW5uZWxzImluIGJbcl0pKXRocm93IG5ldyBFcnJvcigibWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogIityKTtpZighKCJsYWJlbHMiaW4gYltyXSkpdGhyb3cgbmV3IEVycm9yKCJtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiAiK3IpO2lmKGJbcl0ubGFiZWxzLmxlbmd0aCE9PWJbcl0uY2hhbm5lbHMpdGhyb3cgbmV3IEVycm9yKCJjaGFubmVsIGFuZCBsYWJlbCBjb3VudHMgbWlzbWF0Y2g6ICIrcik7Y29uc3R7Y2hhbm5lbHM6dCxsYWJlbHM6ZX09YltyXTtkZWxldGUgYltyXS5jaGFubmVscyxkZWxldGUgYltyXS5sYWJlbHMsT2JqZWN0LmRlZmluZVByb3BlcnR5KGJbcl0sImNoYW5uZWxzIix7dmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiW3JdLCJsYWJlbHMiLHt2YWx1ZTplfSl9Yi5yZ2IuaHNsPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clswXS8yNTUsZT1yWzFdLzI1NSxzPXJbMl0vMjU1LGk9TWF0aC5taW4odCxlLHMpLG49TWF0aC5tYXgodCxlLHMpLGE9bi1pO2xldCBvLGg7bj09PWk/bz0wOnQ9PT1uP289KGUtcykvYTplPT09bj9vPTIrKHMtdCkvYTpzPT09biYmKG89NCsodC1lKS9hKSxvPU1hdGgubWluKG8qNjAsMzYwKSxvPDAmJihvKz0zNjApO2NvbnN0IGw9KGkrbikvMjtyZXR1cm4gbj09PWk/aD0wOmw8PS41P2g9YS8obitpKTpoPWEvKDItbi1pKSxbbyxoKjEwMCxsKjEwMF19LGIucmdiLmhzdj1mdW5jdGlvbihyKXtsZXQgdCxlLHMsaSxuO2NvbnN0IGE9clswXS8yNTUsbz1yWzFdLzI1NSxoPXJbMl0vMjU1LGw9TWF0aC5tYXgoYSxvLGgpLGM9bC1NYXRoLm1pbihhLG8saCksdT1mdW5jdGlvbihtKXtyZXR1cm4obC1tKS82L2MrMS8yfTtyZXR1cm4gYz09PTA/KGk9MCxuPTApOihuPWMvbCx0PXUoYSksZT11KG8pLHM9dShoKSxhPT09bD9pPXMtZTpvPT09bD9pPTEvMyt0LXM6aD09PWwmJihpPTIvMytlLXQpLGk8MD9pKz0xOmk+MSYmKGktPTEpKSxbaSozNjAsbioxMDAsbCoxMDBdfSxiLnJnYi5od2I9ZnVuY3Rpb24ocil7Y29uc3QgdD1yWzBdLGU9clsxXTtsZXQgcz1yWzJdO2NvbnN0IGk9Yi5yZ2IuaHNsKHIpWzBdLG49MS8yNTUqTWF0aC5taW4odCxNYXRoLm1pbihlLHMpKTtyZXR1cm4gcz0xLTEvMjU1Kk1hdGgubWF4KHQsTWF0aC5tYXgoZSxzKSksW2ksbioxMDAscyoxMDBdfSxiLnJnYi5jbXlrPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clswXS8yNTUsZT1yWzFdLzI1NSxzPXJbMl0vMjU1LGk9TWF0aC5taW4oMS10LDEtZSwxLXMpLG49KDEtdC1pKS8oMS1pKXx8MCxhPSgxLWUtaSkvKDEtaSl8fDAsbz0oMS1zLWkpLygxLWkpfHwwO3JldHVybltuKjEwMCxhKjEwMCxvKjEwMCxpKjEwMF19O2Z1bmN0aW9uIGhzKHIsdCl7cmV0dXJuKHJbMF0tdFswXSkqKjIrKHJbMV0tdFsxXSkqKjIrKHJbMl0tdFsyXSkqKjJ9Yi5yZ2Iua2V5d29yZD1mdW5jdGlvbihyKXtjb25zdCB0PXZlW3JdO2lmKHQpcmV0dXJuIHQ7bGV0IGU9MS8wLHM7Zm9yKGNvbnN0IGkgb2YgT2JqZWN0LmtleXMoRHQpKXtjb25zdCBuPUR0W2ldLGE9aHMocixuKTthPGUmJihlPWEscz1pKX1yZXR1cm4gc30sYi5rZXl3b3JkLnJnYj1mdW5jdGlvbihyKXtyZXR1cm4gRHRbcl19LGIucmdiLnh5ej1mdW5jdGlvbihyKXtsZXQgdD1yWzBdLzI1NSxlPXJbMV0vMjU1LHM9clsyXS8yNTU7dD10Pi4wNDA0NT8oKHQrLjA1NSkvMS4wNTUpKioyLjQ6dC8xMi45MixlPWU+LjA0MDQ1PygoZSsuMDU1KS8xLjA1NSkqKjIuNDplLzEyLjkyLHM9cz4uMDQwNDU/KChzKy4wNTUpLzEuMDU1KSoqMi40OnMvMTIuOTI7Y29uc3QgaT10Ki40MTI0K2UqLjM1NzYrcyouMTgwNSxuPXQqLjIxMjYrZSouNzE1MitzKi4wNzIyLGE9dCouMDE5MytlKi4xMTkyK3MqLjk1MDU7cmV0dXJuW2kqMTAwLG4qMTAwLGEqMTAwXX0sYi5yZ2IubGFiPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9Yi5yZ2IueHl6KHIpO2xldCBlPXRbMF0scz10WzFdLGk9dFsyXTtlLz05NS4wNDcscy89MTAwLGkvPTEwOC44ODMsZT1lPi4wMDg4NTY/ZSoqKDEvMyk6Ny43ODcqZSsxNi8xMTYscz1zPi4wMDg4NTY/cyoqKDEvMyk6Ny43ODcqcysxNi8xMTYsaT1pPi4wMDg4NTY/aSoqKDEvMyk6Ny43ODcqaSsxNi8xMTY7Y29uc3Qgbj0xMTYqcy0xNixhPTUwMCooZS1zKSxvPTIwMCoocy1pKTtyZXR1cm5bbixhLG9dfSxiLmhzbC5yZ2I9ZnVuY3Rpb24ocil7Y29uc3QgdD1yWzBdLzM2MCxlPXJbMV0vMTAwLHM9clsyXS8xMDA7bGV0IGksbixhO2lmKGU9PT0wKXJldHVybiBhPXMqMjU1LFthLGEsYV07czwuNT9pPXMqKDErZSk6aT1zK2UtcyplO2NvbnN0IG89MipzLWksaD1bMCwwLDBdO2ZvcihsZXQgbD0wO2w8MztsKyspbj10KzEvMyotKGwtMSksbjwwJiZuKyssbj4xJiZuLS0sNipuPDE/YT1vKyhpLW8pKjYqbjoyKm48MT9hPWk6MypuPDI/YT1vKyhpLW8pKigyLzMtbikqNjphPW8saFtsXT1hKjI1NTtyZXR1cm4gaH0sYi5oc2wuaHN2PWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clswXTtsZXQgZT1yWzFdLzEwMCxzPXJbMl0vMTAwLGk9ZTtjb25zdCBuPU1hdGgubWF4KHMsLjAxKTtzKj0yLGUqPXM8PTE/czoyLXMsaSo9bjw9MT9uOjItbjtjb25zdCBhPShzK2UpLzIsbz1zPT09MD8yKmkvKG4raSk6MiplLyhzK2UpO3JldHVyblt0LG8qMTAwLGEqMTAwXX0sYi5oc3YucmdiPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clswXS82MCxlPXJbMV0vMTAwO2xldCBzPXJbMl0vMTAwO2NvbnN0IGk9TWF0aC5mbG9vcih0KSU2LG49dC1NYXRoLmZsb29yKHQpLGE9MjU1KnMqKDEtZSksbz0yNTUqcyooMS1lKm4pLGg9MjU1KnMqKDEtZSooMS1uKSk7c3dpdGNoKHMqPTI1NSxpKXtjYXNlIDA6cmV0dXJuW3MsaCxhXTtjYXNlIDE6cmV0dXJuW28scyxhXTtjYXNlIDI6cmV0dXJuW2EscyxoXTtjYXNlIDM6cmV0dXJuW2EsbyxzXTtjYXNlIDQ6cmV0dXJuW2gsYSxzXTtjYXNlIDU6cmV0dXJuW3MsYSxvXX19LGIuaHN2LmhzbD1mdW5jdGlvbihyKXtjb25zdCB0PXJbMF0sZT1yWzFdLzEwMCxzPXJbMl0vMTAwLGk9TWF0aC5tYXgocywuMDEpO2xldCBuLGE7YT0oMi1lKSpzO2NvbnN0IG89KDItZSkqaTtyZXR1cm4gbj1lKmksbi89bzw9MT9vOjItbyxuPW58fDAsYS89MixbdCxuKjEwMCxhKjEwMF19LGIuaHdiLnJnYj1mdW5jdGlvbihyKXtjb25zdCB0PXJbMF0vMzYwO2xldCBlPXJbMV0vMTAwLHM9clsyXS8xMDA7Y29uc3QgaT1lK3M7bGV0IG47aT4xJiYoZS89aSxzLz1pKTtjb25zdCBhPU1hdGguZmxvb3IoNip0KSxvPTEtcztuPTYqdC1hLGEmMSYmKG49MS1uKTtjb25zdCBoPWUrbiooby1lKTtsZXQgbCxjLHU7c3dpdGNoKGEpe2RlZmF1bHQ6Y2FzZSA2OmNhc2UgMDpsPW8sYz1oLHU9ZTticmVhaztjYXNlIDE6bD1oLGM9byx1PWU7YnJlYWs7Y2FzZSAyOmw9ZSxjPW8sdT1oO2JyZWFrO2Nhc2UgMzpsPWUsYz1oLHU9bzticmVhaztjYXNlIDQ6bD1oLGM9ZSx1PW87YnJlYWs7Y2FzZSA1Omw9byxjPWUsdT1oO2JyZWFrfXJldHVybltsKjI1NSxjKjI1NSx1KjI1NV19LGIuY215ay5yZ2I9ZnVuY3Rpb24ocil7Y29uc3QgdD1yWzBdLzEwMCxlPXJbMV0vMTAwLHM9clsyXS8xMDAsaT1yWzNdLzEwMCxuPTEtTWF0aC5taW4oMSx0KigxLWkpK2kpLGE9MS1NYXRoLm1pbigxLGUqKDEtaSkraSksbz0xLU1hdGgubWluKDEscyooMS1pKStpKTtyZXR1cm5bbioyNTUsYSoyNTUsbyoyNTVdfSxiLnh5ei5yZ2I9ZnVuY3Rpb24ocil7Y29uc3QgdD1yWzBdLzEwMCxlPXJbMV0vMTAwLHM9clsyXS8xMDA7bGV0IGksbixhO3JldHVybiBpPXQqMy4yNDA2K2UqLTEuNTM3MitzKi0uNDk4NixuPXQqLS45Njg5K2UqMS44NzU4K3MqLjA0MTUsYT10Ki4wNTU3K2UqLS4yMDQrcyoxLjA1NyxpPWk+LjAwMzEzMDg/MS4wNTUqaSoqKDEvMi40KS0uMDU1OmkqMTIuOTIsbj1uPi4wMDMxMzA4PzEuMDU1Km4qKigxLzIuNCktLjA1NTpuKjEyLjkyLGE9YT4uMDAzMTMwOD8xLjA1NSphKiooMS8yLjQpLS4wNTU6YSoxMi45MixpPU1hdGgubWluKE1hdGgubWF4KDAsaSksMSksbj1NYXRoLm1pbihNYXRoLm1heCgwLG4pLDEpLGE9TWF0aC5taW4oTWF0aC5tYXgoMCxhKSwxKSxbaSoyNTUsbioyNTUsYSoyNTVdfSxiLnh5ei5sYWI9ZnVuY3Rpb24ocil7bGV0IHQ9clswXSxlPXJbMV0scz1yWzJdO3QvPTk1LjA0NyxlLz0xMDAscy89MTA4Ljg4Myx0PXQ+LjAwODg1Nj90KiooMS8zKTo3Ljc4Nyp0KzE2LzExNixlPWU+LjAwODg1Nj9lKiooMS8zKTo3Ljc4NyplKzE2LzExNixzPXM+LjAwODg1Nj9zKiooMS8zKTo3Ljc4NypzKzE2LzExNjtjb25zdCBpPTExNiplLTE2LG49NTAwKih0LWUpLGE9MjAwKihlLXMpO3JldHVybltpLG4sYV19LGIubGFiLnh5ej1mdW5jdGlvbihyKXtjb25zdCB0PXJbMF0sZT1yWzFdLHM9clsyXTtsZXQgaSxuLGE7bj0odCsxNikvMTE2LGk9ZS81MDArbixhPW4tcy8yMDA7Y29uc3Qgbz1uKiozLGg9aSoqMyxsPWEqKjM7cmV0dXJuIG49bz4uMDA4ODU2P286KG4tMTYvMTE2KS83Ljc4NyxpPWg+LjAwODg1Nj9oOihpLTE2LzExNikvNy43ODcsYT1sPi4wMDg4NTY/bDooYS0xNi8xMTYpLzcuNzg3LGkqPTk1LjA0NyxuKj0xMDAsYSo9MTA4Ljg4MyxbaSxuLGFdfSxiLmxhYi5sY2g9ZnVuY3Rpb24ocil7Y29uc3QgdD1yWzBdLGU9clsxXSxzPXJbMl07bGV0IGk7aT1NYXRoLmF0YW4yKHMsZSkqMzYwLzIvTWF0aC5QSSxpPDAmJihpKz0zNjApO2NvbnN0IGE9TWF0aC5zcXJ0KGUqZStzKnMpO3JldHVyblt0LGEsaV19LGIubGNoLmxhYj1mdW5jdGlvbihyKXtjb25zdCB0PXJbMF0sZT1yWzFdLGk9clsyXS8zNjAqMipNYXRoLlBJLG49ZSpNYXRoLmNvcyhpKSxhPWUqTWF0aC5zaW4oaSk7cmV0dXJuW3QsbixhXX0sYi5yZ2IuYW5zaTE2PWZ1bmN0aW9uKHIsdD1udWxsKXtjb25zdFtlLHMsaV09cjtsZXQgbj10PT09bnVsbD9iLnJnYi5oc3YocilbMl06dDtpZihuPU1hdGgucm91bmQobi81MCksbj09PTApcmV0dXJuIDMwO2xldCBhPTMwKyhNYXRoLnJvdW5kKGkvMjU1KTw8MnxNYXRoLnJvdW5kKHMvMjU1KTw8MXxNYXRoLnJvdW5kKGUvMjU1KSk7cmV0dXJuIG49PT0yJiYoYSs9NjApLGF9LGIuaHN2LmFuc2kxNj1mdW5jdGlvbihyKXtyZXR1cm4gYi5yZ2IuYW5zaTE2KGIuaHN2LnJnYihyKSxyWzJdKX0sYi5yZ2IuYW5zaTI1Nj1mdW5jdGlvbihyKXtjb25zdCB0PXJbMF0sZT1yWzFdLHM9clsyXTtyZXR1cm4gdD09PWUmJmU9PT1zP3Q8OD8xNjp0PjI0OD8yMzE6TWF0aC5yb3VuZCgodC04KS8yNDcqMjQpKzIzMjoxNiszNipNYXRoLnJvdW5kKHQvMjU1KjUpKzYqTWF0aC5yb3VuZChlLzI1NSo1KStNYXRoLnJvdW5kKHMvMjU1KjUpfSxiLmFuc2kxNi5yZ2I9ZnVuY3Rpb24ocil7bGV0IHQ9ciUxMDtpZih0PT09MHx8dD09PTcpcmV0dXJuIHI+NTAmJih0Kz0zLjUpLHQ9dC8xMC41KjI1NSxbdCx0LHRdO2NvbnN0IGU9KH5+KHI+NTApKzEpKi41LHM9KHQmMSkqZSoyNTUsaT0odD4+MSYxKSplKjI1NSxuPSh0Pj4yJjEpKmUqMjU1O3JldHVybltzLGksbl19LGIuYW5zaTI1Ni5yZ2I9ZnVuY3Rpb24ocil7aWYocj49MjMyKXtjb25zdCBuPShyLTIzMikqMTArODtyZXR1cm5bbixuLG5dfXItPTE2O2xldCB0O2NvbnN0IGU9TWF0aC5mbG9vcihyLzM2KS81KjI1NSxzPU1hdGguZmxvb3IoKHQ9ciUzNikvNikvNSoyNTUsaT10JTYvNSoyNTU7cmV0dXJuW2UscyxpXX0sYi5yZ2IuaGV4PWZ1bmN0aW9uKHIpe2NvbnN0IGU9KCgoTWF0aC5yb3VuZChyWzBdKSYyNTUpPDwxNikrKChNYXRoLnJvdW5kKHJbMV0pJjI1NSk8PDgpKyhNYXRoLnJvdW5kKHJbMl0pJjI1NSkpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiIwMDAwMDAiLnN1YnN0cmluZyhlLmxlbmd0aCkrZX0sYi5oZXgucmdiPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9ci50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO2lmKCF0KXJldHVyblswLDAsMF07bGV0IGU9dFswXTt0WzBdLmxlbmd0aD09PTMmJihlPWUuc3BsaXQoIiIpLm1hcChvPT5vK28pLmpvaW4oIiIpKTtjb25zdCBzPXBhcnNlSW50KGUsMTYpLGk9cz4+MTYmMjU1LG49cz4+OCYyNTUsYT1zJjI1NTtyZXR1cm5baSxuLGFdfSxiLnJnYi5oY2c9ZnVuY3Rpb24ocil7Y29uc3QgdD1yWzBdLzI1NSxlPXJbMV0vMjU1LHM9clsyXS8yNTUsaT1NYXRoLm1heChNYXRoLm1heCh0LGUpLHMpLG49TWF0aC5taW4oTWF0aC5taW4odCxlKSxzKSxhPWktbjtsZXQgbyxoO3JldHVybiBhPDE/bz1uLygxLWEpOm89MCxhPD0wP2g9MDppPT09dD9oPShlLXMpL2ElNjppPT09ZT9oPTIrKHMtdCkvYTpoPTQrKHQtZSkvYSxoLz02LGglPTEsW2gqMzYwLGEqMTAwLG8qMTAwXX0sYi5oc2wuaGNnPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clsxXS8xMDAsZT1yWzJdLzEwMCxzPWU8LjU/Mip0KmU6Mip0KigxLWUpO2xldCBpPTA7cmV0dXJuIHM8MSYmKGk9KGUtLjUqcykvKDEtcykpLFtyWzBdLHMqMTAwLGkqMTAwXX0sYi5oc3YuaGNnPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clsxXS8xMDAsZT1yWzJdLzEwMCxzPXQqZTtsZXQgaT0wO3JldHVybiBzPDEmJihpPShlLXMpLygxLXMpKSxbclswXSxzKjEwMCxpKjEwMF19LGIuaGNnLnJnYj1mdW5jdGlvbihyKXtjb25zdCB0PXJbMF0vMzYwLGU9clsxXS8xMDAscz1yWzJdLzEwMDtpZihlPT09MClyZXR1cm5bcyoyNTUscyoyNTUscyoyNTVdO2NvbnN0IGk9WzAsMCwwXSxuPXQlMSo2LGE9biUxLG89MS1hO2xldCBoPTA7c3dpdGNoKE1hdGguZmxvb3Iobikpe2Nhc2UgMDppWzBdPTEsaVsxXT1hLGlbMl09MDticmVhaztjYXNlIDE6aVswXT1vLGlbMV09MSxpWzJdPTA7YnJlYWs7Y2FzZSAyOmlbMF09MCxpWzFdPTEsaVsyXT1hO2JyZWFrO2Nhc2UgMzppWzBdPTAsaVsxXT1vLGlbMl09MTticmVhaztjYXNlIDQ6aVswXT1hLGlbMV09MCxpWzJdPTE7YnJlYWs7ZGVmYXVsdDppWzBdPTEsaVsxXT0wLGlbMl09b31yZXR1cm4gaD0oMS1lKSpzLFsoZSppWzBdK2gpKjI1NSwoZSppWzFdK2gpKjI1NSwoZSppWzJdK2gpKjI1NV19LGIuaGNnLmhzdj1mdW5jdGlvbihyKXtjb25zdCB0PXJbMV0vMTAwLGU9clsyXS8xMDAscz10K2UqKDEtdCk7bGV0IGk9MDtyZXR1cm4gcz4wJiYoaT10L3MpLFtyWzBdLGkqMTAwLHMqMTAwXX0sYi5oY2cuaHNsPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clsxXS8xMDAscz1yWzJdLzEwMCooMS10KSsuNSp0O2xldCBpPTA7cmV0dXJuIHM+MCYmczwuNT9pPXQvKDIqcyk6cz49LjUmJnM8MSYmKGk9dC8oMiooMS1zKSkpLFtyWzBdLGkqMTAwLHMqMTAwXX0sYi5oY2cuaHdiPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clsxXS8xMDAsZT1yWzJdLzEwMCxzPXQrZSooMS10KTtyZXR1cm5bclswXSwocy10KSoxMDAsKDEtcykqMTAwXX0sYi5od2IuaGNnPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9clsxXS8xMDAscz0xLXJbMl0vMTAwLGk9cy10O2xldCBuPTA7cmV0dXJuIGk8MSYmKG49KHMtaSkvKDEtaSkpLFtyWzBdLGkqMTAwLG4qMTAwXX0sYi5hcHBsZS5yZ2I9ZnVuY3Rpb24ocil7cmV0dXJuW3JbMF0vNjU1MzUqMjU1LHJbMV0vNjU1MzUqMjU1LHJbMl0vNjU1MzUqMjU1XX0sYi5yZ2IuYXBwbGU9ZnVuY3Rpb24ocil7cmV0dXJuW3JbMF0vMjU1KjY1NTM1LHJbMV0vMjU1KjY1NTM1LHJbMl0vMjU1KjY1NTM1XX0sYi5ncmF5LnJnYj1mdW5jdGlvbihyKXtyZXR1cm5bclswXS8xMDAqMjU1LHJbMF0vMTAwKjI1NSxyWzBdLzEwMCoyNTVdfSxiLmdyYXkuaHNsPWZ1bmN0aW9uKHIpe3JldHVyblswLDAsclswXV19LGIuZ3JheS5oc3Y9Yi5ncmF5LmhzbCxiLmdyYXkuaHdiPWZ1bmN0aW9uKHIpe3JldHVyblswLDEwMCxyWzBdXX0sYi5ncmF5LmNteWs9ZnVuY3Rpb24ocil7cmV0dXJuWzAsMCwwLHJbMF1dfSxiLmdyYXkubGFiPWZ1bmN0aW9uKHIpe3JldHVybltyWzBdLDAsMF19LGIuZ3JheS5oZXg9ZnVuY3Rpb24ocil7Y29uc3QgdD1NYXRoLnJvdW5kKHJbMF0vMTAwKjI1NSkmMjU1LHM9KCh0PDwxNikrKHQ8PDgpK3QpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiIwMDAwMDAiLnN1YnN0cmluZyhzLmxlbmd0aCkrc30sYi5yZ2IuZ3JheT1mdW5jdGlvbihyKXtyZXR1cm5bKHJbMF0rclsxXStyWzJdKS8zLzI1NSoxMDBdfTtjb25zdCBxdD1EZTtmdW5jdGlvbiBscygpe2NvbnN0IHI9e30sdD1PYmplY3Qua2V5cyhxdCk7Zm9yKGxldCBlPXQubGVuZ3RoLHM9MDtzPGU7cysrKXJbdFtzXV09e2Rpc3RhbmNlOi0xLHBhcmVudDpudWxsfTtyZXR1cm4gcn1mdW5jdGlvbiBjcyhyKXtjb25zdCB0PWxzKCksZT1bcl07Zm9yKHRbcl0uZGlzdGFuY2U9MDtlLmxlbmd0aDspe2NvbnN0IHM9ZS5wb3AoKSxpPU9iamVjdC5rZXlzKHF0W3NdKTtmb3IobGV0IG49aS5sZW5ndGgsYT0wO2E8bjthKyspe2NvbnN0IG89aVthXSxoPXRbb107aC5kaXN0YW5jZT09PS0xJiYoaC5kaXN0YW5jZT10W3NdLmRpc3RhbmNlKzEsaC5wYXJlbnQ9cyxlLnVuc2hpZnQobykpfX1yZXR1cm4gdH1mdW5jdGlvbiB1cyhyLHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdChyKGUpKX19ZnVuY3Rpb24gZHMocix0KXtjb25zdCBlPVt0W3JdLnBhcmVudCxyXTtsZXQgcz1xdFt0W3JdLnBhcmVudF1bcl0saT10W3JdLnBhcmVudDtmb3IoO3RbaV0ucGFyZW50OyllLnVuc2hpZnQodFtpXS5wYXJlbnQpLHM9dXMocXRbdFtpXS5wYXJlbnRdW2ldLHMpLGk9dFtpXS5wYXJlbnQ7cmV0dXJuIHMuY29udmVyc2lvbj1lLHN9dmFyIG1zPWZ1bmN0aW9uKHIpe2NvbnN0IHQ9Y3MociksZT17fSxzPU9iamVjdC5rZXlzKHQpO2ZvcihsZXQgaT1zLmxlbmd0aCxuPTA7bjxpO24rKyl7Y29uc3QgYT1zW25dO3RbYV0ucGFyZW50IT09bnVsbCYmKGVbYV09ZHMoYSx0KSl9cmV0dXJuIGV9O2NvbnN0IG5lPURlLGZzPW1zLGd0PXt9LHlzPU9iamVjdC5rZXlzKG5lKTtmdW5jdGlvbiB4cyhyKXtjb25zdCB0PWZ1bmN0aW9uKC4uLmUpe2NvbnN0IHM9ZVswXTtyZXR1cm4gcz09bnVsbD9zOihzLmxlbmd0aD4xJiYoZT1zKSxyKGUpKX07cmV0dXJuImNvbnZlcnNpb24iaW4gciYmKHQuY29udmVyc2lvbj1yLmNvbnZlcnNpb24pLHR9ZnVuY3Rpb24gcHMocil7Y29uc3QgdD1mdW5jdGlvbiguLi5lKXtjb25zdCBzPWVbMF07aWYocz09bnVsbClyZXR1cm4gcztzLmxlbmd0aD4xJiYoZT1zKTtjb25zdCBpPXIoZSk7aWYodHlwZW9mIGk9PSJvYmplY3QiKWZvcihsZXQgbj1pLmxlbmd0aCxhPTA7YTxuO2ErKylpW2FdPU1hdGgucm91bmQoaVthXSk7cmV0dXJuIGl9O3JldHVybiJjb252ZXJzaW9uImluIHImJih0LmNvbnZlcnNpb249ci5jb252ZXJzaW9uKSx0fXlzLmZvckVhY2gocj0+e2d0W3JdPXt9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShndFtyXSwiY2hhbm5lbHMiLHt2YWx1ZTpuZVtyXS5jaGFubmVsc30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShndFtyXSwibGFiZWxzIix7dmFsdWU6bmVbcl0ubGFiZWxzfSk7Y29uc3QgdD1mcyhyKTtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKHM9Pntjb25zdCBpPXRbc107Z3Rbcl1bc109cHMoaSksZ3Rbcl1bc10ucmF3PXhzKGkpfSl9KTt2YXIgZ3M9Z3Q7Y29uc3QgYnQ9b3MsJD1ncyxUZT1bImtleXdvcmQiLCJncmF5IiwiaGV4Il0sYWU9e307Zm9yKGNvbnN0IHIgb2YgT2JqZWN0LmtleXMoJCkpYWVbWy4uLiRbcl0ubGFiZWxzXS5zb3J0KCkuam9pbigiIildPXI7Y29uc3QgTnQ9e307ZnVuY3Rpb24gVChyLHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFQpKXJldHVybiBuZXcgVChyLHQpO2lmKHQmJnQgaW4gVGUmJih0PW51bGwpLHQmJiEodCBpbiAkKSl0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gbW9kZWw6ICIrdCk7bGV0IGUscztpZihyPT1udWxsKXRoaXMubW9kZWw9InJnYiIsdGhpcy5jb2xvcj1bMCwwLDBdLHRoaXMudmFscGhhPTE7ZWxzZSBpZihyIGluc3RhbmNlb2YgVCl0aGlzLm1vZGVsPXIubW9kZWwsdGhpcy5jb2xvcj1bLi4uci5jb2xvcl0sdGhpcy52YWxwaGE9ci52YWxwaGE7ZWxzZSBpZih0eXBlb2Ygcj09InN0cmluZyIpe2NvbnN0IGk9YnQuZ2V0KHIpO2lmKGk9PT1udWxsKXRocm93IG5ldyBFcnJvcigiVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gc3RyaW5nOiAiK3IpO3RoaXMubW9kZWw9aS5tb2RlbCxzPSRbdGhpcy5tb2RlbF0uY2hhbm5lbHMsdGhpcy5jb2xvcj1pLnZhbHVlLnNsaWNlKDAscyksdGhpcy52YWxwaGE9dHlwZW9mIGkudmFsdWVbc109PSJudW1iZXIiP2kudmFsdWVbc106MX1lbHNlIGlmKHIubGVuZ3RoPjApe3RoaXMubW9kZWw9dHx8InJnYiIscz0kW3RoaXMubW9kZWxdLmNoYW5uZWxzO2NvbnN0IGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwociwwLHMpO3RoaXMuY29sb3I9b2UoaSxzKSx0aGlzLnZhbHBoYT10eXBlb2YgcltzXT09Im51bWJlciI/cltzXToxfWVsc2UgaWYodHlwZW9mIHI9PSJudW1iZXIiKXRoaXMubW9kZWw9InJnYiIsdGhpcy5jb2xvcj1bcj4+MTYmMjU1LHI+PjgmMjU1LHImMjU1XSx0aGlzLnZhbHBoYT0xO2Vsc2V7dGhpcy52YWxwaGE9MTtjb25zdCBpPU9iamVjdC5rZXlzKHIpOyJhbHBoYSJpbiByJiYoaS5zcGxpY2UoaS5pbmRleE9mKCJhbHBoYSIpLDEpLHRoaXMudmFscGhhPXR5cGVvZiByLmFscGhhPT0ibnVtYmVyIj9yLmFscGhhOjApO2NvbnN0IG49aS5zb3J0KCkuam9pbigiIik7aWYoIShuIGluIGFlKSl0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIG9iamVjdDogIitKU09OLnN0cmluZ2lmeShyKSk7dGhpcy5tb2RlbD1hZVtuXTtjb25zdHtsYWJlbHM6YX09JFt0aGlzLm1vZGVsXSxvPVtdO2ZvcihlPTA7ZTxhLmxlbmd0aDtlKyspby5wdXNoKHJbYVtlXV0pO3RoaXMuY29sb3I9b2Uobyl9aWYoTnRbdGhpcy5tb2RlbF0pZm9yKHM9JFt0aGlzLm1vZGVsXS5jaGFubmVscyxlPTA7ZTxzO2UrKyl7Y29uc3QgaT1OdFt0aGlzLm1vZGVsXVtlXTtpJiYodGhpcy5jb2xvcltlXT1pKHRoaXMuY29sb3JbZV0pKX10aGlzLnZhbHBoYT1NYXRoLm1heCgwLE1hdGgubWluKDEsdGhpcy52YWxwaGEpKSxPYmplY3QuZnJlZXplJiZPYmplY3QuZnJlZXplKHRoaXMpfVQucHJvdG90eXBlPXt0b1N0cmluZygpe3JldHVybiB0aGlzLnN0cmluZygpfSx0b0pTT04oKXtyZXR1cm4gdGhpc1t0aGlzLm1vZGVsXSgpfSxzdHJpbmcocil7bGV0IHQ9dGhpcy5tb2RlbCBpbiBidC50bz90aGlzOnRoaXMucmdiKCk7dD10LnJvdW5kKHR5cGVvZiByPT0ibnVtYmVyIj9yOjEpO2NvbnN0IGU9dC52YWxwaGE9PT0xP3QuY29sb3I6Wy4uLnQuY29sb3IsdGhpcy52YWxwaGFdO3JldHVybiBidC50b1t0Lm1vZGVsXShlKX0scGVyY2VudFN0cmluZyhyKXtjb25zdCB0PXRoaXMucmdiKCkucm91bmQodHlwZW9mIHI9PSJudW1iZXIiP3I6MSksZT10LnZhbHBoYT09PTE/dC5jb2xvcjpbLi4udC5jb2xvcix0aGlzLnZhbHBoYV07cmV0dXJuIGJ0LnRvLnJnYi5wZXJjZW50KGUpfSxhcnJheSgpe3JldHVybiB0aGlzLnZhbHBoYT09PTE/Wy4uLnRoaXMuY29sb3JdOlsuLi50aGlzLmNvbG9yLHRoaXMudmFscGhhXX0sb2JqZWN0KCl7Y29uc3Qgcj17fSx7Y2hhbm5lbHM6dH09JFt0aGlzLm1vZGVsXSx7bGFiZWxzOmV9PSRbdGhpcy5tb2RlbF07Zm9yKGxldCBzPTA7czx0O3MrKylyW2Vbc11dPXRoaXMuY29sb3Jbc107cmV0dXJuIHRoaXMudmFscGhhIT09MSYmKHIuYWxwaGE9dGhpcy52YWxwaGEpLHJ9LHVuaXRBcnJheSgpe2NvbnN0IHI9dGhpcy5yZ2IoKS5jb2xvcjtyZXR1cm4gclswXS89MjU1LHJbMV0vPTI1NSxyWzJdLz0yNTUsdGhpcy52YWxwaGEhPT0xJiZyLnB1c2godGhpcy52YWxwaGEpLHJ9LHVuaXRPYmplY3QoKXtjb25zdCByPXRoaXMucmdiKCkub2JqZWN0KCk7cmV0dXJuIHIuci89MjU1LHIuZy89MjU1LHIuYi89MjU1LHRoaXMudmFscGhhIT09MSYmKHIuYWxwaGE9dGhpcy52YWxwaGEpLHJ9LHJvdW5kKHIpe3JldHVybiByPU1hdGgubWF4KHJ8fDAsMCksbmV3IFQoWy4uLnRoaXMuY29sb3IubWFwKE1zKHIpKSx0aGlzLnZhbHBoYV0sdGhpcy5tb2RlbCl9LGFscGhhKHIpe3JldHVybiByIT09dm9pZCAwP25ldyBUKFsuLi50aGlzLmNvbG9yLE1hdGgubWF4KDAsTWF0aC5taW4oMSxyKSldLHRoaXMubW9kZWwpOnRoaXMudmFscGhhfSxyZWQ6QygicmdiIiwwLEQoMjU1KSksZ3JlZW46QygicmdiIiwxLEQoMjU1KSksYmx1ZTpDKCJyZ2IiLDIsRCgyNTUpKSxodWU6QyhbImhzbCIsImhzdiIsImhzbCIsImh3YiIsImhjZyJdLDAscj0+KHIlMzYwKzM2MCklMzYwKSxzYXR1cmF0aW9ubDpDKCJoc2wiLDEsRCgxMDApKSxsaWdodG5lc3M6QygiaHNsIiwyLEQoMTAwKSksc2F0dXJhdGlvbnY6QygiaHN2IiwxLEQoMTAwKSksdmFsdWU6QygiaHN2IiwyLEQoMTAwKSksY2hyb21hOkMoImhjZyIsMSxEKDEwMCkpLGdyYXk6QygiaGNnIiwyLEQoMTAwKSksd2hpdGU6QygiaHdiIiwxLEQoMTAwKSksd2JsYWNrOkMoImh3YiIsMixEKDEwMCkpLGN5YW46QygiY215ayIsMCxEKDEwMCkpLG1hZ2VudGE6QygiY215ayIsMSxEKDEwMCkpLHllbGxvdzpDKCJjbXlrIiwyLEQoMTAwKSksYmxhY2s6QygiY215ayIsMyxEKDEwMCkpLHg6QygieHl6IiwwLEQoOTUuMDQ3KSkseTpDKCJ4eXoiLDEsRCgxMDApKSx6OkMoInh5eiIsMixEKDEwOC44MzMpKSxsOkMoImxhYiIsMCxEKDEwMCkpLGE6QygibGFiIiwxKSxiOkMoImxhYiIsMiksa2V5d29yZChyKXtyZXR1cm4gciE9PXZvaWQgMD9uZXcgVChyKTokW3RoaXMubW9kZWxdLmtleXdvcmQodGhpcy5jb2xvcil9LGhleChyKXtyZXR1cm4gciE9PXZvaWQgMD9uZXcgVChyKTpidC50by5oZXgodGhpcy5yZ2IoKS5yb3VuZCgpLmNvbG9yKX0saGV4YShyKXtpZihyIT09dm9pZCAwKXJldHVybiBuZXcgVChyKTtjb25zdCB0PXRoaXMucmdiKCkucm91bmQoKS5jb2xvcjtsZXQgZT1NYXRoLnJvdW5kKHRoaXMudmFscGhhKjI1NSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7cmV0dXJuIGUubGVuZ3RoPT09MSYmKGU9IjAiK2UpLGJ0LnRvLmhleCh0KStlfSxyZ2JOdW1iZXIoKXtjb25zdCByPXRoaXMucmdiKCkuY29sb3I7cmV0dXJuKHJbMF0mMjU1KTw8MTZ8KHJbMV0mMjU1KTw8OHxyWzJdJjI1NX0sbHVtaW5vc2l0eSgpe2NvbnN0IHI9dGhpcy5yZ2IoKS5jb2xvcix0PVtdO2Zvcihjb25zdFtlLHNdb2Ygci5lbnRyaWVzKCkpe2NvbnN0IGk9cy8yNTU7dFtlXT1pPD0uMDQwNDU/aS8xMi45MjooKGkrLjA1NSkvMS4wNTUpKioyLjR9cmV0dXJuIC4yMTI2KnRbMF0rLjcxNTIqdFsxXSsuMDcyMip0WzJdfSxjb250cmFzdChyKXtjb25zdCB0PXRoaXMubHVtaW5vc2l0eSgpLGU9ci5sdW1pbm9zaXR5KCk7cmV0dXJuIHQ+ZT8odCsuMDUpLyhlKy4wNSk6KGUrLjA1KS8odCsuMDUpfSxsZXZlbChyKXtjb25zdCB0PXRoaXMuY29udHJhc3Qocik7cmV0dXJuIHQ+PTc/IkFBQSI6dD49NC41PyJBQSI6IiJ9LGlzRGFyaygpe2NvbnN0IHI9dGhpcy5yZ2IoKS5jb2xvcjtyZXR1cm4oclswXSoyMTI2K3JbMV0qNzE1MityWzJdKjcyMikvMWU0PDEyOH0saXNMaWdodCgpe3JldHVybiF0aGlzLmlzRGFyaygpfSxuZWdhdGUoKXtjb25zdCByPXRoaXMucmdiKCk7Zm9yKGxldCB0PTA7dDwzO3QrKylyLmNvbG9yW3RdPTI1NS1yLmNvbG9yW3RdO3JldHVybiByfSxsaWdodGVuKHIpe2NvbnN0IHQ9dGhpcy5oc2woKTtyZXR1cm4gdC5jb2xvclsyXSs9dC5jb2xvclsyXSpyLHR9LGRhcmtlbihyKXtjb25zdCB0PXRoaXMuaHNsKCk7cmV0dXJuIHQuY29sb3JbMl0tPXQuY29sb3JbMl0qcix0fSxzYXR1cmF0ZShyKXtjb25zdCB0PXRoaXMuaHNsKCk7cmV0dXJuIHQuY29sb3JbMV0rPXQuY29sb3JbMV0qcix0fSxkZXNhdHVyYXRlKHIpe2NvbnN0IHQ9dGhpcy5oc2woKTtyZXR1cm4gdC5jb2xvclsxXS09dC5jb2xvclsxXSpyLHR9LHdoaXRlbihyKXtjb25zdCB0PXRoaXMuaHdiKCk7cmV0dXJuIHQuY29sb3JbMV0rPXQuY29sb3JbMV0qcix0fSxibGFja2VuKHIpe2NvbnN0IHQ9dGhpcy5od2IoKTtyZXR1cm4gdC5jb2xvclsyXSs9dC5jb2xvclsyXSpyLHR9LGdyYXlzY2FsZSgpe2NvbnN0IHI9dGhpcy5yZ2IoKS5jb2xvcix0PXJbMF0qLjMrclsxXSouNTkrclsyXSouMTE7cmV0dXJuIFQucmdiKHQsdCx0KX0sZmFkZShyKXtyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYS10aGlzLnZhbHBoYSpyKX0sb3BhcXVlcihyKXtyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSt0aGlzLnZhbHBoYSpyKX0scm90YXRlKHIpe2NvbnN0IHQ9dGhpcy5oc2woKTtsZXQgZT10LmNvbG9yWzBdO3JldHVybiBlPShlK3IpJTM2MCxlPWU8MD8zNjArZTplLHQuY29sb3JbMF09ZSx0fSxtaXgocix0KXtpZighcnx8IXIucmdiKXRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gIm1peCIgd2FzIG5vdCBhIENvbG9yIGluc3RhbmNlLCBidXQgcmF0aGVyIGFuIGluc3RhbmNlIG9mICcrdHlwZW9mIHIpO2NvbnN0IGU9ci5yZ2IoKSxzPXRoaXMucmdiKCksaT10PT09dm9pZCAwPy41OnQsbj0yKmktMSxhPWUuYWxwaGEoKS1zLmFscGhhKCksbz0oKG4qYT09PS0xP246KG4rYSkvKDErbiphKSkrMSkvMixoPTEtbztyZXR1cm4gVC5yZ2IobyplLnJlZCgpK2gqcy5yZWQoKSxvKmUuZ3JlZW4oKStoKnMuZ3JlZW4oKSxvKmUuYmx1ZSgpK2gqcy5ibHVlKCksZS5hbHBoYSgpKmkrcy5hbHBoYSgpKigxLWkpKX19O2Zvcihjb25zdCByIG9mIE9iamVjdC5rZXlzKCQpKXtpZihUZS5pbmNsdWRlcyhyKSljb250aW51ZTtjb25zdHtjaGFubmVsczp0fT0kW3JdO1QucHJvdG90eXBlW3JdPWZ1bmN0aW9uKC4uLmUpe3JldHVybiB0aGlzLm1vZGVsPT09cj9uZXcgVCh0aGlzKTplLmxlbmd0aD4wP25ldyBUKGUscik6bmV3IFQoWy4uLndzKCRbdGhpcy5tb2RlbF1bcl0ucmF3KHRoaXMuY29sb3IpKSx0aGlzLnZhbHBoYV0scil9LFRbcl09ZnVuY3Rpb24oLi4uZSl7bGV0IHM9ZVswXTtyZXR1cm4gdHlwZW9mIHM9PSJudW1iZXIiJiYocz1vZShlLHQpKSxuZXcgVChzLHIpfX1mdW5jdGlvbiBicyhyLHQpe3JldHVybiBOdW1iZXIoci50b0ZpeGVkKHQpKX1mdW5jdGlvbiBNcyhyKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGJzKHQscil9fWZ1bmN0aW9uIEMocix0LGUpe3I9QXJyYXkuaXNBcnJheShyKT9yOltyXTtmb3IoY29uc3QgcyBvZiByKShOdFtzXXx8KE50W3NdPVtdKSlbdF09ZTtyZXR1cm4gcj1yWzBdLGZ1bmN0aW9uKHMpe2xldCBpO3JldHVybiBzIT09dm9pZCAwPyhlJiYocz1lKHMpKSxpPXRoaXNbcl0oKSxpLmNvbG9yW3RdPXMsaSk6KGk9dGhpc1tyXSgpLmNvbG9yW3RdLGUmJihpPWUoaSkpLGkpfX1mdW5jdGlvbiBEKHIpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5tYXgoMCxNYXRoLm1pbihyLHQpKX19ZnVuY3Rpb24gd3Mocil7cmV0dXJuIEFycmF5LmlzQXJyYXkocik/cjpbcl19ZnVuY3Rpb24gb2Uocix0KXtmb3IobGV0IGU9MDtlPHQ7ZSsrKXR5cGVvZiByW2VdIT0ibnVtYmVyIiYmKHJbZV09MCk7cmV0dXJuIHJ9dmFyIF9zPVQsTXQ9ZXMoX3MpO010KCIjY2NjY2NjIiksTXQoIiMwMGZmMDAiKSxNdCgiI2ZmZmYwMCIpLE10KCIjMDA4ODg4IiksTXQoIiNmZjAwMDAiKSxNdCgiI2YwMDAwMCIpO2NsYXNzIEFze2NvbnN0cnVjdG9yKHQsZSxzLGksbil7dGhpcy54U3RhcnRNbT10LHRoaXMueVN0YXJ0TW09ZSx0aGlzLnhEZWx0YU1tPXMsdGhpcy55RGVsdGFNbT1pLHRoaXMuY3V0QXJlYU1tU3E9bn10b1N0cmluZygpe3JldHVybmAke3RoaXMueERlbHRhTW19LCR7dGhpcy55RGVsdGFNbX06JHt0aGlzLmN1dEFyZWFNbVNxfWB9dG9Db25zdHJ1Y3RvclN0cmluZygpe3JldHVybmBuZXcgTW92ZSgke3RoaXMueFN0YXJ0TW19LCAke3RoaXMueVN0YXJ0TW19LCAke3RoaXMueERlbHRhTW19LCAke3RoaXMueURlbHRhTW19LCAke3RoaXMuY3V0QXJlYU1tU3F9KWB9aXNFbXB0eSgpe3JldHVybiF0aGlzLnhEZWx0YU1tJiYhdGhpcy55RGVsdGFNbX1pc0Jhc2ljKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueERlbHRhTW0pPD0uMDEmJk1hdGguYWJzKHRoaXMueURlbHRhTW0pPD0uMDF9dG9MYXRoZUNvZGUoKXtpZighdGhpcy54RGVsdGFNbSlyZXR1cm4iIjtjb25zdCB0PWU9Pk1hdGguYWJzKGUpLnRvRml4ZWQoMyk7cmV0dXJuIHRoaXMueURlbHRhTW0/YEwke3QodGhpcy54RGVsdGFNbSl9IFJTJHt0KHRoaXMueVN0YXJ0TW0pfSBSRSR7dCh0aGlzLnlTdGFydE1tK3RoaXMueURlbHRhTW0pfWA6YEwke3QodGhpcy54RGVsdGFNbSl9IFIke3QodGhpcy55U3RhcnRNbSl9YH19Y2xhc3MgZnR7Y29uc3RydWN0b3IodCxlLHMsaSxuLGEpe3RoaXMueFN0YXJ0PXQsdGhpcy55U3RhcnQ9ZSx0aGlzLnhEZWx0YT1zLHRoaXMueURlbHRhPWksdGhpcy5jdXRBcmVhPW4sdGhpcy5jdXRQaXhlbHM9YX1zdGF0aWMgd2l0aG91dEN1dCh0LGUscyxpKXtyZXR1cm4gbmV3IGZ0KHQsZSxzLGksMCxbXSl9dG9TdHJpbmcoKXtyZXR1cm5gJHt0aGlzLnhEZWx0YX0sJHt0aGlzLnlEZWx0YX06JHt0aGlzLmN1dEFyZWF9YH10b0NvbnN0cnVjdG9yU3RyaW5nKCl7cmV0dXJuYG5ldyBQaXhlbE1vdmUoJHt0aGlzLnhTdGFydH0sICR7dGhpcy55U3RhcnR9LCAke3RoaXMueERlbHRhfSwgJHt0aGlzLnlEZWx0YX0sICR7dGhpcy5jdXRBcmVhfSwgW10pYH10b01vdmUodCl7cmV0dXJuIG5ldyBBcygtdGhpcy54U3RhcnQvdCwtdGhpcy55U3RhcnQvdCwtdGhpcy54RGVsdGEvdCwtdGhpcy55RGVsdGEvdCx0aGlzLmN1dEFyZWEvdC90KX1pc0VtcHR5KCl7cmV0dXJuIXRoaXMueERlbHRhJiYhdGhpcy55RGVsdGF9aXNCYXNpYygpe3JldHVybih0aGlzLnhEZWx0YT09PTF8fHRoaXMueERlbHRhPT09MHx8dGhpcy54RGVsdGE9PT0tMSkmJih0aGlzLnlEZWx0YT09PTF8fHRoaXMueURlbHRhPT09MHx8dGhpcy55RGVsdGE9PT0tMSl9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLnhEZWx0YSp0aGlzLnhEZWx0YSt0aGlzLnlEZWx0YSp0aGlzLnlEZWx0YSl9aXNIb3Jpem9udGFsT3JWZXJ0aWNhbCgpe3JldHVybiB0aGlzLnhEZWx0YSp0aGlzLnlEZWx0YT09PTAmJiF0aGlzLmlzRW1wdHkoKX1nZXRBbmdsZURlZ3JlZXMoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO2xldCB0PU1hdGguYXRhbjIodGhpcy55RGVsdGEsdGhpcy54RGVsdGEpKjE4MC9NYXRoLlBJO3JldHVybiB0PDAmJih0Kz0zNjApLHR9Z2V0QW5nbGVUb0RlZ3JlZXModCl7bGV0IGU9TWF0aC5hYnModGhpcy5nZXRBbmdsZURlZ3JlZXMoKS10LmdldEFuZ2xlRGVncmVlcygpKTtyZXR1cm4gMzYwLWU8ZT8zNjAtZTplfW1lcmdlKHQpe2lmKHRoaXMueFN0YXJ0K3RoaXMueERlbHRhIT09dC54U3RhcnR8fHRoaXMueVN0YXJ0K3RoaXMueURlbHRhIT09dC55U3RhcnQpdGhyb3cgbmV3IEVycm9yKGBtZXJnZSBlcnJvcjogJHt0aGlzfSArICR7dH1gKTtyZXR1cm4gbmV3IGZ0KHRoaXMueFN0YXJ0LHRoaXMueVN0YXJ0LHRoaXMueERlbHRhK3QueERlbHRhLHRoaXMueURlbHRhK3QueURlbHRhLHRoaXMuY3V0QXJlYSt0LmN1dEFyZWEsdGhpcy5jdXRQaXhlbHMuY29uY2F0KHQuY3V0UGl4ZWxzKSl9Z2V0Q3V0KCl7aWYoIXRoaXMuY3V0QXJlYSlyZXR1cm57d2lkdGg6MCxoZWlnaHQ6MH07bGV0IHQ9MS8wLGU9LTEvMCxzPTEvMCxpPS0xLzA7Zm9yKGxldCBuIG9mIHRoaXMuY3V0UGl4ZWxzKW4ueDx0JiYodD1uLngpLG4ueD5lJiYoZT1uLngpLG4ueTxzJiYocz1uLnkpLG4ueT5pJiYoaT1uLnkpO3JldHVybnt3aWR0aDplLXQrMSxoZWlnaHQ6aS1zKzF9fX1jb25zdCB6cz0uMDUsRnM9Ljk7ZnVuY3Rpb24gU3Mocix0LGUpe2NvbnN0IGk9ci5tZXJnZSh0KS5nZXRBbmdsZVRvRGVncmVlcyhyKTtyZXR1cm4gaT09PTE4MD8hMTpNYXRoLnNpbihpLzE4MCpNYXRoLlBJKSpyLmxlbmd0aCgpPD1lfWZ1bmN0aW9uIFJlKHIsdCl7Y29uc3QgZT1bXTtsZXQgcz0wO2Zvcig7czxyLmxlbmd0aDspe2xldCBpPXJbc107aWYocysxPHIubGVuZ3RoJiZTcyhyW3NdLHJbcysxXSx0KSl7ZS5wdXNoKHJbc10ubWVyZ2UocltzKzFdKSkscys9Mjtjb250aW51ZX1lLnB1c2goaSkscysrfXJldHVybiBlLmxlbmd0aDxyLmxlbmd0aD9SZShlLHQpOmV9ZnVuY3Rpb24gSHQocix0KXtjb25zdCBlPVtdO2xldCBzPTA7Zm9yKDtzPHIubGVuZ3RoOyl7bGV0IGk9cltzXTtpZihpLmlzRW1wdHkoKSl7cysrO2NvbnRpbnVlfWlmKCFpLmN1dEFyZWEpe2NvbnN0IGE9a3MocixzKTtpZihhLmxlbmd0aD4xJiZhLm1vdmVzLmxlbmd0aDxhLmxlbmd0aCl7ZS5wdXNoKC4uLmEubW92ZXMpLHMrPWEubGVuZ3RoO2NvbnRpbnVlfX1jb25zdCBuPUNzKHIscyk7aWYobi5sZW5ndGg+MSl7ZS5wdXNoKG4ubW92ZSkscys9bi5sZW5ndGg7Y29udGludWV9aWYocysxPHIubGVuZ3RoJiZyW3NdLmlzQmFzaWMoKSYmcltzKzFdLmlzSG9yaXpvbnRhbE9yVmVydGljYWwoKSl7bGV0IGE9MTtmb3IoO3MrMSthKjI8ci5sZW5ndGg7KXtjb25zdCBvPXMrYSoyO2lmKHJbb10uaXNCYXNpYygpJiZyW28rMV0uaXNIb3Jpem9udGFsT3JWZXJ0aWNhbCgpJiZyW28tMl0ubWVyZ2UocltvLTFdKS5nZXRBbmdsZVRvRGVncmVlcyhyW29dLm1lcmdlKHJbbysxXSkpPHpzKWErKztlbHNlIGJyZWFrfWlmKGE+MSl7ZS5wdXNoKEJzKHIscywyKmEpKSxzKz0yKmE7Y29udGludWV9fWUucHVzaChpKSxzKyt9cmV0dXJuIGUubGVuZ3RoPHIubGVuZ3RoP0h0KGUpOlJlKGUsRnMpfWZ1bmN0aW9uIGtzKHIsdCl7aWYoclt0XS5jdXRBcmVhKXRocm93IG5ldyBFcnJvcigiZXhwZWN0aW5nIGEgdHJhdmVsIG1vdmUiKTtsZXQgZT10O2Zvcig7ZTxyLmxlbmd0aC0xJiYhcltlKzFdLmN1dEFyZWE7KWUrKztyZXR1cm57bW92ZXM6RXMoci5zbGljZSh0LGUrMSkpLGxlbmd0aDplLXQrMX19ZnVuY3Rpb24gRXMocil7Y29uc3QgdD1bXSxlPXJbMF0scz1NYXRoLm1heC5hcHBseShudWxsLHIubWFwKGg9PmgueVN0YXJ0K2gueURlbHRhKSksaT1yLmF0KC0xKSxuPWkueFN0YXJ0K2kueERlbHRhLGE9aS55U3RhcnQraS55RGVsdGE7bGV0IG89ZS55U3RhcnQ7cmV0dXJuIG4hPWUueFN0YXJ0JiYoZS55U3RhcnQhPT1zJiYodC5wdXNoKGZ0LndpdGhvdXRDdXQoZS54U3RhcnQsZS55U3RhcnQsMCxzLWUueVN0YXJ0KSksbz1zKSx0LnB1c2goZnQud2l0aG91dEN1dChlLnhTdGFydCxzLG4tZS54U3RhcnQsMCkpKSxhIT1vJiZ0LnB1c2goZnQud2l0aG91dEN1dChuLG8sMCxhLW8pKSx0fWZ1bmN0aW9uIENzKHIsdCl7bGV0IGU9clt0XSxzPTE7Zm9yKDt0PHIubGVuZ3RoLTE7KXtjb25zdCBpPXJbdCsxXTtpZighaS5nZXRBbmdsZVRvRGVncmVlcyhlKSllPWUubWVyZ2UoaSkscysrLHQrKztlbHNlIGJyZWFrfXJldHVybnttb3ZlOmUsbGVuZ3RoOnN9fWZ1bmN0aW9uIEJzKHIsdCxlKXtsZXQgcz1yW3RdO2ZvcihsZXQgaT0xO2k8ZTtpKyspcz1zLm1lcmdlKHJbdCtpXSk7cmV0dXJuIHN9LyoqCiAqIEBsaWNlbnNlCiAqIENvcHlyaWdodCAyMDEwLTIwMjMgVGhyZWUuanMgQXV0aG9ycwogKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUCiAqL2NvbnN0IExlPSIxNTMiLEllPTMwMCxQZT0xZTMsV3Q9MTAwMSxPZT0xMDAyLHZzPTEwMDYsRHM9MTAwOCxUcz0xMDA5LFJzPTEwMTUsTHM9MTAyMyxJcz0zZTMsaGU9MzAwMSxsZT0iIixHPSJzcmdiIixjZT0ic3JnYi1saW5lYXIiLFVlPSJkaXNwbGF5LXAzIixxZT0zNTA0NCwkdD0yZTMsTmU9MjAwMTtjbGFzcyB1ZXthZGRFdmVudExpc3RlbmVyKHQsZSl7dGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwJiYodGhpcy5fbGlzdGVuZXJzPXt9KTtjb25zdCBzPXRoaXMuX2xpc3RlbmVycztzW3RdPT09dm9pZCAwJiYoc1t0XT1bXSksc1t0XS5pbmRleE9mKGUpPT09LTEmJnNbdF0ucHVzaChlKX1oYXNFdmVudExpc3RlbmVyKHQsZSl7aWYodGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwKXJldHVybiExO2NvbnN0IHM9dGhpcy5fbGlzdGVuZXJzO3JldHVybiBzW3RdIT09dm9pZCAwJiZzW3RdLmluZGV4T2YoZSkhPT0tMX1yZW1vdmVFdmVudExpc3RlbmVyKHQsZSl7aWYodGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwKXJldHVybjtjb25zdCBpPXRoaXMuX2xpc3RlbmVyc1t0XTtpZihpIT09dm9pZCAwKXtjb25zdCBuPWkuaW5kZXhPZihlKTtuIT09LTEmJmkuc3BsaWNlKG4sMSl9fWRpc3BhdGNoRXZlbnQodCl7aWYodGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwKXJldHVybjtjb25zdCBzPXRoaXMuX2xpc3RlbmVyc1t0LnR5cGVdO2lmKHMhPT12b2lkIDApe3QudGFyZ2V0PXRoaXM7Y29uc3QgaT1zLnNsaWNlKDApO2ZvcihsZXQgbj0wLGE9aS5sZW5ndGg7bjxhO24rKylpW25dLmNhbGwodGhpcyx0KTt0LnRhcmdldD1udWxsfX19Y29uc3QgTz1bIjAwIiwiMDEiLCIwMiIsIjAzIiwiMDQiLCIwNSIsIjA2IiwiMDciLCIwOCIsIjA5IiwiMGEiLCIwYiIsIjBjIiwiMGQiLCIwZSIsIjBmIiwiMTAiLCIxMSIsIjEyIiwiMTMiLCIxNCIsIjE1IiwiMTYiLCIxNyIsIjE4IiwiMTkiLCIxYSIsIjFiIiwiMWMiLCIxZCIsIjFlIiwiMWYiLCIyMCIsIjIxIiwiMjIiLCIyMyIsIjI0IiwiMjUiLCIyNiIsIjI3IiwiMjgiLCIyOSIsIjJhIiwiMmIiLCIyYyIsIjJkIiwiMmUiLCIyZiIsIjMwIiwiMzEiLCIzMiIsIjMzIiwiMzQiLCIzNSIsIjM2IiwiMzciLCIzOCIsIjM5IiwiM2EiLCIzYiIsIjNjIiwiM2QiLCIzZSIsIjNmIiwiNDAiLCI0MSIsIjQyIiwiNDMiLCI0NCIsIjQ1IiwiNDYiLCI0NyIsIjQ4IiwiNDkiLCI0YSIsIjRiIiwiNGMiLCI0ZCIsIjRlIiwiNGYiLCI1MCIsIjUxIiwiNTIiLCI1MyIsIjU0IiwiNTUiLCI1NiIsIjU3IiwiNTgiLCI1OSIsIjVhIiwiNWIiLCI1YyIsIjVkIiwiNWUiLCI1ZiIsIjYwIiwiNjEiLCI2MiIsIjYzIiwiNjQiLCI2NSIsIjY2IiwiNjciLCI2OCIsIjY5IiwiNmEiLCI2YiIsIjZjIiwiNmQiLCI2ZSIsIjZmIiwiNzAiLCI3MSIsIjcyIiwiNzMiLCI3NCIsIjc1IiwiNzYiLCI3NyIsIjc4IiwiNzkiLCI3YSIsIjdiIiwiN2MiLCI3ZCIsIjdlIiwiN2YiLCI4MCIsIjgxIiwiODIiLCI4MyIsIjg0IiwiODUiLCI4NiIsIjg3IiwiODgiLCI4OSIsIjhhIiwiOGIiLCI4YyIsIjhkIiwiOGUiLCI4ZiIsIjkwIiwiOTEiLCI5MiIsIjkzIiwiOTQiLCI5NSIsIjk2IiwiOTciLCI5OCIsIjk5IiwiOWEiLCI5YiIsIjljIiwiOWQiLCI5ZSIsIjlmIiwiYTAiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJhYSIsImFiIiwiYWMiLCJhZCIsImFlIiwiYWYiLCJiMCIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJiOSIsImJhIiwiYmIiLCJiYyIsImJkIiwiYmUiLCJiZiIsImMwIiwiYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwiYzciLCJjOCIsImM5IiwiY2EiLCJjYiIsImNjIiwiY2QiLCJjZSIsImNmIiwiZDAiLCJkMSIsImQyIiwiZDMiLCJkNCIsImQ1IiwiZDYiLCJkNyIsImQ4IiwiZDkiLCJkYSIsImRiIiwiZGMiLCJkZCIsImRlIiwiZGYiLCJlMCIsImUxIiwiZTIiLCJlMyIsImU0IiwiZTUiLCJlNiIsImU3IiwiZTgiLCJlOSIsImVhIiwiZWIiLCJlYyIsImVkIiwiZWUiLCJlZiIsImYwIiwiZjEiLCJmMiIsImYzIiwiZjQiLCJmNSIsImY2IiwiZjciLCJmOCIsImY5IiwiZmEiLCJmYiIsImZjIiwiZmQiLCJmZSIsImZmIl07ZnVuY3Rpb24gVnQoKXtjb25zdCByPU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NXwwLHQ9TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDAsZT1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTV8MCxzPU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NXwwO3JldHVybihPW3ImMjU1XStPW3I+PjgmMjU1XStPW3I+PjE2JjI1NV0rT1tyPj4yNCYyNTVdKyItIitPW3QmMjU1XStPW3Q+PjgmMjU1XSsiLSIrT1t0Pj4xNiYxNXw2NF0rT1t0Pj4yNCYyNTVdKyItIitPW2UmNjN8MTI4XStPW2U+PjgmMjU1XSsiLSIrT1tlPj4xNiYyNTVdK09bZT4+MjQmMjU1XStPW3MmMjU1XStPW3M+PjgmMjU1XStPW3M+PjE2JjI1NV0rT1tzPj4yNCYyNTVdKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIE4ocix0LGUpe3JldHVybiBNYXRoLm1heCh0LE1hdGgubWluKGUscikpfWZ1bmN0aW9uIFBzKHIsdCl7cmV0dXJuKHIldCt0KSV0fWZ1bmN0aW9uIGRlKHIsdCxlKXtyZXR1cm4oMS1lKSpyK2UqdH1mdW5jdGlvbiBZdChyLHQpe3N3aXRjaCh0LmNvbnN0cnVjdG9yKXtjYXNlIEZsb2F0MzJBcnJheTpyZXR1cm4gcjtjYXNlIFVpbnQzMkFycmF5OnJldHVybiByLzQyOTQ5NjcyOTU7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gci82NTUzNTtjYXNlIFVpbnQ4QXJyYXk6cmV0dXJuIHIvMjU1O2Nhc2UgSW50MzJBcnJheTpyZXR1cm4gTWF0aC5tYXgoci8yMTQ3NDgzNjQ3LC0xKTtjYXNlIEludDE2QXJyYXk6cmV0dXJuIE1hdGgubWF4KHIvMzI3NjcsLTEpO2Nhc2UgSW50OEFycmF5OnJldHVybiBNYXRoLm1heChyLzEyNywtMSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIil9fWZ1bmN0aW9uIFYocix0KXtzd2l0Y2godC5jb25zdHJ1Y3Rvcil7Y2FzZSBGbG9hdDMyQXJyYXk6cmV0dXJuIHI7Y2FzZSBVaW50MzJBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChyKjQyOTQ5NjcyOTUpO2Nhc2UgVWludDE2QXJyYXk6cmV0dXJuIE1hdGgucm91bmQocio2NTUzNSk7Y2FzZSBVaW50OEFycmF5OnJldHVybiBNYXRoLnJvdW5kKHIqMjU1KTtjYXNlIEludDMyQXJyYXk6cmV0dXJuIE1hdGgucm91bmQocioyMTQ3NDgzNjQ3KTtjYXNlIEludDE2QXJyYXk6cmV0dXJuIE1hdGgucm91bmQociozMjc2Nyk7Y2FzZSBJbnQ4QXJyYXk6cmV0dXJuIE1hdGgucm91bmQocioxMjcpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGNvbXBvbmVudCB0eXBlLiIpfX1jbGFzcyBldHtjb25zdHJ1Y3Rvcih0PTAsZT0wKXtldC5wcm90b3R5cGUuaXNWZWN0b3IyPSEwLHRoaXMueD10LHRoaXMueT1lfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnh9c2V0IHdpZHRoKHQpe3RoaXMueD10fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy55fXNldCBoZWlnaHQodCl7dGhpcy55PXR9c2V0KHQsZSl7cmV0dXJuIHRoaXMueD10LHRoaXMueT1lLHRoaXN9c2V0U2NhbGFyKHQpe3JldHVybiB0aGlzLng9dCx0aGlzLnk9dCx0aGlzfXNldFgodCl7cmV0dXJuIHRoaXMueD10LHRoaXN9c2V0WSh0KXtyZXR1cm4gdGhpcy55PXQsdGhpc31zZXRDb21wb25lbnQodCxlKXtzd2l0Y2godCl7Y2FzZSAwOnRoaXMueD1lO2JyZWFrO2Nhc2UgMTp0aGlzLnk9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiK3QpfXJldHVybiB0aGlzfWdldENvbXBvbmVudCh0KXtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB0aGlzLng7Y2FzZSAxOnJldHVybiB0aGlzLnk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIit0KX19Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LHRoaXMueSl9Y29weSh0KXtyZXR1cm4gdGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXN9YWRkKHQpe3JldHVybiB0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzfWFkZFNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kz10LHRoaXMueSs9dCx0aGlzfWFkZFZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueCtlLngsdGhpcy55PXQueStlLnksdGhpc31hZGRTY2FsZWRWZWN0b3IodCxlKXtyZXR1cm4gdGhpcy54Kz10LngqZSx0aGlzLnkrPXQueSplLHRoaXN9c3ViKHQpe3JldHVybiB0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzfXN1YlNjYWxhcih0KXtyZXR1cm4gdGhpcy54LT10LHRoaXMueS09dCx0aGlzfXN1YlZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueC1lLngsdGhpcy55PXQueS1lLnksdGhpc31tdWx0aXBseSh0KXtyZXR1cm4gdGhpcy54Kj10LngsdGhpcy55Kj10LnksdGhpc31tdWx0aXBseVNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzfWRpdmlkZSh0KXtyZXR1cm4gdGhpcy54Lz10LngsdGhpcy55Lz10LnksdGhpc31kaXZpZGVTY2FsYXIodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS90KX1hcHBseU1hdHJpeDModCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksaT10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9aVswXSplK2lbM10qcytpWzZdLHRoaXMueT1pWzFdKmUraVs0XSpzK2lbN10sdGhpc31taW4odCl7cmV0dXJuIHRoaXMueD1NYXRoLm1pbih0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQueSksdGhpc31tYXgodCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LHQueSksdGhpc31jbGFtcCh0LGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodC54LE1hdGgubWluKGUueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodC55LE1hdGgubWluKGUueSx0aGlzLnkpKSx0aGlzfWNsYW1wU2NhbGFyKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLnkpKSx0aGlzfWNsYW1wTGVuZ3RoKHQsZSl7Y29uc3Qgcz10aGlzLmxlbmd0aCgpO3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcihzfHwxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heCh0LE1hdGgubWluKGUscykpKX1mbG9vcigpe3JldHVybiB0aGlzLng9TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT1NYXRoLmZsb29yKHRoaXMueSksdGhpc31jZWlsKCl7cmV0dXJuIHRoaXMueD1NYXRoLmNlaWwodGhpcy54KSx0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSksdGhpc31yb3VuZCgpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueSksdGhpc31yb3VuZFRvWmVybygpe3JldHVybiB0aGlzLng9dGhpcy54PDA/TWF0aC5jZWlsKHRoaXMueCk6TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT10aGlzLnk8MD9NYXRoLmNlaWwodGhpcy55KTpNYXRoLmZsb29yKHRoaXMueSksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpc31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueX1jcm9zcyh0KXtyZXR1cm4gdGhpcy54KnQueS10aGlzLnkqdC54fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueX1sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9bWFuaGF0dGFuTGVuZ3RoKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueCkrTWF0aC5hYnModGhpcy55KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9YW5nbGUoKXtyZXR1cm4gTWF0aC5hdGFuMigtdGhpcy55LC10aGlzLngpK01hdGguUEl9YW5nbGVUbyh0KXtjb25zdCBlPU1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkqdC5sZW5ndGhTcSgpKTtpZihlPT09MClyZXR1cm4gTWF0aC5QSS8yO2NvbnN0IHM9dGhpcy5kb3QodCkvZTtyZXR1cm4gTWF0aC5hY29zKE4ocywtMSwxKSl9ZGlzdGFuY2VUbyh0KXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodCkpfWRpc3RhbmNlVG9TcXVhcmVkKHQpe2NvbnN0IGU9dGhpcy54LXQueCxzPXRoaXMueS10Lnk7cmV0dXJuIGUqZStzKnN9bWFuaGF0dGFuRGlzdGFuY2VUbyh0KXtyZXR1cm4gTWF0aC5hYnModGhpcy54LXQueCkrTWF0aC5hYnModGhpcy55LXQueSl9c2V0TGVuZ3RoKHQpe3JldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHQpfWxlcnAodCxlKXtyZXR1cm4gdGhpcy54Kz0odC54LXRoaXMueCkqZSx0aGlzLnkrPSh0LnktdGhpcy55KSplLHRoaXN9bGVycFZlY3RvcnModCxlLHMpe3JldHVybiB0aGlzLng9dC54KyhlLngtdC54KSpzLHRoaXMueT10LnkrKGUueS10LnkpKnMsdGhpc31lcXVhbHModCl7cmV0dXJuIHQueD09PXRoaXMueCYmdC55PT09dGhpcy55fWZyb21BcnJheSh0LGU9MCl7cmV0dXJuIHRoaXMueD10W2VdLHRoaXMueT10W2UrMV0sdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLngsdFtlKzFdPXRoaXMueSx0fWZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKXtyZXR1cm4gdGhpcy54PXQuZ2V0WChlKSx0aGlzLnk9dC5nZXRZKGUpLHRoaXN9cm90YXRlQXJvdW5kKHQsZSl7Y29uc3Qgcz1NYXRoLmNvcyhlKSxpPU1hdGguc2luKGUpLG49dGhpcy54LXQueCxhPXRoaXMueS10Lnk7cmV0dXJuIHRoaXMueD1uKnMtYSppK3QueCx0aGlzLnk9bippK2Eqcyt0LnksdGhpc31yYW5kb20oKXtyZXR1cm4gdGhpcy54PU1hdGgucmFuZG9tKCksdGhpcy55PU1hdGgucmFuZG9tKCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55fX1jbGFzcyBodHtjb25zdHJ1Y3Rvcih0LGUscyxpLG4sYSxvLGgsbCl7aHQucHJvdG90eXBlLmlzTWF0cml4Mz0hMCx0aGlzLmVsZW1lbnRzPVsxLDAsMCwwLDEsMCwwLDAsMV0sdCE9PXZvaWQgMCYmdGhpcy5zZXQodCxlLHMsaSxuLGEsbyxoLGwpfXNldCh0LGUscyxpLG4sYSxvLGgsbCl7Y29uc3QgYz10aGlzLmVsZW1lbnRzO3JldHVybiBjWzBdPXQsY1sxXT1pLGNbMl09byxjWzNdPWUsY1s0XT1uLGNbNV09aCxjWzZdPXMsY1s3XT1hLGNbOF09bCx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDEsMCwwLDAsMSwwLDAsMCwxKSx0aGlzfWNvcHkodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHM9dC5lbGVtZW50cztyZXR1cm4gZVswXT1zWzBdLGVbMV09c1sxXSxlWzJdPXNbMl0sZVszXT1zWzNdLGVbNF09c1s0XSxlWzVdPXNbNV0sZVs2XT1zWzZdLGVbN109c1s3XSxlWzhdPXNbOF0sdGhpc31leHRyYWN0QmFzaXModCxlLHMpe3JldHVybiB0LnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsMCksZS5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLDEpLHMuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywyKSx0aGlzfXNldEZyb21NYXRyaXg0KHQpe2NvbnN0IGU9dC5lbGVtZW50cztyZXR1cm4gdGhpcy5zZXQoZVswXSxlWzRdLGVbOF0sZVsxXSxlWzVdLGVbOV0sZVsyXSxlWzZdLGVbMTBdKSx0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcyx0KX1wcmVtdWx0aXBseSh0KXtyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsdGhpcyl9bXVsdGlwbHlNYXRyaWNlcyh0LGUpe2NvbnN0IHM9dC5lbGVtZW50cyxpPWUuZWxlbWVudHMsbj10aGlzLmVsZW1lbnRzLGE9c1swXSxvPXNbM10saD1zWzZdLGw9c1sxXSxjPXNbNF0sdT1zWzddLG09c1syXSxkPXNbNV0sZj1zWzhdLHk9aVswXSx4PWlbM10scD1pWzZdLEY9aVsxXSxTPWlbNF0sdz1pWzddLF89aVsyXSxrPWlbNV0sTT1pWzhdO3JldHVybiBuWzBdPWEqeStvKkYraCpfLG5bM109YSp4K28qUytoKmssbls2XT1hKnArbyp3K2gqTSxuWzFdPWwqeStjKkYrdSpfLG5bNF09bCp4K2MqUyt1Kmssbls3XT1sKnArYyp3K3UqTSxuWzJdPW0qeStkKkYrZipfLG5bNV09bSp4K2QqUytmKmssbls4XT1tKnArZCp3K2YqTSx0aGlzfW11bHRpcGx5U2NhbGFyKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cztyZXR1cm4gZVswXSo9dCxlWzNdKj10LGVbNl0qPXQsZVsxXSo9dCxlWzRdKj10LGVbN10qPXQsZVsyXSo9dCxlWzVdKj10LGVbOF0qPXQsdGhpc31kZXRlcm1pbmFudCgpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxlPXRbMF0scz10WzFdLGk9dFsyXSxuPXRbM10sYT10WzRdLG89dFs1XSxoPXRbNl0sbD10WzddLGM9dFs4XTtyZXR1cm4gZSphKmMtZSpvKmwtcypuKmMrcypvKmgraSpuKmwtaSphKmh9aW52ZXJ0KCl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGU9dFswXSxzPXRbMV0saT10WzJdLG49dFszXSxhPXRbNF0sbz10WzVdLGg9dFs2XSxsPXRbN10sYz10WzhdLHU9YyphLW8qbCxtPW8qaC1jKm4sZD1sKm4tYSpoLGY9ZSp1K3MqbStpKmQ7aWYoZj09PTApcmV0dXJuIHRoaXMuc2V0KDAsMCwwLDAsMCwwLDAsMCwwKTtjb25zdCB5PTEvZjtyZXR1cm4gdFswXT11KnksdFsxXT0oaSpsLWMqcykqeSx0WzJdPShvKnMtaSphKSp5LHRbM109bSp5LHRbNF09KGMqZS1pKmgpKnksdFs1XT0oaSpuLW8qZSkqeSx0WzZdPWQqeSx0WzddPShzKmgtbCplKSp5LHRbOF09KGEqZS1zKm4pKnksdGhpc310cmFuc3Bvc2UoKXtsZXQgdDtjb25zdCBlPXRoaXMuZWxlbWVudHM7cmV0dXJuIHQ9ZVsxXSxlWzFdPWVbM10sZVszXT10LHQ9ZVsyXSxlWzJdPWVbNl0sZVs2XT10LHQ9ZVs1XSxlWzVdPWVbN10sZVs3XT10LHRoaXN9Z2V0Tm9ybWFsTWF0cml4KHQpe3JldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KHQpLmludmVydCgpLnRyYW5zcG9zZSgpfXRyYW5zcG9zZUludG9BcnJheSh0KXtjb25zdCBlPXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbM10sdFsyXT1lWzZdLHRbM109ZVsxXSx0WzRdPWVbNF0sdFs1XT1lWzddLHRbNl09ZVsyXSx0WzddPWVbNV0sdFs4XT1lWzhdLHRoaXN9c2V0VXZUcmFuc2Zvcm0odCxlLHMsaSxuLGEsbyl7Y29uc3QgaD1NYXRoLmNvcyhuKSxsPU1hdGguc2luKG4pO3JldHVybiB0aGlzLnNldChzKmgscypsLC1zKihoKmErbCpvKSthK3QsLWkqbCxpKmgsLWkqKC1sKmEraCpvKStvK2UsMCwwLDEpLHRoaXN9c2NhbGUodCxlKXtyZXR1cm4gdGhpcy5wcmVtdWx0aXBseShtZS5tYWtlU2NhbGUodCxlKSksdGhpc31yb3RhdGUodCl7cmV0dXJuIHRoaXMucHJlbXVsdGlwbHkobWUubWFrZVJvdGF0aW9uKC10KSksdGhpc310cmFuc2xhdGUodCxlKXtyZXR1cm4gdGhpcy5wcmVtdWx0aXBseShtZS5tYWtlVHJhbnNsYXRpb24odCxlKSksdGhpc31tYWtlVHJhbnNsYXRpb24odCxlKXtyZXR1cm4gdC5pc1ZlY3RvcjI/dGhpcy5zZXQoMSwwLHQueCwwLDEsdC55LDAsMCwxKTp0aGlzLnNldCgxLDAsdCwwLDEsZSwwLDAsMSksdGhpc31tYWtlUm90YXRpb24odCl7Y29uc3QgZT1NYXRoLmNvcyh0KSxzPU1hdGguc2luKHQpO3JldHVybiB0aGlzLnNldChlLC1zLDAscyxlLDAsMCwwLDEpLHRoaXN9bWFrZVNjYWxlKHQsZSl7cmV0dXJuIHRoaXMuc2V0KHQsMCwwLDAsZSwwLDAsMCwxKSx0aGlzfWVxdWFscyh0KXtjb25zdCBlPXRoaXMuZWxlbWVudHMscz10LmVsZW1lbnRzO2ZvcihsZXQgaT0wO2k8OTtpKyspaWYoZVtpXSE9PXNbaV0pcmV0dXJuITE7cmV0dXJuITB9ZnJvbUFycmF5KHQsZT0wKXtmb3IobGV0IHM9MDtzPDk7cysrKXRoaXMuZWxlbWVudHNbc109dFtzK2VdO3JldHVybiB0aGlzfXRvQXJyYXkodD1bXSxlPTApe2NvbnN0IHM9dGhpcy5lbGVtZW50cztyZXR1cm4gdFtlXT1zWzBdLHRbZSsxXT1zWzFdLHRbZSsyXT1zWzJdLHRbZSszXT1zWzNdLHRbZSs0XT1zWzRdLHRbZSs1XT1zWzVdLHRbZSs2XT1zWzZdLHRbZSs3XT1zWzddLHRbZSs4XT1zWzhdLHR9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyl9fWNvbnN0IG1lPW5ldyBodDtmdW5jdGlvbiBPcyhyKXtmb3IobGV0IHQ9ci5sZW5ndGgtMTt0Pj0wOy0tdClpZihyW3RdPj02NTUzNSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBIZShyKXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIixyKX1jb25zdCBXZT17fTtmdW5jdGlvbiBmZShyKXtyIGluIFdlfHwoV2Vbcl09ITAsY29uc29sZS53YXJuKHIpKX1mdW5jdGlvbiB3dChyKXtyZXR1cm4gcjwuMDQwNDU/ciouMDc3Mzk5MzgwODpNYXRoLnBvdyhyKi45NDc4NjcyOTg2Ky4wNTIxMzI3MDE0LDIuNCl9ZnVuY3Rpb24geWUocil7cmV0dXJuIHI8LjAwMzEzMDg/cioxMi45MjoxLjA1NSpNYXRoLnBvdyhyLC40MTY2NiktLjA1NX1jb25zdCBVcz1uZXcgaHQoKS5mcm9tQXJyYXkoWy44MjI0NjIxLC4wMzMxOTQxLC4wMTcwODI3LC4xNzc1MzgsLjk2NjgwNTgsLjA3MjM5NzQsLTFlLTcsMWUtNywuOTEwNTE5OV0pLHFzPW5ldyBodCgpLmZyb21BcnJheShbMS4yMjQ5NDAxLC0uMDQyMDU2OSwtLjAxOTYzNzYsLS4yMjQ5NDA0LDEuMDQyMDU3MSwtLjA3ODYzNjEsMWUtNywwLDEuMDk4MjczNV0pO2Z1bmN0aW9uIE5zKHIpe3JldHVybiByLmNvbnZlcnRTUkdCVG9MaW5lYXIoKS5hcHBseU1hdHJpeDMocXMpfWZ1bmN0aW9uIEhzKHIpe3JldHVybiByLmFwcGx5TWF0cml4MyhVcykuY29udmVydExpbmVhclRvU1JHQigpfWNvbnN0IFdzPXtbY2VdOnI9PnIsW0ddOnI9PnIuY29udmVydFNSR0JUb0xpbmVhcigpLFtVZV06TnN9LCRzPXtbY2VdOnI9PnIsW0ddOnI9PnIuY29udmVydExpbmVhclRvU1JHQigpLFtVZV06SHN9LGo9e2VuYWJsZWQ6ITAsZ2V0IGxlZ2FjeU1vZGUoKXtyZXR1cm4gY29uc29sZS53YXJuKCJUSFJFRS5Db2xvck1hbmFnZW1lbnQ6IC5sZWdhY3lNb2RlPWZhbHNlIHJlbmFtZWQgdG8gLmVuYWJsZWQ9dHJ1ZSBpbiByMTUwLiIpLCF0aGlzLmVuYWJsZWR9LHNldCBsZWdhY3lNb2RlKHIpe2NvbnNvbGUud2FybigiVEhSRUUuQ29sb3JNYW5hZ2VtZW50OiAubGVnYWN5TW9kZT1mYWxzZSByZW5hbWVkIHRvIC5lbmFibGVkPXRydWUgaW4gcjE1MC4iKSx0aGlzLmVuYWJsZWQ9IXJ9LGdldCB3b3JraW5nQ29sb3JTcGFjZSgpe3JldHVybiBjZX0sc2V0IHdvcmtpbmdDb2xvclNwYWNlKHIpe2NvbnNvbGUud2FybigiVEhSRUUuQ29sb3JNYW5hZ2VtZW50OiAud29ya2luZ0NvbG9yU3BhY2UgaXMgcmVhZG9ubHkuIil9LGNvbnZlcnQ6ZnVuY3Rpb24ocix0LGUpe2lmKHRoaXMuZW5hYmxlZD09PSExfHx0PT09ZXx8IXR8fCFlKXJldHVybiByO2NvbnN0IHM9V3NbdF0saT0kc1tlXTtpZihzPT09dm9pZCAwfHxpPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29sb3Igc3BhY2UgY29udmVyc2lvbiwgIiR7dH0iIHRvICIke2V9Ii5gKTtyZXR1cm4gaShzKHIpKX0sZnJvbVdvcmtpbmdDb2xvclNwYWNlOmZ1bmN0aW9uKHIsdCl7cmV0dXJuIHRoaXMuY29udmVydChyLHRoaXMud29ya2luZ0NvbG9yU3BhY2UsdCl9LHRvV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdGhpcy5jb252ZXJ0KHIsdCx0aGlzLndvcmtpbmdDb2xvclNwYWNlKX19O2xldCBfdDtjbGFzcyBWc3tzdGF0aWMgZ2V0RGF0YVVSTCh0KXtpZigvXmRhdGE6L2kudGVzdCh0LnNyYyl8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudD4idSIpcmV0dXJuIHQuc3JjO2xldCBlO2lmKHQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCllPXQ7ZWxzZXtfdD09PXZvaWQgMCYmKF90PUhlKCJjYW52YXMiKSksX3Qud2lkdGg9dC53aWR0aCxfdC5oZWlnaHQ9dC5oZWlnaHQ7Y29uc3Qgcz1fdC5nZXRDb250ZXh0KCIyZCIpO3QgaW5zdGFuY2VvZiBJbWFnZURhdGE/cy5wdXRJbWFnZURhdGEodCwwLDApOnMuZHJhd0ltYWdlKHQsMCwwLHQud2lkdGgsdC5oZWlnaHQpLGU9X3R9cmV0dXJuIGUud2lkdGg+MjA0OHx8ZS5oZWlnaHQ+MjA0OD8oY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMiLHQpLGUudG9EYXRhVVJMKCJpbWFnZS9qcGVnIiwuNikpOmUudG9EYXRhVVJMKCJpbWFnZS9wbmciKX1zdGF0aWMgc1JHQlRvTGluZWFyKHQpe2lmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmdCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXtjb25zdCBlPUhlKCJjYW52YXMiKTtlLndpZHRoPXQud2lkdGgsZS5oZWlnaHQ9dC5oZWlnaHQ7Y29uc3Qgcz1lLmdldENvbnRleHQoIjJkIik7cy5kcmF3SW1hZ2UodCwwLDAsdC53aWR0aCx0LmhlaWdodCk7Y29uc3QgaT1zLmdldEltYWdlRGF0YSgwLDAsdC53aWR0aCx0LmhlaWdodCksbj1pLmRhdGE7Zm9yKGxldCBhPTA7YTxuLmxlbmd0aDthKyspblthXT13dChuW2FdLzI1NSkqMjU1O3JldHVybiBzLnB1dEltYWdlRGF0YShpLDAsMCksZX1lbHNlIGlmKHQuZGF0YSl7Y29uc3QgZT10LmRhdGEuc2xpY2UoMCk7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheT9lW3NdPU1hdGguZmxvb3Iod3QoZVtzXS8yNTUpKjI1NSk6ZVtzXT13dChlW3NdKTtyZXR1cm57ZGF0YTplLHdpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0fX1lbHNlIHJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4iKSx0fX1sZXQgWXM9MDtjbGFzcyBYc3tjb25zdHJ1Y3Rvcih0PW51bGwpe3RoaXMuaXNTb3VyY2U9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6WXMrK30pLHRoaXMudXVpZD1WdCgpLHRoaXMuZGF0YT10LHRoaXMudmVyc2lvbj0wfXNldCBuZWVkc1VwZGF0ZSh0KXt0PT09ITAmJnRoaXMudmVyc2lvbisrfXRvSlNPTih0KXtjb25zdCBlPXQ9PT12b2lkIDB8fHR5cGVvZiB0PT0ic3RyaW5nIjtpZighZSYmdC5pbWFnZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gdC5pbWFnZXNbdGhpcy51dWlkXTtjb25zdCBzPXt1dWlkOnRoaXMudXVpZCx1cmw6IiJ9LGk9dGhpcy5kYXRhO2lmKGkhPT1udWxsKXtsZXQgbjtpZihBcnJheS5pc0FycmF5KGkpKXtuPVtdO2ZvcihsZXQgYT0wLG89aS5sZW5ndGg7YTxvO2ErKylpW2FdLmlzRGF0YVRleHR1cmU/bi5wdXNoKHhlKGlbYV0uaW1hZ2UpKTpuLnB1c2goeGUoaVthXSkpfWVsc2Ugbj14ZShpKTtzLnVybD1ufXJldHVybiBlfHwodC5pbWFnZXNbdGhpcy51dWlkXT1zKSxzfX1mdW5jdGlvbiB4ZShyKXtyZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZyIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PCJ1IiYmciBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0eXBlb2YgSW1hZ2VCaXRtYXA8InUiJiZyIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA/VnMuZ2V0RGF0YVVSTChyKTpyLmRhdGE/e2RhdGE6QXJyYXkuZnJvbShyLmRhdGEpLHdpZHRoOnIud2lkdGgsaGVpZ2h0OnIuaGVpZ2h0LHR5cGU6ci5kYXRhLmNvbnN0cnVjdG9yLm5hbWV9Oihjb25zb2xlLndhcm4oIlRIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4iKSx7fSl9bGV0IEdzPTA7Y2xhc3MgeXQgZXh0ZW5kcyB1ZXtjb25zdHJ1Y3Rvcih0PXl0LkRFRkFVTFRfSU1BR0UsZT15dC5ERUZBVUxUX01BUFBJTkcscz1XdCxpPVd0LG49dnMsYT1EcyxvPUxzLGg9VHMsbD15dC5ERUZBVUxUX0FOSVNPVFJPUFksYz1sZSl7c3VwZXIoKSx0aGlzLmlzVGV4dHVyZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTpHcysrfSksdGhpcy51dWlkPVZ0KCksdGhpcy5uYW1lPSIiLHRoaXMuc291cmNlPW5ldyBYcyh0KSx0aGlzLm1pcG1hcHM9W10sdGhpcy5tYXBwaW5nPWUsdGhpcy5jaGFubmVsPTAsdGhpcy53cmFwUz1zLHRoaXMud3JhcFQ9aSx0aGlzLm1hZ0ZpbHRlcj1uLHRoaXMubWluRmlsdGVyPWEsdGhpcy5hbmlzb3Ryb3B5PWwsdGhpcy5mb3JtYXQ9byx0aGlzLmludGVybmFsRm9ybWF0PW51bGwsdGhpcy50eXBlPWgsdGhpcy5vZmZzZXQ9bmV3IGV0KDAsMCksdGhpcy5yZXBlYXQ9bmV3IGV0KDEsMSksdGhpcy5jZW50ZXI9bmV3IGV0KDAsMCksdGhpcy5yb3RhdGlvbj0wLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMCx0aGlzLm1hdHJpeD1uZXcgaHQsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITAsdGhpcy5wcmVtdWx0aXBseUFscGhhPSExLHRoaXMuZmxpcFk9ITAsdGhpcy51bnBhY2tBbGlnbm1lbnQ9NCx0eXBlb2YgYz09InN0cmluZyI/dGhpcy5jb2xvclNwYWNlPWM6KGZlKCJUSFJFRS5UZXh0dXJlOiBQcm9wZXJ0eSAuZW5jb2RpbmcgaGFzIGJlZW4gcmVwbGFjZWQgYnkgLmNvbG9yU3BhY2UuIiksdGhpcy5jb2xvclNwYWNlPWM9PT1oZT9HOmxlKSx0aGlzLnVzZXJEYXRhPXt9LHRoaXMudmVyc2lvbj0wLHRoaXMub25VcGRhdGU9bnVsbCx0aGlzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMSx0aGlzLm5lZWRzUE1SRU1VcGRhdGU9ITF9Z2V0IGltYWdlKCl7cmV0dXJuIHRoaXMuc291cmNlLmRhdGF9c2V0IGltYWdlKHQ9bnVsbCl7dGhpcy5zb3VyY2UuZGF0YT10fXVwZGF0ZU1hdHJpeCgpe3RoaXMubWF0cml4LnNldFV2VHJhbnNmb3JtKHRoaXMub2Zmc2V0LngsdGhpcy5vZmZzZXQueSx0aGlzLnJlcGVhdC54LHRoaXMucmVwZWF0LnksdGhpcy5yb3RhdGlvbix0aGlzLmNlbnRlci54LHRoaXMuY2VudGVyLnkpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KHQpe3JldHVybiB0aGlzLm5hbWU9dC5uYW1lLHRoaXMuc291cmNlPXQuc291cmNlLHRoaXMubWlwbWFwcz10Lm1pcG1hcHMuc2xpY2UoMCksdGhpcy5tYXBwaW5nPXQubWFwcGluZyx0aGlzLmNoYW5uZWw9dC5jaGFubmVsLHRoaXMud3JhcFM9dC53cmFwUyx0aGlzLndyYXBUPXQud3JhcFQsdGhpcy5tYWdGaWx0ZXI9dC5tYWdGaWx0ZXIsdGhpcy5taW5GaWx0ZXI9dC5taW5GaWx0ZXIsdGhpcy5hbmlzb3Ryb3B5PXQuYW5pc290cm9weSx0aGlzLmZvcm1hdD10LmZvcm1hdCx0aGlzLmludGVybmFsRm9ybWF0PXQuaW50ZXJuYWxGb3JtYXQsdGhpcy50eXBlPXQudHlwZSx0aGlzLm9mZnNldC5jb3B5KHQub2Zmc2V0KSx0aGlzLnJlcGVhdC5jb3B5KHQucmVwZWF0KSx0aGlzLmNlbnRlci5jb3B5KHQuY2VudGVyKSx0aGlzLnJvdGF0aW9uPXQucm90YXRpb24sdGhpcy5tYXRyaXhBdXRvVXBkYXRlPXQubWF0cml4QXV0b1VwZGF0ZSx0aGlzLm1hdHJpeC5jb3B5KHQubWF0cml4KSx0aGlzLmdlbmVyYXRlTWlwbWFwcz10LmdlbmVyYXRlTWlwbWFwcyx0aGlzLnByZW11bHRpcGx5QWxwaGE9dC5wcmVtdWx0aXBseUFscGhhLHRoaXMuZmxpcFk9dC5mbGlwWSx0aGlzLnVucGFja0FsaWdubWVudD10LnVucGFja0FsaWdubWVudCx0aGlzLmNvbG9yU3BhY2U9dC5jb2xvclNwYWNlLHRoaXMudXNlckRhdGE9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0LnVzZXJEYXRhKSksdGhpcy5uZWVkc1VwZGF0ZT0hMCx0aGlzfXRvSlNPTih0KXtjb25zdCBlPXQ9PT12b2lkIDB8fHR5cGVvZiB0PT0ic3RyaW5nIjtpZighZSYmdC50ZXh0dXJlc1t0aGlzLnV1aWRdIT09dm9pZCAwKXJldHVybiB0LnRleHR1cmVzW3RoaXMudXVpZF07Y29uc3Qgcz17bWV0YWRhdGE6e3ZlcnNpb246NC42LHR5cGU6IlRleHR1cmUiLGdlbmVyYXRvcjoiVGV4dHVyZS50b0pTT04ifSx1dWlkOnRoaXMudXVpZCxuYW1lOnRoaXMubmFtZSxpbWFnZTp0aGlzLnNvdXJjZS50b0pTT04odCkudXVpZCxtYXBwaW5nOnRoaXMubWFwcGluZyxjaGFubmVsOnRoaXMuY2hhbm5lbCxyZXBlYXQ6W3RoaXMucmVwZWF0LngsdGhpcy5yZXBlYXQueV0sb2Zmc2V0Olt0aGlzLm9mZnNldC54LHRoaXMub2Zmc2V0LnldLGNlbnRlcjpbdGhpcy5jZW50ZXIueCx0aGlzLmNlbnRlci55XSxyb3RhdGlvbjp0aGlzLnJvdGF0aW9uLHdyYXA6W3RoaXMud3JhcFMsdGhpcy53cmFwVF0sZm9ybWF0OnRoaXMuZm9ybWF0LGludGVybmFsRm9ybWF0OnRoaXMuaW50ZXJuYWxGb3JtYXQsdHlwZTp0aGlzLnR5cGUsY29sb3JTcGFjZTp0aGlzLmNvbG9yU3BhY2UsbWluRmlsdGVyOnRoaXMubWluRmlsdGVyLG1hZ0ZpbHRlcjp0aGlzLm1hZ0ZpbHRlcixhbmlzb3Ryb3B5OnRoaXMuYW5pc290cm9weSxmbGlwWTp0aGlzLmZsaXBZLGdlbmVyYXRlTWlwbWFwczp0aGlzLmdlbmVyYXRlTWlwbWFwcyxwcmVtdWx0aXBseUFscGhhOnRoaXMucHJlbXVsdGlwbHlBbHBoYSx1bnBhY2tBbGlnbm1lbnQ6dGhpcy51bnBhY2tBbGlnbm1lbnR9O3JldHVybiBPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKHMudXNlckRhdGE9dGhpcy51c2VyRGF0YSksZXx8KHQudGV4dHVyZXNbdGhpcy51dWlkXT1zKSxzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9dHJhbnNmb3JtVXYodCl7aWYodGhpcy5tYXBwaW5nIT09SWUpcmV0dXJuIHQ7aWYodC5hcHBseU1hdHJpeDModGhpcy5tYXRyaXgpLHQueDwwfHx0Lng+MSlzd2l0Y2godGhpcy53cmFwUyl7Y2FzZSBQZTp0Lng9dC54LU1hdGguZmxvb3IodC54KTticmVhaztjYXNlIFd0OnQueD10Lng8MD8wOjE7YnJlYWs7Y2FzZSBPZTpNYXRoLmFicyhNYXRoLmZsb29yKHQueCklMik9PT0xP3QueD1NYXRoLmNlaWwodC54KS10Lng6dC54PXQueC1NYXRoLmZsb29yKHQueCk7YnJlYWt9aWYodC55PDB8fHQueT4xKXN3aXRjaCh0aGlzLndyYXBUKXtjYXNlIFBlOnQueT10LnktTWF0aC5mbG9vcih0LnkpO2JyZWFrO2Nhc2UgV3Q6dC55PXQueTwwPzA6MTticmVhaztjYXNlIE9lOk1hdGguYWJzKE1hdGguZmxvb3IodC55KSUyKT09PTE/dC55PU1hdGguY2VpbCh0LnkpLXQueTp0Lnk9dC55LU1hdGguZmxvb3IodC55KTticmVha31yZXR1cm4gdGhpcy5mbGlwWSYmKHQueT0xLXQueSksdH1zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiYodGhpcy52ZXJzaW9uKyssdGhpcy5zb3VyY2UubmVlZHNVcGRhdGU9ITApfWdldCBlbmNvZGluZygpe3JldHVybiBmZSgiVEhSRUUuVGV4dHVyZTogUHJvcGVydHkgLmVuY29kaW5nIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IC5jb2xvclNwYWNlLiIpLHRoaXMuY29sb3JTcGFjZT09PUc/aGU6SXN9c2V0IGVuY29kaW5nKHQpe2ZlKCJUSFJFRS5UZXh0dXJlOiBQcm9wZXJ0eSAuZW5jb2RpbmcgaGFzIGJlZW4gcmVwbGFjZWQgYnkgLmNvbG9yU3BhY2UuIiksdGhpcy5jb2xvclNwYWNlPXQ9PT1oZT9HOmxlfX15dC5ERUZBVUxUX0lNQUdFPW51bGwseXQuREVGQVVMVF9NQVBQSU5HPUllLHl0LkRFRkFVTFRfQU5JU09UUk9QWT0xO2NsYXNzIFR0e2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wLGk9MSl7dGhpcy5pc1F1YXRlcm5pb249ITAsdGhpcy5feD10LHRoaXMuX3k9ZSx0aGlzLl96PXMsdGhpcy5fdz1pfXN0YXRpYyBzbGVycEZsYXQodCxlLHMsaSxuLGEsbyl7bGV0IGg9c1tpKzBdLGw9c1tpKzFdLGM9c1tpKzJdLHU9c1tpKzNdO2NvbnN0IG09blthKzBdLGQ9blthKzFdLGY9blthKzJdLHk9blthKzNdO2lmKG89PT0wKXt0W2UrMF09aCx0W2UrMV09bCx0W2UrMl09Yyx0W2UrM109dTtyZXR1cm59aWYobz09PTEpe3RbZSswXT1tLHRbZSsxXT1kLHRbZSsyXT1mLHRbZSszXT15O3JldHVybn1pZih1IT09eXx8aCE9PW18fGwhPT1kfHxjIT09Zil7bGV0IHg9MS1vO2NvbnN0IHA9aCptK2wqZCtjKmYrdSp5LEY9cD49MD8xOi0xLFM9MS1wKnA7aWYoUz5OdW1iZXIuRVBTSUxPTil7Y29uc3QgXz1NYXRoLnNxcnQoUyksaz1NYXRoLmF0YW4yKF8scCpGKTt4PU1hdGguc2luKHgqaykvXyxvPU1hdGguc2luKG8qaykvX31jb25zdCB3PW8qRjtpZihoPWgqeCttKncsbD1sKngrZCp3LGM9Yyp4K2Yqdyx1PXUqeCt5KncseD09PTEtbyl7Y29uc3QgXz0xL01hdGguc3FydChoKmgrbCpsK2MqYyt1KnUpO2gqPV8sbCo9XyxjKj1fLHUqPV99fXRbZV09aCx0W2UrMV09bCx0W2UrMl09Yyx0W2UrM109dX1zdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQodCxlLHMsaSxuLGEpe2NvbnN0IG89c1tpXSxoPXNbaSsxXSxsPXNbaSsyXSxjPXNbaSszXSx1PW5bYV0sbT1uW2ErMV0sZD1uW2ErMl0sZj1uW2ErM107cmV0dXJuIHRbZV09bypmK2MqdStoKmQtbCptLHRbZSsxXT1oKmYrYyptK2wqdS1vKmQsdFtlKzJdPWwqZitjKmQrbyptLWgqdSx0W2UrM109YypmLW8qdS1oKm0tbCpkLHR9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1zZXQgeCh0KXt0aGlzLl94PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9c2V0IHkodCl7dGhpcy5feT10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeigpe3JldHVybiB0aGlzLl96fXNldCB6KHQpe3RoaXMuX3o9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHcoKXtyZXR1cm4gdGhpcy5fd31zZXQgdyh0KXt0aGlzLl93PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldCh0LGUscyxpKXtyZXR1cm4gdGhpcy5feD10LHRoaXMuX3k9ZSx0aGlzLl96PXMsdGhpcy5fdz1pLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsdGhpcy5feSx0aGlzLl96LHRoaXMuX3cpfWNvcHkodCl7cmV0dXJuIHRoaXMuX3g9dC54LHRoaXMuX3k9dC55LHRoaXMuX3o9dC56LHRoaXMuX3c9dC53LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21FdWxlcih0LGUpe2NvbnN0IHM9dC5feCxpPXQuX3ksbj10Ll96LGE9dC5fb3JkZXIsbz1NYXRoLmNvcyxoPU1hdGguc2luLGw9byhzLzIpLGM9byhpLzIpLHU9byhuLzIpLG09aChzLzIpLGQ9aChpLzIpLGY9aChuLzIpO3N3aXRjaChhKXtjYXNlIlhZWiI6dGhpcy5feD1tKmMqdStsKmQqZix0aGlzLl95PWwqZCp1LW0qYypmLHRoaXMuX3o9bCpjKmYrbSpkKnUsdGhpcy5fdz1sKmMqdS1tKmQqZjticmVhaztjYXNlIllYWiI6dGhpcy5feD1tKmMqdStsKmQqZix0aGlzLl95PWwqZCp1LW0qYypmLHRoaXMuX3o9bCpjKmYtbSpkKnUsdGhpcy5fdz1sKmMqdSttKmQqZjticmVhaztjYXNlIlpYWSI6dGhpcy5feD1tKmMqdS1sKmQqZix0aGlzLl95PWwqZCp1K20qYypmLHRoaXMuX3o9bCpjKmYrbSpkKnUsdGhpcy5fdz1sKmMqdS1tKmQqZjticmVhaztjYXNlIlpZWCI6dGhpcy5feD1tKmMqdS1sKmQqZix0aGlzLl95PWwqZCp1K20qYypmLHRoaXMuX3o9bCpjKmYtbSpkKnUsdGhpcy5fdz1sKmMqdSttKmQqZjticmVhaztjYXNlIllaWCI6dGhpcy5feD1tKmMqdStsKmQqZix0aGlzLl95PWwqZCp1K20qYypmLHRoaXMuX3o9bCpjKmYtbSpkKnUsdGhpcy5fdz1sKmMqdS1tKmQqZjticmVhaztjYXNlIlhaWSI6dGhpcy5feD1tKmMqdS1sKmQqZix0aGlzLl95PWwqZCp1LW0qYypmLHRoaXMuX3o9bCpjKmYrbSpkKnUsdGhpcy5fdz1sKmMqdSttKmQqZjticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrYSl9cmV0dXJuIGUhPT0hMSYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUF4aXNBbmdsZSh0LGUpe2NvbnN0IHM9ZS8yLGk9TWF0aC5zaW4ocyk7cmV0dXJuIHRoaXMuX3g9dC54KmksdGhpcy5feT10LnkqaSx0aGlzLl96PXQueippLHRoaXMuX3c9TWF0aC5jb3MocyksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KHQpe2NvbnN0IGU9dC5lbGVtZW50cyxzPWVbMF0saT1lWzRdLG49ZVs4XSxhPWVbMV0sbz1lWzVdLGg9ZVs5XSxsPWVbMl0sYz1lWzZdLHU9ZVsxMF0sbT1zK28rdTtpZihtPjApe2NvbnN0IGQ9LjUvTWF0aC5zcXJ0KG0rMSk7dGhpcy5fdz0uMjUvZCx0aGlzLl94PShjLWgpKmQsdGhpcy5feT0obi1sKSpkLHRoaXMuX3o9KGEtaSkqZH1lbHNlIGlmKHM+byYmcz51KXtjb25zdCBkPTIqTWF0aC5zcXJ0KDErcy1vLXUpO3RoaXMuX3c9KGMtaCkvZCx0aGlzLl94PS4yNSpkLHRoaXMuX3k9KGkrYSkvZCx0aGlzLl96PShuK2wpL2R9ZWxzZSBpZihvPnUpe2NvbnN0IGQ9MipNYXRoLnNxcnQoMStvLXMtdSk7dGhpcy5fdz0obi1sKS9kLHRoaXMuX3g9KGkrYSkvZCx0aGlzLl95PS4yNSpkLHRoaXMuX3o9KGgrYykvZH1lbHNle2NvbnN0IGQ9MipNYXRoLnNxcnQoMSt1LXMtbyk7dGhpcy5fdz0oYS1pKS9kLHRoaXMuX3g9KG4rbCkvZCx0aGlzLl95PShoK2MpL2QsdGhpcy5fej0uMjUqZH1yZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVVuaXRWZWN0b3JzKHQsZSl7bGV0IHM9dC5kb3QoZSkrMTtyZXR1cm4gczxOdW1iZXIuRVBTSUxPTj8ocz0wLE1hdGguYWJzKHQueCk+TWF0aC5hYnModC56KT8odGhpcy5feD0tdC55LHRoaXMuX3k9dC54LHRoaXMuX3o9MCx0aGlzLl93PXMpOih0aGlzLl94PTAsdGhpcy5feT0tdC56LHRoaXMuX3o9dC55LHRoaXMuX3c9cykpOih0aGlzLl94PXQueSplLnotdC56KmUueSx0aGlzLl95PXQueiplLngtdC54KmUueix0aGlzLl96PXQueCplLnktdC55KmUueCx0aGlzLl93PXMpLHRoaXMubm9ybWFsaXplKCl9YW5nbGVUbyh0KXtyZXR1cm4gMipNYXRoLmFjb3MoTWF0aC5hYnMoTih0aGlzLmRvdCh0KSwtMSwxKSkpfXJvdGF0ZVRvd2FyZHModCxlKXtjb25zdCBzPXRoaXMuYW5nbGVUbyh0KTtpZihzPT09MClyZXR1cm4gdGhpcztjb25zdCBpPU1hdGgubWluKDEsZS9zKTtyZXR1cm4gdGhpcy5zbGVycCh0LGkpLHRoaXN9aWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5zZXQoMCwwLDAsMSl9aW52ZXJ0KCl7cmV0dXJuIHRoaXMuY29uanVnYXRlKCl9Y29uanVnYXRlKCl7cmV0dXJuIHRoaXMuX3gqPS0xLHRoaXMuX3kqPS0xLHRoaXMuX3oqPS0xLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWRvdCh0KXtyZXR1cm4gdGhpcy5feCp0Ll94K3RoaXMuX3kqdC5feSt0aGlzLl96KnQuX3ordGhpcy5fdyp0Ll93fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMuX3gqdGhpcy5feCt0aGlzLl95KnRoaXMuX3krdGhpcy5feip0aGlzLl96K3RoaXMuX3cqdGhpcy5fd31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3gqdGhpcy5feCt0aGlzLl95KnRoaXMuX3krdGhpcy5feip0aGlzLl96K3RoaXMuX3cqdGhpcy5fdyl9bm9ybWFsaXplKCl7bGV0IHQ9dGhpcy5sZW5ndGgoKTtyZXR1cm4gdD09PTA/KHRoaXMuX3g9MCx0aGlzLl95PTAsdGhpcy5fej0wLHRoaXMuX3c9MSk6KHQ9MS90LHRoaXMuX3g9dGhpcy5feCp0LHRoaXMuX3k9dGhpcy5feSp0LHRoaXMuX3o9dGhpcy5feip0LHRoaXMuX3c9dGhpcy5fdyp0KSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31tdWx0aXBseSh0KXtyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsdCl9cHJlbXVsdGlwbHkodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0LHRoaXMpfW11bHRpcGx5UXVhdGVybmlvbnModCxlKXtjb25zdCBzPXQuX3gsaT10Ll95LG49dC5feixhPXQuX3csbz1lLl94LGg9ZS5feSxsPWUuX3osYz1lLl93O3JldHVybiB0aGlzLl94PXMqYythKm8raSpsLW4qaCx0aGlzLl95PWkqYythKmgrbipvLXMqbCx0aGlzLl96PW4qYythKmwrcypoLWkqbyx0aGlzLl93PWEqYy1zKm8taSpoLW4qbCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycCh0LGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2lmKGU9PT0xKXJldHVybiB0aGlzLmNvcHkodCk7Y29uc3Qgcz10aGlzLl94LGk9dGhpcy5feSxuPXRoaXMuX3osYT10aGlzLl93O2xldCBvPWEqdC5fdytzKnQuX3graSp0Ll95K24qdC5fejtpZihvPDA/KHRoaXMuX3c9LXQuX3csdGhpcy5feD0tdC5feCx0aGlzLl95PS10Ll95LHRoaXMuX3o9LXQuX3osbz0tbyk6dGhpcy5jb3B5KHQpLG8+PTEpcmV0dXJuIHRoaXMuX3c9YSx0aGlzLl94PXMsdGhpcy5feT1pLHRoaXMuX3o9bix0aGlzO2NvbnN0IGg9MS1vKm87aWYoaDw9TnVtYmVyLkVQU0lMT04pe2NvbnN0IGQ9MS1lO3JldHVybiB0aGlzLl93PWQqYStlKnRoaXMuX3csdGhpcy5feD1kKnMrZSp0aGlzLl94LHRoaXMuX3k9ZCppK2UqdGhpcy5feSx0aGlzLl96PWQqbitlKnRoaXMuX3osdGhpcy5ub3JtYWxpemUoKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31jb25zdCBsPU1hdGguc3FydChoKSxjPU1hdGguYXRhbjIobCxvKSx1PU1hdGguc2luKCgxLWUpKmMpL2wsbT1NYXRoLnNpbihlKmMpL2w7cmV0dXJuIHRoaXMuX3c9YSp1K3RoaXMuX3cqbSx0aGlzLl94PXMqdSt0aGlzLl94Km0sdGhpcy5feT1pKnUrdGhpcy5feSptLHRoaXMuX3o9bip1K3RoaXMuX3oqbSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycFF1YXRlcm5pb25zKHQsZSxzKXtyZXR1cm4gdGhpcy5jb3B5KHQpLnNsZXJwKGUscyl9cmFuZG9tKCl7Y29uc3QgdD1NYXRoLnJhbmRvbSgpLGU9TWF0aC5zcXJ0KDEtdCkscz1NYXRoLnNxcnQodCksaT0yKk1hdGguUEkqTWF0aC5yYW5kb20oKSxuPTIqTWF0aC5QSSpNYXRoLnJhbmRvbSgpO3JldHVybiB0aGlzLnNldChlKk1hdGguY29zKGkpLHMqTWF0aC5zaW4obikscypNYXRoLmNvcyhuKSxlKk1hdGguc2luKGkpKX1lcXVhbHModCl7cmV0dXJuIHQuX3g9PT10aGlzLl94JiZ0Ll95PT09dGhpcy5feSYmdC5fej09PXRoaXMuX3omJnQuX3c9PT10aGlzLl93fWZyb21BcnJheSh0LGU9MCl7cmV0dXJuIHRoaXMuX3g9dFtlXSx0aGlzLl95PXRbZSsxXSx0aGlzLl96PXRbZSsyXSx0aGlzLl93PXRbZSszXSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLl94LHRbZSsxXT10aGlzLl95LHRbZSsyXT10aGlzLl96LHRbZSszXT10aGlzLl93LHR9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpe3JldHVybiB0aGlzLl94PXQuZ2V0WChlKSx0aGlzLl95PXQuZ2V0WShlKSx0aGlzLl96PXQuZ2V0WihlKSx0aGlzLl93PXQuZ2V0VyhlKSx0aGlzfXRvSlNPTigpe3JldHVybiB0aGlzLnRvQXJyYXkoKX1fb25DaGFuZ2UodCl7cmV0dXJuIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2s9dCx0aGlzfV9vbkNoYW5nZUNhbGxiYWNrKCl7fSpbU3ltYm9sLml0ZXJhdG9yXSgpe3lpZWxkIHRoaXMuX3gseWllbGQgdGhpcy5feSx5aWVsZCB0aGlzLl96LHlpZWxkIHRoaXMuX3d9fWNsYXNzIGd7Y29uc3RydWN0b3IodD0wLGU9MCxzPTApe2cucHJvdG90eXBlLmlzVmVjdG9yMz0hMCx0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9c31zZXQodCxlLHMpe3JldHVybiBzPT09dm9pZCAwJiYocz10aGlzLnopLHRoaXMueD10LHRoaXMueT1lLHRoaXMuej1zLHRoaXN9c2V0U2NhbGFyKHQpe3JldHVybiB0aGlzLng9dCx0aGlzLnk9dCx0aGlzLno9dCx0aGlzfXNldFgodCl7cmV0dXJuIHRoaXMueD10LHRoaXN9c2V0WSh0KXtyZXR1cm4gdGhpcy55PXQsdGhpc31zZXRaKHQpe3JldHVybiB0aGlzLno9dCx0aGlzfXNldENvbXBvbmVudCh0LGUpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy54PWU7YnJlYWs7Y2FzZSAxOnRoaXMueT1lO2JyZWFrO2Nhc2UgMjp0aGlzLno9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiK3QpfXJldHVybiB0aGlzfWdldENvbXBvbmVudCh0KXtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB0aGlzLng7Y2FzZSAxOnJldHVybiB0aGlzLnk7Y2FzZSAyOnJldHVybiB0aGlzLno7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIit0KX19Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LHRoaXMueSx0aGlzLnopfWNvcHkodCl7cmV0dXJuIHRoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56LHRoaXN9YWRkKHQpe3JldHVybiB0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzLnorPXQueix0aGlzfWFkZFNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kz10LHRoaXMueSs9dCx0aGlzLnorPXQsdGhpc31hZGRWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngrZS54LHRoaXMueT10LnkrZS55LHRoaXMuej10LnorZS56LHRoaXN9YWRkU2NhbGVkVmVjdG9yKHQsZSl7cmV0dXJuIHRoaXMueCs9dC54KmUsdGhpcy55Kz10LnkqZSx0aGlzLnorPXQueiplLHRoaXN9c3ViKHQpe3JldHVybiB0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzLnotPXQueix0aGlzfXN1YlNjYWxhcih0KXtyZXR1cm4gdGhpcy54LT10LHRoaXMueS09dCx0aGlzLnotPXQsdGhpc31zdWJWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngtZS54LHRoaXMueT10LnktZS55LHRoaXMuej10LnotZS56LHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMueCo9dC54LHRoaXMueSo9dC55LHRoaXMueio9dC56LHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7cmV0dXJuIHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10LHRoaXN9bXVsdGlwbHlWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngqZS54LHRoaXMueT10LnkqZS55LHRoaXMuej10LnoqZS56LHRoaXN9YXBwbHlFdWxlcih0KXtyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oJGUuc2V0RnJvbUV1bGVyKHQpKX1hcHBseUF4aXNBbmdsZSh0LGUpe3JldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbigkZS5zZXRGcm9tQXhpc0FuZ2xlKHQsZSkpfWFwcGx5TWF0cml4Myh0KXtjb25zdCBlPXRoaXMueCxzPXRoaXMueSxpPXRoaXMueixuPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMueD1uWzBdKmUrblszXSpzK25bNl0qaSx0aGlzLnk9blsxXSplK25bNF0qcytuWzddKmksdGhpcy56PW5bMl0qZStuWzVdKnMrbls4XSppLHRoaXN9YXBwbHlOb3JtYWxNYXRyaXgodCl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXgzKHQpLm5vcm1hbGl6ZSgpfWFwcGx5TWF0cml4NCh0KXtjb25zdCBlPXRoaXMueCxzPXRoaXMueSxpPXRoaXMueixuPXQuZWxlbWVudHMsYT0xLyhuWzNdKmUrbls3XSpzK25bMTFdKmkrblsxNV0pO3JldHVybiB0aGlzLng9KG5bMF0qZStuWzRdKnMrbls4XSppK25bMTJdKSphLHRoaXMueT0oblsxXSplK25bNV0qcytuWzldKmkrblsxM10pKmEsdGhpcy56PShuWzJdKmUrbls2XSpzK25bMTBdKmkrblsxNF0pKmEsdGhpc31hcHBseVF1YXRlcm5pb24odCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksaT10aGlzLnosbj10LngsYT10Lnksbz10LnosaD10LncsbD1oKmUrYSppLW8qcyxjPWgqcytvKmUtbippLHU9aCppK24qcy1hKmUsbT0tbiplLWEqcy1vKmk7cmV0dXJuIHRoaXMueD1sKmgrbSotbitjKi1vLXUqLWEsdGhpcy55PWMqaCttKi1hK3UqLW4tbCotbyx0aGlzLno9dSpoK20qLW8rbCotYS1jKi1uLHRoaXN9cHJvamVjdCh0KXtyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQodC5tYXRyaXhXb3JsZEludmVyc2UpLmFwcGx5TWF0cml4NCh0LnByb2plY3Rpb25NYXRyaXgpfXVucHJvamVjdCh0KXtyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQodC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSkuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpfXRyYW5zZm9ybURpcmVjdGlvbih0KXtjb25zdCBlPXRoaXMueCxzPXRoaXMueSxpPXRoaXMueixuPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMueD1uWzBdKmUrbls0XSpzK25bOF0qaSx0aGlzLnk9blsxXSplK25bNV0qcytuWzldKmksdGhpcy56PW5bMl0qZStuWzZdKnMrblsxMF0qaSx0aGlzLm5vcm1hbGl6ZSgpfWRpdmlkZSh0KXtyZXR1cm4gdGhpcy54Lz10LngsdGhpcy55Lz10LnksdGhpcy56Lz10LnosdGhpc31kaXZpZGVTY2FsYXIodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS90KX1taW4odCl7cmV0dXJuIHRoaXMueD1NYXRoLm1pbih0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQueSksdGhpcy56PU1hdGgubWluKHRoaXMueix0LnopLHRoaXN9bWF4KHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LHQueCksdGhpcy55PU1hdGgubWF4KHRoaXMueSx0LnkpLHRoaXMuej1NYXRoLm1heCh0aGlzLnosdC56KSx0aGlzfWNsYW1wKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LngsTWF0aC5taW4oZS54LHRoaXMueCkpLHRoaXMueT1NYXRoLm1heCh0LnksTWF0aC5taW4oZS55LHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LnosTWF0aC5taW4oZS56LHRoaXMueikpLHRoaXN9Y2xhbXBTY2FsYXIodCxlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy56KSksdGhpc31jbGFtcExlbmd0aCh0LGUpe2NvbnN0IHM9dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoc3x8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgodCxNYXRoLm1pbihlLHMpKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXMuej1NYXRoLmZsb29yKHRoaXMueiksdGhpc31jZWlsKCl7cmV0dXJuIHRoaXMueD1NYXRoLmNlaWwodGhpcy54KSx0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSksdGhpcy56PU1hdGguY2VpbCh0aGlzLnopLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXMuej1NYXRoLnJvdW5kKHRoaXMueiksdGhpc31yb3VuZFRvWmVybygpe3JldHVybiB0aGlzLng9dGhpcy54PDA/TWF0aC5jZWlsKHRoaXMueCk6TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT10aGlzLnk8MD9NYXRoLmNlaWwodGhpcy55KTpNYXRoLmZsb29yKHRoaXMueSksdGhpcy56PXRoaXMuejwwP01hdGguY2VpbCh0aGlzLnopOk1hdGguZmxvb3IodGhpcy56KSx0aGlzfW5lZ2F0ZSgpe3JldHVybiB0aGlzLng9LXRoaXMueCx0aGlzLnk9LXRoaXMueSx0aGlzLno9LXRoaXMueix0aGlzfWRvdCh0KXtyZXR1cm4gdGhpcy54KnQueCt0aGlzLnkqdC55K3RoaXMueip0Lnp9bGVuZ3RoU3EoKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnp9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMueil9bWFuaGF0dGFuTGVuZ3RoKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueCkrTWF0aC5hYnModGhpcy55KStNYXRoLmFicyh0aGlzLnopfW5vcm1hbGl6ZSgpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpfHwxKX1zZXRMZW5ndGgodCl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCl9bGVycCh0LGUpe3JldHVybiB0aGlzLngrPSh0LngtdGhpcy54KSplLHRoaXMueSs9KHQueS10aGlzLnkpKmUsdGhpcy56Kz0odC56LXRoaXMueikqZSx0aGlzfWxlcnBWZWN0b3JzKHQsZSxzKXtyZXR1cm4gdGhpcy54PXQueCsoZS54LXQueCkqcyx0aGlzLnk9dC55KyhlLnktdC55KSpzLHRoaXMuej10LnorKGUuei10LnopKnMsdGhpc31jcm9zcyh0KXtyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnModGhpcyx0KX1jcm9zc1ZlY3RvcnModCxlKXtjb25zdCBzPXQueCxpPXQueSxuPXQueixhPWUueCxvPWUueSxoPWUuejtyZXR1cm4gdGhpcy54PWkqaC1uKm8sdGhpcy55PW4qYS1zKmgsdGhpcy56PXMqby1pKmEsdGhpc31wcm9qZWN0T25WZWN0b3IodCl7Y29uc3QgZT10Lmxlbmd0aFNxKCk7aWYoZT09PTApcmV0dXJuIHRoaXMuc2V0KDAsMCwwKTtjb25zdCBzPXQuZG90KHRoaXMpL2U7cmV0dXJuIHRoaXMuY29weSh0KS5tdWx0aXBseVNjYWxhcihzKX1wcm9qZWN0T25QbGFuZSh0KXtyZXR1cm4gcGUuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IodCksdGhpcy5zdWIocGUpfXJlZmxlY3QodCl7cmV0dXJuIHRoaXMuc3ViKHBlLmNvcHkodCkubXVsdGlwbHlTY2FsYXIoMip0aGlzLmRvdCh0KSkpfWFuZ2xlVG8odCl7Y29uc3QgZT1NYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpKnQubGVuZ3RoU3EoKSk7aWYoZT09PTApcmV0dXJuIE1hdGguUEkvMjtjb25zdCBzPXRoaXMuZG90KHQpL2U7cmV0dXJuIE1hdGguYWNvcyhOKHMsLTEsMSkpfWRpc3RhbmNlVG8odCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHQpKX1kaXN0YW5jZVRvU3F1YXJlZCh0KXtjb25zdCBlPXRoaXMueC10Lngscz10aGlzLnktdC55LGk9dGhpcy56LXQuejtyZXR1cm4gZSplK3MqcytpKml9bWFuaGF0dGFuRGlzdGFuY2VUbyh0KXtyZXR1cm4gTWF0aC5hYnModGhpcy54LXQueCkrTWF0aC5hYnModGhpcy55LXQueSkrTWF0aC5hYnModGhpcy56LXQueil9c2V0RnJvbVNwaGVyaWNhbCh0KXtyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKHQucmFkaXVzLHQucGhpLHQudGhldGEpfXNldEZyb21TcGhlcmljYWxDb29yZHModCxlLHMpe2NvbnN0IGk9TWF0aC5zaW4oZSkqdDtyZXR1cm4gdGhpcy54PWkqTWF0aC5zaW4ocyksdGhpcy55PU1hdGguY29zKGUpKnQsdGhpcy56PWkqTWF0aC5jb3MocyksdGhpc31zZXRGcm9tQ3lsaW5kcmljYWwodCl7cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKHQucmFkaXVzLHQudGhldGEsdC55KX1zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHModCxlLHMpe3JldHVybiB0aGlzLng9dCpNYXRoLnNpbihlKSx0aGlzLnk9cyx0aGlzLno9dCpNYXRoLmNvcyhlKSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbih0KXtjb25zdCBlPXQuZWxlbWVudHM7cmV0dXJuIHRoaXMueD1lWzEyXSx0aGlzLnk9ZVsxM10sdGhpcy56PWVbMTRdLHRoaXN9c2V0RnJvbU1hdHJpeFNjYWxlKHQpe2NvbnN0IGU9dGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMCkubGVuZ3RoKCkscz10aGlzLnNldEZyb21NYXRyaXhDb2x1bW4odCwxKS5sZW5ndGgoKSxpPXRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LDIpLmxlbmd0aCgpO3JldHVybiB0aGlzLng9ZSx0aGlzLnk9cyx0aGlzLno9aSx0aGlzfXNldEZyb21NYXRyaXhDb2x1bW4odCxlKXtyZXR1cm4gdGhpcy5mcm9tQXJyYXkodC5lbGVtZW50cyxlKjQpfXNldEZyb21NYXRyaXgzQ29sdW1uKHQsZSl7cmV0dXJuIHRoaXMuZnJvbUFycmF5KHQuZWxlbWVudHMsZSozKX1zZXRGcm9tRXVsZXIodCl7cmV0dXJuIHRoaXMueD10Ll94LHRoaXMueT10Ll95LHRoaXMuej10Ll96LHRoaXN9c2V0RnJvbUNvbG9yKHQpe3JldHVybiB0aGlzLng9dC5yLHRoaXMueT10LmcsdGhpcy56PXQuYix0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC54PT09dGhpcy54JiZ0Lnk9PT10aGlzLnkmJnQuej09PXRoaXMuen1mcm9tQXJyYXkodCxlPTApe3JldHVybiB0aGlzLng9dFtlXSx0aGlzLnk9dFtlKzFdLHRoaXMuej10W2UrMl0sdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLngsdFtlKzFdPXRoaXMueSx0W2UrMl09dGhpcy56LHR9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpe3JldHVybiB0aGlzLng9dC5nZXRYKGUpLHRoaXMueT10LmdldFkoZSksdGhpcy56PXQuZ2V0WihlKSx0aGlzfXJhbmRvbSgpe3JldHVybiB0aGlzLng9TWF0aC5yYW5kb20oKSx0aGlzLnk9TWF0aC5yYW5kb20oKSx0aGlzLno9TWF0aC5yYW5kb20oKSx0aGlzfXJhbmRvbURpcmVjdGlvbigpe2NvbnN0IHQ9KE1hdGgucmFuZG9tKCktLjUpKjIsZT1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMixzPU1hdGguc3FydCgxLXQqKjIpO3JldHVybiB0aGlzLng9cypNYXRoLmNvcyhlKSx0aGlzLnk9cypNYXRoLnNpbihlKSx0aGlzLno9dCx0aGlzfSpbU3ltYm9sLml0ZXJhdG9yXSgpe3lpZWxkIHRoaXMueCx5aWVsZCB0aGlzLnkseWllbGQgdGhpcy56fX1jb25zdCBwZT1uZXcgZywkZT1uZXcgVHQ7Y2xhc3MgUnR7Y29uc3RydWN0b3IodD1uZXcgZygxLzAsMS8wLDEvMCksZT1uZXcgZygtMS8wLC0xLzAsLTEvMCkpe3RoaXMuaXNCb3gzPSEwLHRoaXMubWluPXQsdGhpcy5tYXg9ZX1zZXQodCxlKXtyZXR1cm4gdGhpcy5taW4uY29weSh0KSx0aGlzLm1heC5jb3B5KGUpLHRoaXN9c2V0RnJvbUFycmF5KHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBlPTAscz10Lmxlbmd0aDtlPHM7ZSs9Myl0aGlzLmV4cGFuZEJ5UG9pbnQoaXQuZnJvbUFycmF5KHQsZSkpO3JldHVybiB0aGlzfXNldEZyb21CdWZmZXJBdHRyaWJ1dGUodCl7dGhpcy5tYWtlRW1wdHkoKTtmb3IobGV0IGU9MCxzPXQuY291bnQ7ZTxzO2UrKyl0aGlzLmV4cGFuZEJ5UG9pbnQoaXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpKTtyZXR1cm4gdGhpc31zZXRGcm9tUG9pbnRzKHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBlPTAscz10Lmxlbmd0aDtlPHM7ZSsrKXRoaXMuZXhwYW5kQnlQb2ludCh0W2VdKTtyZXR1cm4gdGhpc31zZXRGcm9tQ2VudGVyQW5kU2l6ZSh0LGUpe2NvbnN0IHM9aXQuY29weShlKS5tdWx0aXBseVNjYWxhciguNSk7cmV0dXJuIHRoaXMubWluLmNvcHkodCkuc3ViKHMpLHRoaXMubWF4LmNvcHkodCkuYWRkKHMpLHRoaXN9c2V0RnJvbU9iamVjdCh0LGU9ITEpe3JldHVybiB0aGlzLm1ha2VFbXB0eSgpLHRoaXMuZXhwYW5kQnlPYmplY3QodCxlKX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weSh0KXtyZXR1cm4gdGhpcy5taW4uY29weSh0Lm1pbiksdGhpcy5tYXguY29weSh0Lm1heCksdGhpc31tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5taW4ueD10aGlzLm1pbi55PXRoaXMubWluLno9MS8wLHRoaXMubWF4Lng9dGhpcy5tYXgueT10aGlzLm1heC56PS0xLzAsdGhpc31pc0VtcHR5KCl7cmV0dXJuIHRoaXMubWF4Lng8dGhpcy5taW4ueHx8dGhpcy5tYXgueTx0aGlzLm1pbi55fHx0aGlzLm1heC56PHRoaXMubWluLnp9Z2V0Q2VudGVyKHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT90LnNldCgwLDAsMCk6dC5hZGRWZWN0b3JzKHRoaXMubWluLHRoaXMubWF4KS5tdWx0aXBseVNjYWxhciguNSl9Z2V0U2l6ZSh0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dC5zZXQoMCwwLDApOnQuc3ViVmVjdG9ycyh0aGlzLm1heCx0aGlzLm1pbil9ZXhwYW5kQnlQb2ludCh0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQpLHRoaXMubWF4Lm1heCh0KSx0aGlzfWV4cGFuZEJ5VmVjdG9yKHQpe3JldHVybiB0aGlzLm1pbi5zdWIodCksdGhpcy5tYXguYWRkKHQpLHRoaXN9ZXhwYW5kQnlTY2FsYXIodCl7cmV0dXJuIHRoaXMubWluLmFkZFNjYWxhcigtdCksdGhpcy5tYXguYWRkU2NhbGFyKHQpLHRoaXN9ZXhwYW5kQnlPYmplY3QodCxlPSExKXtpZih0LnVwZGF0ZVdvcmxkTWF0cml4KCExLCExKSx0LmJvdW5kaW5nQm94IT09dm9pZCAwKXQuYm91bmRpbmdCb3g9PT1udWxsJiZ0LmNvbXB1dGVCb3VuZGluZ0JveCgpLEF0LmNvcHkodC5ib3VuZGluZ0JveCksQXQuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMudW5pb24oQXQpO2Vsc2V7Y29uc3QgaT10Lmdlb21ldHJ5O2lmKGkhPT12b2lkIDApaWYoZSYmaS5hdHRyaWJ1dGVzIT09dm9pZCAwJiZpLmF0dHJpYnV0ZXMucG9zaXRpb24hPT12b2lkIDApe2NvbnN0IG49aS5hdHRyaWJ1dGVzLnBvc2l0aW9uO2ZvcihsZXQgYT0wLG89bi5jb3VudDthPG87YSsrKWl0LmZyb21CdWZmZXJBdHRyaWJ1dGUobixhKS5hcHBseU1hdHJpeDQodC5tYXRyaXhXb3JsZCksdGhpcy5leHBhbmRCeVBvaW50KGl0KX1lbHNlIGkuYm91bmRpbmdCb3g9PT1udWxsJiZpLmNvbXB1dGVCb3VuZGluZ0JveCgpLEF0LmNvcHkoaS5ib3VuZGluZ0JveCksQXQuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMudW5pb24oQXQpfWNvbnN0IHM9dC5jaGlsZHJlbjtmb3IobGV0IGk9MCxuPXMubGVuZ3RoO2k8bjtpKyspdGhpcy5leHBhbmRCeU9iamVjdChzW2ldLGUpO3JldHVybiB0aGlzfWNvbnRhaW5zUG9pbnQodCl7cmV0dXJuISh0Lng8dGhpcy5taW4ueHx8dC54PnRoaXMubWF4Lnh8fHQueTx0aGlzLm1pbi55fHx0Lnk+dGhpcy5tYXgueXx8dC56PHRoaXMubWluLnp8fHQuej50aGlzLm1heC56KX1jb250YWluc0JveCh0KXtyZXR1cm4gdGhpcy5taW4ueDw9dC5taW4ueCYmdC5tYXgueDw9dGhpcy5tYXgueCYmdGhpcy5taW4ueTw9dC5taW4ueSYmdC5tYXgueTw9dGhpcy5tYXgueSYmdGhpcy5taW4uejw9dC5taW4ueiYmdC5tYXguejw9dGhpcy5tYXguen1nZXRQYXJhbWV0ZXIodCxlKXtyZXR1cm4gZS5zZXQoKHQueC10aGlzLm1pbi54KS8odGhpcy5tYXgueC10aGlzLm1pbi54KSwodC55LXRoaXMubWluLnkpLyh0aGlzLm1heC55LXRoaXMubWluLnkpLCh0LnotdGhpcy5taW4ueikvKHRoaXMubWF4LnotdGhpcy5taW4ueikpfWludGVyc2VjdHNCb3godCl7cmV0dXJuISh0Lm1heC54PHRoaXMubWluLnh8fHQubWluLng+dGhpcy5tYXgueHx8dC5tYXgueTx0aGlzLm1pbi55fHx0Lm1pbi55PnRoaXMubWF4Lnl8fHQubWF4Lno8dGhpcy5taW4uenx8dC5taW4uej50aGlzLm1heC56KX1pbnRlcnNlY3RzU3BoZXJlKHQpe3JldHVybiB0aGlzLmNsYW1wUG9pbnQodC5jZW50ZXIsaXQpLGl0LmRpc3RhbmNlVG9TcXVhcmVkKHQuY2VudGVyKTw9dC5yYWRpdXMqdC5yYWRpdXN9aW50ZXJzZWN0c1BsYW5lKHQpe2xldCBlLHM7cmV0dXJuIHQubm9ybWFsLng+MD8oZT10Lm5vcm1hbC54KnRoaXMubWluLngscz10Lm5vcm1hbC54KnRoaXMubWF4LngpOihlPXQubm9ybWFsLngqdGhpcy5tYXgueCxzPXQubm9ybWFsLngqdGhpcy5taW4ueCksdC5ub3JtYWwueT4wPyhlKz10Lm5vcm1hbC55KnRoaXMubWluLnkscys9dC5ub3JtYWwueSp0aGlzLm1heC55KTooZSs9dC5ub3JtYWwueSp0aGlzLm1heC55LHMrPXQubm9ybWFsLnkqdGhpcy5taW4ueSksdC5ub3JtYWwuej4wPyhlKz10Lm5vcm1hbC56KnRoaXMubWluLnoscys9dC5ub3JtYWwueip0aGlzLm1heC56KTooZSs9dC5ub3JtYWwueip0aGlzLm1heC56LHMrPXQubm9ybWFsLnoqdGhpcy5taW4ueiksZTw9LXQuY29uc3RhbnQmJnM+PS10LmNvbnN0YW50fWludGVyc2VjdHNUcmlhbmdsZSh0KXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4hMTt0aGlzLmdldENlbnRlcihMdCksWHQuc3ViVmVjdG9ycyh0aGlzLm1heCxMdCksenQuc3ViVmVjdG9ycyh0LmEsTHQpLEZ0LnN1YlZlY3RvcnModC5iLEx0KSxTdC5zdWJWZWN0b3JzKHQuYyxMdCksbHQuc3ViVmVjdG9ycyhGdCx6dCksY3Quc3ViVmVjdG9ycyhTdCxGdCkseHQuc3ViVmVjdG9ycyh6dCxTdCk7bGV0IGU9WzAsLWx0LnosbHQueSwwLC1jdC56LGN0LnksMCwteHQueix4dC55LGx0LnosMCwtbHQueCxjdC56LDAsLWN0LngseHQueiwwLC14dC54LC1sdC55LGx0LngsMCwtY3QueSxjdC54LDAsLXh0LnkseHQueCwwXTtyZXR1cm4hZ2UoZSx6dCxGdCxTdCxYdCl8fChlPVsxLDAsMCwwLDEsMCwwLDAsMV0sIWdlKGUsenQsRnQsU3QsWHQpKT8hMTooR3QuY3Jvc3NWZWN0b3JzKGx0LGN0KSxlPVtHdC54LEd0LnksR3Quel0sZ2UoZSx6dCxGdCxTdCxYdCkpfWNsYW1wUG9pbnQodCxlKXtyZXR1cm4gZS5jb3B5KHQpLmNsYW1wKHRoaXMubWluLHRoaXMubWF4KX1kaXN0YW5jZVRvUG9pbnQodCl7cmV0dXJuIHRoaXMuY2xhbXBQb2ludCh0LGl0KS5kaXN0YW5jZVRvKHQpfWdldEJvdW5kaW5nU3BoZXJlKHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT90Lm1ha2VFbXB0eSgpOih0aGlzLmdldENlbnRlcih0LmNlbnRlciksdC5yYWRpdXM9dGhpcy5nZXRTaXplKGl0KS5sZW5ndGgoKSouNSksdH1pbnRlcnNlY3QodCl7cmV0dXJuIHRoaXMubWluLm1heCh0Lm1pbiksdGhpcy5tYXgubWluKHQubWF4KSx0aGlzLmlzRW1wdHkoKSYmdGhpcy5tYWtlRW1wdHkoKSx0aGlzfXVuaW9uKHQpe3JldHVybiB0aGlzLm1pbi5taW4odC5taW4pLHRoaXMubWF4Lm1heCh0Lm1heCksdGhpc31hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3RoaXM6KHN0WzBdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLHN0WzFdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHN0WzJdLnNldCh0aGlzLm1pbi54LHRoaXMubWF4LnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLHN0WzNdLnNldCh0aGlzLm1pbi54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHN0WzRdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLHN0WzVdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHN0WzZdLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLHN0WzddLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0RnJvbVBvaW50cyhzdCksdGhpcyl9dHJhbnNsYXRlKHQpe3JldHVybiB0aGlzLm1pbi5hZGQodCksdGhpcy5tYXguYWRkKHQpLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lm1pbi5lcXVhbHModGhpcy5taW4pJiZ0Lm1heC5lcXVhbHModGhpcy5tYXgpfX1jb25zdCBzdD1bbmV3IGcsbmV3IGcsbmV3IGcsbmV3IGcsbmV3IGcsbmV3IGcsbmV3IGcsbmV3IGddLGl0PW5ldyBnLEF0PW5ldyBSdCx6dD1uZXcgZyxGdD1uZXcgZyxTdD1uZXcgZyxsdD1uZXcgZyxjdD1uZXcgZyx4dD1uZXcgZyxMdD1uZXcgZyxYdD1uZXcgZyxHdD1uZXcgZyxwdD1uZXcgZztmdW5jdGlvbiBnZShyLHQsZSxzLGkpe2ZvcihsZXQgbj0wLGE9ci5sZW5ndGgtMztuPD1hO24rPTMpe3B0LmZyb21BcnJheShyLG4pO2NvbnN0IG89aS54Kk1hdGguYWJzKHB0LngpK2kueSpNYXRoLmFicyhwdC55KStpLnoqTWF0aC5hYnMocHQueiksaD10LmRvdChwdCksbD1lLmRvdChwdCksYz1zLmRvdChwdCk7aWYoTWF0aC5tYXgoLU1hdGgubWF4KGgsbCxjKSxNYXRoLm1pbihoLGwsYykpPm8pcmV0dXJuITF9cmV0dXJuITB9Y29uc3QgWnM9bmV3IFJ0LEl0PW5ldyBnLGJlPW5ldyBnO2NsYXNzIGpze2NvbnN0cnVjdG9yKHQ9bmV3IGcsZT0tMSl7dGhpcy5jZW50ZXI9dCx0aGlzLnJhZGl1cz1lfXNldCh0LGUpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KHQpLHRoaXMucmFkaXVzPWUsdGhpc31zZXRGcm9tUG9pbnRzKHQsZSl7Y29uc3Qgcz10aGlzLmNlbnRlcjtlIT09dm9pZCAwP3MuY29weShlKTpacy5zZXRGcm9tUG9pbnRzKHQpLmdldENlbnRlcihzKTtsZXQgaT0wO2ZvcihsZXQgbj0wLGE9dC5sZW5ndGg7bjxhO24rKylpPU1hdGgubWF4KGkscy5kaXN0YW5jZVRvU3F1YXJlZCh0W25dKSk7cmV0dXJuIHRoaXMucmFkaXVzPU1hdGguc3FydChpKSx0aGlzfWNvcHkodCl7cmV0dXJuIHRoaXMuY2VudGVyLmNvcHkodC5jZW50ZXIpLHRoaXMucmFkaXVzPXQucmFkaXVzLHRoaXN9aXNFbXB0eSgpe3JldHVybiB0aGlzLnJhZGl1czwwfW1ha2VFbXB0eSgpe3JldHVybiB0aGlzLmNlbnRlci5zZXQoMCwwLDApLHRoaXMucmFkaXVzPS0xLHRoaXN9Y29udGFpbnNQb2ludCh0KXtyZXR1cm4gdC5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcik8PXRoaXMucmFkaXVzKnRoaXMucmFkaXVzfWRpc3RhbmNlVG9Qb2ludCh0KXtyZXR1cm4gdC5kaXN0YW5jZVRvKHRoaXMuY2VudGVyKS10aGlzLnJhZGl1c31pbnRlcnNlY3RzU3BoZXJlKHQpe2NvbnN0IGU9dGhpcy5yYWRpdXMrdC5yYWRpdXM7cmV0dXJuIHQuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKTw9ZSplfWludGVyc2VjdHNCb3godCl7cmV0dXJuIHQuaW50ZXJzZWN0c1NwaGVyZSh0aGlzKX1pbnRlcnNlY3RzUGxhbmUodCl7cmV0dXJuIE1hdGguYWJzKHQuZGlzdGFuY2VUb1BvaW50KHRoaXMuY2VudGVyKSk8PXRoaXMucmFkaXVzfWNsYW1wUG9pbnQodCxlKXtjb25zdCBzPXRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHQpO3JldHVybiBlLmNvcHkodCkscz50aGlzLnJhZGl1cyp0aGlzLnJhZGl1cyYmKGUuc3ViKHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKSxlLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKS5hZGQodGhpcy5jZW50ZXIpKSxlfWdldEJvdW5kaW5nQm94KHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8odC5tYWtlRW1wdHkoKSx0KToodC5zZXQodGhpcy5jZW50ZXIsdGhpcy5jZW50ZXIpLHQuZXhwYW5kQnlTY2FsYXIodGhpcy5yYWRpdXMpLHQpfWFwcGx5TWF0cml4NCh0KXtyZXR1cm4gdGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KHQpLHRoaXMucmFkaXVzPXRoaXMucmFkaXVzKnQuZ2V0TWF4U2NhbGVPbkF4aXMoKSx0aGlzfXRyYW5zbGF0ZSh0KXtyZXR1cm4gdGhpcy5jZW50ZXIuYWRkKHQpLHRoaXN9ZXhwYW5kQnlQb2ludCh0KXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5jZW50ZXIuY29weSh0KSx0aGlzLnJhZGl1cz0wLHRoaXM7SXQuc3ViVmVjdG9ycyh0LHRoaXMuY2VudGVyKTtjb25zdCBlPUl0Lmxlbmd0aFNxKCk7aWYoZT50aGlzLnJhZGl1cyp0aGlzLnJhZGl1cyl7Y29uc3Qgcz1NYXRoLnNxcnQoZSksaT0ocy10aGlzLnJhZGl1cykqLjU7dGhpcy5jZW50ZXIuYWRkU2NhbGVkVmVjdG9yKEl0LGkvcyksdGhpcy5yYWRpdXMrPWl9cmV0dXJuIHRoaXN9dW5pb24odCl7cmV0dXJuIHQuaXNFbXB0eSgpP3RoaXM6dGhpcy5pc0VtcHR5KCk/KHRoaXMuY29weSh0KSx0aGlzKToodGhpcy5jZW50ZXIuZXF1YWxzKHQuY2VudGVyKT09PSEwP3RoaXMucmFkaXVzPU1hdGgubWF4KHRoaXMucmFkaXVzLHQucmFkaXVzKTooYmUuc3ViVmVjdG9ycyh0LmNlbnRlcix0aGlzLmNlbnRlcikuc2V0TGVuZ3RoKHQucmFkaXVzKSx0aGlzLmV4cGFuZEJ5UG9pbnQoSXQuY29weSh0LmNlbnRlcikuYWRkKGJlKSksdGhpcy5leHBhbmRCeVBvaW50KEl0LmNvcHkodC5jZW50ZXIpLnN1YihiZSkpKSx0aGlzKX1lcXVhbHModCl7cmV0dXJuIHQuY2VudGVyLmVxdWFscyh0aGlzLmNlbnRlcikmJnQucmFkaXVzPT09dGhpcy5yYWRpdXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX1jbGFzcyBLe2NvbnN0cnVjdG9yKHQsZSxzLGksbixhLG8saCxsLGMsdSxtLGQsZix5LHgpe0sucHJvdG90eXBlLmlzTWF0cml4ND0hMCx0aGlzLmVsZW1lbnRzPVsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSx0IT09dm9pZCAwJiZ0aGlzLnNldCh0LGUscyxpLG4sYSxvLGgsbCxjLHUsbSxkLGYseSx4KX1zZXQodCxlLHMsaSxuLGEsbyxoLGwsYyx1LG0sZCxmLHkseCl7Y29uc3QgcD10aGlzLmVsZW1lbnRzO3JldHVybiBwWzBdPXQscFs0XT1lLHBbOF09cyxwWzEyXT1pLHBbMV09bixwWzVdPWEscFs5XT1vLHBbMTNdPWgscFsyXT1sLHBbNl09YyxwWzEwXT11LHBbMTRdPW0scFszXT1kLHBbN109ZixwWzExXT15LHBbMTVdPXgsdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyBLKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpfWNvcHkodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHM9dC5lbGVtZW50cztyZXR1cm4gZVswXT1zWzBdLGVbMV09c1sxXSxlWzJdPXNbMl0sZVszXT1zWzNdLGVbNF09c1s0XSxlWzVdPXNbNV0sZVs2XT1zWzZdLGVbN109c1s3XSxlWzhdPXNbOF0sZVs5XT1zWzldLGVbMTBdPXNbMTBdLGVbMTFdPXNbMTFdLGVbMTJdPXNbMTJdLGVbMTNdPXNbMTNdLGVbMTRdPXNbMTRdLGVbMTVdPXNbMTVdLHRoaXN9Y29weVBvc2l0aW9uKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxzPXQuZWxlbWVudHM7cmV0dXJuIGVbMTJdPXNbMTJdLGVbMTNdPXNbMTNdLGVbMTRdPXNbMTRdLHRoaXN9c2V0RnJvbU1hdHJpeDModCl7Y29uc3QgZT10LmVsZW1lbnRzO3JldHVybiB0aGlzLnNldChlWzBdLGVbM10sZVs2XSwwLGVbMV0sZVs0XSxlWzddLDAsZVsyXSxlWzVdLGVbOF0sMCwwLDAsMCwxKSx0aGlzfWV4dHJhY3RCYXNpcyh0LGUscyl7cmV0dXJuIHQuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLDApLGUuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLDEpLHMuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLDIpLHRoaXN9bWFrZUJhc2lzKHQsZSxzKXtyZXR1cm4gdGhpcy5zZXQodC54LGUueCxzLngsMCx0LnksZS55LHMueSwwLHQueixlLnoscy56LDAsMCwwLDAsMSksdGhpc31leHRyYWN0Um90YXRpb24odCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHM9dC5lbGVtZW50cyxpPTEva3Quc2V0RnJvbU1hdHJpeENvbHVtbih0LDApLmxlbmd0aCgpLG49MS9rdC5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMSkubGVuZ3RoKCksYT0xL2t0LnNldEZyb21NYXRyaXhDb2x1bW4odCwyKS5sZW5ndGgoKTtyZXR1cm4gZVswXT1zWzBdKmksZVsxXT1zWzFdKmksZVsyXT1zWzJdKmksZVszXT0wLGVbNF09c1s0XSpuLGVbNV09c1s1XSpuLGVbNl09c1s2XSpuLGVbN109MCxlWzhdPXNbOF0qYSxlWzldPXNbOV0qYSxlWzEwXT1zWzEwXSphLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSx0aGlzfW1ha2VSb3RhdGlvbkZyb21FdWxlcih0KXtjb25zdCBlPXRoaXMuZWxlbWVudHMscz10LngsaT10Lnksbj10LnosYT1NYXRoLmNvcyhzKSxvPU1hdGguc2luKHMpLGg9TWF0aC5jb3MoaSksbD1NYXRoLnNpbihpKSxjPU1hdGguY29zKG4pLHU9TWF0aC5zaW4obik7aWYodC5vcmRlcj09PSJYWVoiKXtjb25zdCBtPWEqYyxkPWEqdSxmPW8qYyx5PW8qdTtlWzBdPWgqYyxlWzRdPS1oKnUsZVs4XT1sLGVbMV09ZCtmKmwsZVs1XT1tLXkqbCxlWzldPS1vKmgsZVsyXT15LW0qbCxlWzZdPWYrZCpsLGVbMTBdPWEqaH1lbHNlIGlmKHQub3JkZXI9PT0iWVhaIil7Y29uc3QgbT1oKmMsZD1oKnUsZj1sKmMseT1sKnU7ZVswXT1tK3kqbyxlWzRdPWYqby1kLGVbOF09YSpsLGVbMV09YSp1LGVbNV09YSpjLGVbOV09LW8sZVsyXT1kKm8tZixlWzZdPXkrbSpvLGVbMTBdPWEqaH1lbHNlIGlmKHQub3JkZXI9PT0iWlhZIil7Y29uc3QgbT1oKmMsZD1oKnUsZj1sKmMseT1sKnU7ZVswXT1tLXkqbyxlWzRdPS1hKnUsZVs4XT1mK2QqbyxlWzFdPWQrZipvLGVbNV09YSpjLGVbOV09eS1tKm8sZVsyXT0tYSpsLGVbNl09byxlWzEwXT1hKmh9ZWxzZSBpZih0Lm9yZGVyPT09IlpZWCIpe2NvbnN0IG09YSpjLGQ9YSp1LGY9bypjLHk9byp1O2VbMF09aCpjLGVbNF09ZipsLWQsZVs4XT1tKmwreSxlWzFdPWgqdSxlWzVdPXkqbCttLGVbOV09ZCpsLWYsZVsyXT0tbCxlWzZdPW8qaCxlWzEwXT1hKmh9ZWxzZSBpZih0Lm9yZGVyPT09IllaWCIpe2NvbnN0IG09YSpoLGQ9YSpsLGY9bypoLHk9bypsO2VbMF09aCpjLGVbNF09eS1tKnUsZVs4XT1mKnUrZCxlWzFdPXUsZVs1XT1hKmMsZVs5XT0tbypjLGVbMl09LWwqYyxlWzZdPWQqdStmLGVbMTBdPW0teSp1fWVsc2UgaWYodC5vcmRlcj09PSJYWlkiKXtjb25zdCBtPWEqaCxkPWEqbCxmPW8qaCx5PW8qbDtlWzBdPWgqYyxlWzRdPS11LGVbOF09bCpjLGVbMV09bSp1K3ksZVs1XT1hKmMsZVs5XT1kKnUtZixlWzJdPWYqdS1kLGVbNl09bypjLGVbMTBdPXkqdSttfXJldHVybiBlWzNdPTAsZVs3XT0wLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSx0aGlzfW1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpe3JldHVybiB0aGlzLmNvbXBvc2UoSnMsdCxRcyl9bG9va0F0KHQsZSxzKXtjb25zdCBpPXRoaXMuZWxlbWVudHM7cmV0dXJuIFkuc3ViVmVjdG9ycyh0LGUpLFkubGVuZ3RoU3EoKT09PTAmJihZLno9MSksWS5ub3JtYWxpemUoKSx1dC5jcm9zc1ZlY3RvcnMocyxZKSx1dC5sZW5ndGhTcSgpPT09MCYmKE1hdGguYWJzKHMueik9PT0xP1kueCs9MWUtNDpZLnorPTFlLTQsWS5ub3JtYWxpemUoKSx1dC5jcm9zc1ZlY3RvcnMocyxZKSksdXQubm9ybWFsaXplKCksWnQuY3Jvc3NWZWN0b3JzKFksdXQpLGlbMF09dXQueCxpWzRdPVp0LngsaVs4XT1ZLngsaVsxXT11dC55LGlbNV09WnQueSxpWzldPVkueSxpWzJdPXV0LnosaVs2XT1adC56LGlbMTBdPVkueix0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcyx0KX1wcmVtdWx0aXBseSh0KXtyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsdGhpcyl9bXVsdGlwbHlNYXRyaWNlcyh0LGUpe2NvbnN0IHM9dC5lbGVtZW50cyxpPWUuZWxlbWVudHMsbj10aGlzLmVsZW1lbnRzLGE9c1swXSxvPXNbNF0saD1zWzhdLGw9c1sxMl0sYz1zWzFdLHU9c1s1XSxtPXNbOV0sZD1zWzEzXSxmPXNbMl0seT1zWzZdLHg9c1sxMF0scD1zWzE0XSxGPXNbM10sUz1zWzddLHc9c1sxMV0sXz1zWzE1XSxrPWlbMF0sTT1pWzRdLFA9aVs4XSxxPWlbMTJdLEE9aVsxXSx6PWlbNV0sRT1pWzldLEI9aVsxM10sdHQ9aVsyXSxMPWlbNl0sST1pWzEwXSxtdD1pWzE0XSxIPWlbM10sZWU9aVs3XSxzZT1pWzExXSxpZT1pWzE1XTtyZXR1cm4gblswXT1hKmsrbypBK2gqdHQrbCpILG5bNF09YSpNK28qeitoKkwrbCplZSxuWzhdPWEqUCtvKkUraCpJK2wqc2UsblsxMl09YSpxK28qQitoKm10K2wqaWUsblsxXT1jKmsrdSpBK20qdHQrZCpILG5bNV09YypNK3UqeittKkwrZCplZSxuWzldPWMqUCt1KkUrbSpJK2Qqc2UsblsxM109YypxK3UqQittKm10K2QqaWUsblsyXT1mKmsreSpBK3gqdHQrcCpILG5bNl09ZipNK3kqeit4KkwrcCplZSxuWzEwXT1mKlAreSpFK3gqSStwKnNlLG5bMTRdPWYqcSt5KkIreCptdCtwKmllLG5bM109RiprK1MqQSt3KnR0K18qSCxuWzddPUYqTStTKnordypMK18qZWUsblsxMV09RipQK1MqRSt3KkkrXypzZSxuWzE1XT1GKnErUypCK3cqbXQrXyppZSx0aGlzfW11bHRpcGx5U2NhbGFyKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cztyZXR1cm4gZVswXSo9dCxlWzRdKj10LGVbOF0qPXQsZVsxMl0qPXQsZVsxXSo9dCxlWzVdKj10LGVbOV0qPXQsZVsxM10qPXQsZVsyXSo9dCxlWzZdKj10LGVbMTBdKj10LGVbMTRdKj10LGVbM10qPXQsZVs3XSo9dCxlWzExXSo9dCxlWzE1XSo9dCx0aGlzfWRldGVybWluYW50KCl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGU9dFswXSxzPXRbNF0saT10WzhdLG49dFsxMl0sYT10WzFdLG89dFs1XSxoPXRbOV0sbD10WzEzXSxjPXRbMl0sdT10WzZdLG09dFsxMF0sZD10WzE0XSxmPXRbM10seT10WzddLHg9dFsxMV0scD10WzE1XTtyZXR1cm4gZiooK24qaCp1LWkqbCp1LW4qbyptK3MqbCptK2kqbypkLXMqaCpkKSt5KigrZSpoKmQtZSpsKm0rbiphKm0taSphKmQraSpsKmMtbipoKmMpK3gqKCtlKmwqdS1lKm8qZC1uKmEqdStzKmEqZCtuKm8qYy1zKmwqYykrcCooLWkqbypjLWUqaCp1K2UqbyptK2kqYSp1LXMqYSptK3MqaCpjKX10cmFuc3Bvc2UoKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7bGV0IGU7cmV0dXJuIGU9dFsxXSx0WzFdPXRbNF0sdFs0XT1lLGU9dFsyXSx0WzJdPXRbOF0sdFs4XT1lLGU9dFs2XSx0WzZdPXRbOV0sdFs5XT1lLGU9dFszXSx0WzNdPXRbMTJdLHRbMTJdPWUsZT10WzddLHRbN109dFsxM10sdFsxM109ZSxlPXRbMTFdLHRbMTFdPXRbMTRdLHRbMTRdPWUsdGhpc31zZXRQb3NpdGlvbih0LGUscyl7Y29uc3QgaT10aGlzLmVsZW1lbnRzO3JldHVybiB0LmlzVmVjdG9yMz8oaVsxMl09dC54LGlbMTNdPXQueSxpWzE0XT10LnopOihpWzEyXT10LGlbMTNdPWUsaVsxNF09cyksdGhpc31pbnZlcnQoKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsZT10WzBdLHM9dFsxXSxpPXRbMl0sbj10WzNdLGE9dFs0XSxvPXRbNV0saD10WzZdLGw9dFs3XSxjPXRbOF0sdT10WzldLG09dFsxMF0sZD10WzExXSxmPXRbMTJdLHk9dFsxM10seD10WzE0XSxwPXRbMTVdLEY9dSp4KmwteSptKmwreSpoKmQtbyp4KmQtdSpoKnArbyptKnAsUz1mKm0qbC1jKngqbC1mKmgqZCthKngqZCtjKmgqcC1hKm0qcCx3PWMqeSpsLWYqdSpsK2YqbypkLWEqeSpkLWMqbypwK2EqdSpwLF89Zip1KmgtYyp5KmgtZipvKm0rYSp5Km0rYypvKngtYSp1Kngsaz1lKkYrcypTK2kqdytuKl87aWYoaz09PTApcmV0dXJuIHRoaXMuc2V0KDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDApO2NvbnN0IE09MS9rO3JldHVybiB0WzBdPUYqTSx0WzFdPSh5Km0qbi11Kngqbi15KmkqZCtzKngqZCt1KmkqcC1zKm0qcCkqTSx0WzJdPShvKngqbi15Kmgqbit5KmkqbC1zKngqbC1vKmkqcCtzKmgqcCkqTSx0WzNdPSh1Kmgqbi1vKm0qbi11KmkqbCtzKm0qbCtvKmkqZC1zKmgqZCkqTSx0WzRdPVMqTSx0WzVdPShjKngqbi1mKm0qbitmKmkqZC1lKngqZC1jKmkqcCtlKm0qcCkqTSx0WzZdPShmKmgqbi1hKngqbi1mKmkqbCtlKngqbCthKmkqcC1lKmgqcCkqTSx0WzddPShhKm0qbi1jKmgqbitjKmkqbC1lKm0qbC1hKmkqZCtlKmgqZCkqTSx0WzhdPXcqTSx0WzldPShmKnUqbi1jKnkqbi1mKnMqZCtlKnkqZCtjKnMqcC1lKnUqcCkqTSx0WzEwXT0oYSp5Km4tZipvKm4rZipzKmwtZSp5KmwtYSpzKnArZSpvKnApKk0sdFsxMV09KGMqbypuLWEqdSpuLWMqcypsK2UqdSpsK2EqcypkLWUqbypkKSpNLHRbMTJdPV8qTSx0WzEzXT0oYyp5KmktZip1KmkrZipzKm0tZSp5Km0tYypzKngrZSp1KngpKk0sdFsxNF09KGYqbyppLWEqeSppLWYqcypoK2UqeSpoK2Eqcyp4LWUqbyp4KSpNLHRbMTVdPShhKnUqaS1jKm8qaStjKnMqaC1lKnUqaC1hKnMqbStlKm8qbSkqTSx0aGlzfXNjYWxlKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxzPXQueCxpPXQueSxuPXQuejtyZXR1cm4gZVswXSo9cyxlWzRdKj1pLGVbOF0qPW4sZVsxXSo9cyxlWzVdKj1pLGVbOV0qPW4sZVsyXSo9cyxlWzZdKj1pLGVbMTBdKj1uLGVbM10qPXMsZVs3XSo9aSxlWzExXSo9bix0aGlzfWdldE1heFNjYWxlT25BeGlzKCl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGU9dFswXSp0WzBdK3RbMV0qdFsxXSt0WzJdKnRbMl0scz10WzRdKnRbNF0rdFs1XSp0WzVdK3RbNl0qdFs2XSxpPXRbOF0qdFs4XSt0WzldKnRbOV0rdFsxMF0qdFsxMF07cmV0dXJuIE1hdGguc3FydChNYXRoLm1heChlLHMsaSkpfW1ha2VUcmFuc2xhdGlvbih0LGUscyl7cmV0dXJuIHQuaXNWZWN0b3IzP3RoaXMuc2V0KDEsMCwwLHQueCwwLDEsMCx0LnksMCwwLDEsdC56LDAsMCwwLDEpOnRoaXMuc2V0KDEsMCwwLHQsMCwxLDAsZSwwLDAsMSxzLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uWCh0KXtjb25zdCBlPU1hdGguY29zKHQpLHM9TWF0aC5zaW4odCk7cmV0dXJuIHRoaXMuc2V0KDEsMCwwLDAsMCxlLC1zLDAsMCxzLGUsMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvblkodCl7Y29uc3QgZT1NYXRoLmNvcyh0KSxzPU1hdGguc2luKHQpO3JldHVybiB0aGlzLnNldChlLDAscywwLDAsMSwwLDAsLXMsMCxlLDAsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25aKHQpe2NvbnN0IGU9TWF0aC5jb3ModCkscz1NYXRoLnNpbih0KTtyZXR1cm4gdGhpcy5zZXQoZSwtcywwLDAscyxlLDAsMCwwLDAsMSwwLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uQXhpcyh0LGUpe2NvbnN0IHM9TWF0aC5jb3MoZSksaT1NYXRoLnNpbihlKSxuPTEtcyxhPXQueCxvPXQueSxoPXQueixsPW4qYSxjPW4qbztyZXR1cm4gdGhpcy5zZXQobCphK3MsbCpvLWkqaCxsKmgraSpvLDAsbCpvK2kqaCxjKm8rcyxjKmgtaSphLDAsbCpoLWkqbyxjKmgraSphLG4qaCpoK3MsMCwwLDAsMCwxKSx0aGlzfW1ha2VTY2FsZSh0LGUscyl7cmV0dXJuIHRoaXMuc2V0KHQsMCwwLDAsMCxlLDAsMCwwLDAscywwLDAsMCwwLDEpLHRoaXN9bWFrZVNoZWFyKHQsZSxzLGksbixhKXtyZXR1cm4gdGhpcy5zZXQoMSxzLG4sMCx0LDEsYSwwLGUsaSwxLDAsMCwwLDAsMSksdGhpc31jb21wb3NlKHQsZSxzKXtjb25zdCBpPXRoaXMuZWxlbWVudHMsbj1lLl94LGE9ZS5feSxvPWUuX3osaD1lLl93LGw9bituLGM9YSthLHU9bytvLG09bipsLGQ9bipjLGY9bip1LHk9YSpjLHg9YSp1LHA9byp1LEY9aCpsLFM9aCpjLHc9aCp1LF89cy54LGs9cy55LE09cy56O3JldHVybiBpWzBdPSgxLSh5K3ApKSpfLGlbMV09KGQrdykqXyxpWzJdPShmLVMpKl8saVszXT0wLGlbNF09KGQtdykqayxpWzVdPSgxLShtK3ApKSprLGlbNl09KHgrRikqayxpWzddPTAsaVs4XT0oZitTKSpNLGlbOV09KHgtRikqTSxpWzEwXT0oMS0obSt5KSkqTSxpWzExXT0wLGlbMTJdPXQueCxpWzEzXT10LnksaVsxNF09dC56LGlbMTVdPTEsdGhpc31kZWNvbXBvc2UodCxlLHMpe2NvbnN0IGk9dGhpcy5lbGVtZW50cztsZXQgbj1rdC5zZXQoaVswXSxpWzFdLGlbMl0pLmxlbmd0aCgpO2NvbnN0IGE9a3Quc2V0KGlbNF0saVs1XSxpWzZdKS5sZW5ndGgoKSxvPWt0LnNldChpWzhdLGlbOV0saVsxMF0pLmxlbmd0aCgpO3RoaXMuZGV0ZXJtaW5hbnQoKTwwJiYobj0tbiksdC54PWlbMTJdLHQueT1pWzEzXSx0Lno9aVsxNF0sSi5jb3B5KHRoaXMpO2NvbnN0IGw9MS9uLGM9MS9hLHU9MS9vO3JldHVybiBKLmVsZW1lbnRzWzBdKj1sLEouZWxlbWVudHNbMV0qPWwsSi5lbGVtZW50c1syXSo9bCxKLmVsZW1lbnRzWzRdKj1jLEouZWxlbWVudHNbNV0qPWMsSi5lbGVtZW50c1s2XSo9YyxKLmVsZW1lbnRzWzhdKj11LEouZWxlbWVudHNbOV0qPXUsSi5lbGVtZW50c1sxMF0qPXUsZS5zZXRGcm9tUm90YXRpb25NYXRyaXgoSikscy54PW4scy55PWEscy56PW8sdGhpc31tYWtlUGVyc3BlY3RpdmUodCxlLHMsaSxuLGEsbz0kdCl7Y29uc3QgaD10aGlzLmVsZW1lbnRzLGw9MipuLyhlLXQpLGM9MipuLyhzLWkpLHU9KGUrdCkvKGUtdCksbT0ocytpKS8ocy1pKTtsZXQgZCxmO2lmKG89PT0kdClkPS0oYStuKS8oYS1uKSxmPS0yKmEqbi8oYS1uKTtlbHNlIGlmKG89PT1OZSlkPS1hLyhhLW4pLGY9LWEqbi8oYS1uKTtlbHNlIHRocm93IG5ldyBFcnJvcigiVEhSRUUuTWF0cml4NC5tYWtlUGVyc3BlY3RpdmUoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogIitvKTtyZXR1cm4gaFswXT1sLGhbNF09MCxoWzhdPXUsaFsxMl09MCxoWzFdPTAsaFs1XT1jLGhbOV09bSxoWzEzXT0wLGhbMl09MCxoWzZdPTAsaFsxMF09ZCxoWzE0XT1mLGhbM109MCxoWzddPTAsaFsxMV09LTEsaFsxNV09MCx0aGlzfW1ha2VPcnRob2dyYXBoaWModCxlLHMsaSxuLGEsbz0kdCl7Y29uc3QgaD10aGlzLmVsZW1lbnRzLGw9MS8oZS10KSxjPTEvKHMtaSksdT0xLyhhLW4pLG09KGUrdCkqbCxkPShzK2kpKmM7bGV0IGYseTtpZihvPT09JHQpZj0oYStuKSp1LHk9LTIqdTtlbHNlIGlmKG89PT1OZSlmPW4qdSx5PS0xKnU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk1hdHJpeDQubWFrZU9ydGhvZ3JhcGhpYygpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAiK28pO3JldHVybiBoWzBdPTIqbCxoWzRdPTAsaFs4XT0wLGhbMTJdPS1tLGhbMV09MCxoWzVdPTIqYyxoWzldPTAsaFsxM109LWQsaFsyXT0wLGhbNl09MCxoWzEwXT15LGhbMTRdPS1mLGhbM109MCxoWzddPTAsaFsxMV09MCxoWzE1XT0xLHRoaXN9ZXF1YWxzKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxzPXQuZWxlbWVudHM7Zm9yKGxldCBpPTA7aTwxNjtpKyspaWYoZVtpXSE9PXNbaV0pcmV0dXJuITE7cmV0dXJuITB9ZnJvbUFycmF5KHQsZT0wKXtmb3IobGV0IHM9MDtzPDE2O3MrKyl0aGlzLmVsZW1lbnRzW3NdPXRbcytlXTtyZXR1cm4gdGhpc310b0FycmF5KHQ9W10sZT0wKXtjb25zdCBzPXRoaXMuZWxlbWVudHM7cmV0dXJuIHRbZV09c1swXSx0W2UrMV09c1sxXSx0W2UrMl09c1syXSx0W2UrM109c1szXSx0W2UrNF09c1s0XSx0W2UrNV09c1s1XSx0W2UrNl09c1s2XSx0W2UrN109c1s3XSx0W2UrOF09c1s4XSx0W2UrOV09c1s5XSx0W2UrMTBdPXNbMTBdLHRbZSsxMV09c1sxMV0sdFtlKzEyXT1zWzEyXSx0W2UrMTNdPXNbMTNdLHRbZSsxNF09c1sxNF0sdFtlKzE1XT1zWzE1XSx0fX1jb25zdCBrdD1uZXcgZyxKPW5ldyBLLEpzPW5ldyBnKDAsMCwwKSxRcz1uZXcgZygxLDEsMSksdXQ9bmV3IGcsWnQ9bmV3IGcsWT1uZXcgZyxWZT1uZXcgSyxZZT1uZXcgVHQ7Y2xhc3MganR7Y29uc3RydWN0b3IodD0wLGU9MCxzPTAsaT1qdC5ERUZBVUxUX09SREVSKXt0aGlzLmlzRXVsZXI9ITAsdGhpcy5feD10LHRoaXMuX3k9ZSx0aGlzLl96PXMsdGhpcy5fb3JkZXI9aX1nZXQgeCgpe3JldHVybiB0aGlzLl94fXNldCB4KHQpe3RoaXMuX3g9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5feX1zZXQgeSh0KXt0aGlzLl95PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB6KCl7cmV0dXJuIHRoaXMuX3p9c2V0IHoodCl7dGhpcy5fej10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgb3JkZXIoKXtyZXR1cm4gdGhpcy5fb3JkZXJ9c2V0IG9yZGVyKHQpe3RoaXMuX29yZGVyPXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldCh0LGUscyxpPXRoaXMuX29yZGVyKXtyZXR1cm4gdGhpcy5feD10LHRoaXMuX3k9ZSx0aGlzLl96PXMsdGhpcy5fb3JkZXI9aSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LHRoaXMuX3ksdGhpcy5feix0aGlzLl9vcmRlcil9Y29weSh0KXtyZXR1cm4gdGhpcy5feD10Ll94LHRoaXMuX3k9dC5feSx0aGlzLl96PXQuX3osdGhpcy5fb3JkZXI9dC5fb3JkZXIsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KHQsZT10aGlzLl9vcmRlcixzPSEwKXtjb25zdCBpPXQuZWxlbWVudHMsbj1pWzBdLGE9aVs0XSxvPWlbOF0saD1pWzFdLGw9aVs1XSxjPWlbOV0sdT1pWzJdLG09aVs2XSxkPWlbMTBdO3N3aXRjaChlKXtjYXNlIlhZWiI6dGhpcy5feT1NYXRoLmFzaW4oTihvLC0xLDEpKSxNYXRoLmFicyhvKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKC1jLGQpLHRoaXMuX3o9TWF0aC5hdGFuMigtYSxuKSk6KHRoaXMuX3g9TWF0aC5hdGFuMihtLGwpLHRoaXMuX3o9MCk7YnJlYWs7Y2FzZSJZWFoiOnRoaXMuX3g9TWF0aC5hc2luKC1OKGMsLTEsMSkpLE1hdGguYWJzKGMpPC45OTk5OTk5Pyh0aGlzLl95PU1hdGguYXRhbjIobyxkKSx0aGlzLl96PU1hdGguYXRhbjIoaCxsKSk6KHRoaXMuX3k9TWF0aC5hdGFuMigtdSxuKSx0aGlzLl96PTApO2JyZWFrO2Nhc2UiWlhZIjp0aGlzLl94PU1hdGguYXNpbihOKG0sLTEsMSkpLE1hdGguYWJzKG0pPC45OTk5OTk5Pyh0aGlzLl95PU1hdGguYXRhbjIoLXUsZCksdGhpcy5fej1NYXRoLmF0YW4yKC1hLGwpKToodGhpcy5feT0wLHRoaXMuX3o9TWF0aC5hdGFuMihoLG4pKTticmVhaztjYXNlIlpZWCI6dGhpcy5feT1NYXRoLmFzaW4oLU4odSwtMSwxKSksTWF0aC5hYnModSk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMihtLGQpLHRoaXMuX3o9TWF0aC5hdGFuMihoLG4pKToodGhpcy5feD0wLHRoaXMuX3o9TWF0aC5hdGFuMigtYSxsKSk7YnJlYWs7Y2FzZSJZWlgiOnRoaXMuX3o9TWF0aC5hc2luKE4oaCwtMSwxKSksTWF0aC5hYnMoaCk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMigtYyxsKSx0aGlzLl95PU1hdGguYXRhbjIoLXUsbikpOih0aGlzLl94PTAsdGhpcy5feT1NYXRoLmF0YW4yKG8sZCkpO2JyZWFrO2Nhc2UiWFpZIjp0aGlzLl96PU1hdGguYXNpbigtTihhLC0xLDEpKSxNYXRoLmFicyhhKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKG0sbCksdGhpcy5feT1NYXRoLmF0YW4yKG8sbikpOih0aGlzLl94PU1hdGguYXRhbjIoLWMsZCksdGhpcy5feT0wKTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiK2UpfXJldHVybiB0aGlzLl9vcmRlcj1lLHM9PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVF1YXRlcm5pb24odCxlLHMpe3JldHVybiBWZS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbih0KSx0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeChWZSxlLHMpfXNldEZyb21WZWN0b3IzKHQsZT10aGlzLl9vcmRlcil7cmV0dXJuIHRoaXMuc2V0KHQueCx0LnksdC56LGUpfXJlb3JkZXIodCl7cmV0dXJuIFllLnNldEZyb21FdWxlcih0aGlzKSx0aGlzLnNldEZyb21RdWF0ZXJuaW9uKFllLHQpfWVxdWFscyh0KXtyZXR1cm4gdC5feD09PXRoaXMuX3gmJnQuX3k9PT10aGlzLl95JiZ0Ll96PT09dGhpcy5feiYmdC5fb3JkZXI9PT10aGlzLl9vcmRlcn1mcm9tQXJyYXkodCl7cmV0dXJuIHRoaXMuX3g9dFswXSx0aGlzLl95PXRbMV0sdGhpcy5fej10WzJdLHRbM10hPT12b2lkIDAmJih0aGlzLl9vcmRlcj10WzNdKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLl94LHRbZSsxXT10aGlzLl95LHRbZSsyXT10aGlzLl96LHRbZSszXT10aGlzLl9vcmRlcix0fV9vbkNoYW5nZSh0KXtyZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaz10LHRoaXN9X29uQ2hhbmdlQ2FsbGJhY2soKXt9KltTeW1ib2wuaXRlcmF0b3JdKCl7eWllbGQgdGhpcy5feCx5aWVsZCB0aGlzLl95LHlpZWxkIHRoaXMuX3oseWllbGQgdGhpcy5fb3JkZXJ9fWp0LkRFRkFVTFRfT1JERVI9IlhZWiI7Y2xhc3MgS3N7Y29uc3RydWN0b3IoKXt0aGlzLm1hc2s9MX1zZXQodCl7dGhpcy5tYXNrPSgxPDx0fDApPj4+MH1lbmFibGUodCl7dGhpcy5tYXNrfD0xPDx0fDB9ZW5hYmxlQWxsKCl7dGhpcy5tYXNrPS0xfXRvZ2dsZSh0KXt0aGlzLm1hc2tePTE8PHR8MH1kaXNhYmxlKHQpe3RoaXMubWFzayY9figxPDx0fDApfWRpc2FibGVBbGwoKXt0aGlzLm1hc2s9MH10ZXN0KHQpe3JldHVybih0aGlzLm1hc2smdC5tYXNrKSE9PTB9aXNFbmFibGVkKHQpe3JldHVybih0aGlzLm1hc2smKDE8PHR8MCkpIT09MH19bGV0IHRpPTA7Y29uc3QgWGU9bmV3IGcsRXQ9bmV3IFR0LHJ0PW5ldyBLLEp0PW5ldyBnLFB0PW5ldyBnLGVpPW5ldyBnLHNpPW5ldyBUdCxHZT1uZXcgZygxLDAsMCksWmU9bmV3IGcoMCwxLDApLGplPW5ldyBnKDAsMCwxKSxpaT17dHlwZToiYWRkZWQifSxKZT17dHlwZToicmVtb3ZlZCJ9O2NsYXNzIGR0IGV4dGVuZHMgdWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuaXNPYmplY3QzRD0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTp0aSsrfSksdGhpcy51dWlkPVZ0KCksdGhpcy5uYW1lPSIiLHRoaXMudHlwZT0iT2JqZWN0M0QiLHRoaXMucGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbj1bXSx0aGlzLnVwPWR0LkRFRkFVTFRfVVAuY2xvbmUoKTtjb25zdCB0PW5ldyBnLGU9bmV3IGp0LHM9bmV3IFR0LGk9bmV3IGcoMSwxLDEpO2Z1bmN0aW9uIG4oKXtzLnNldEZyb21FdWxlcihlLCExKX1mdW5jdGlvbiBhKCl7ZS5zZXRGcm9tUXVhdGVybmlvbihzLHZvaWQgMCwhMSl9ZS5fb25DaGFuZ2Uobikscy5fb25DaGFuZ2UoYSksT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyx7cG9zaXRpb246e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOnR9LHJvdGF0aW9uOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTplfSxxdWF0ZXJuaW9uOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpzfSxzY2FsZTp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6aX0sbW9kZWxWaWV3TWF0cml4Ont2YWx1ZTpuZXcgS30sbm9ybWFsTWF0cml4Ont2YWx1ZTpuZXcgaHR9fSksdGhpcy5tYXRyaXg9bmV3IEssdGhpcy5tYXRyaXhXb3JsZD1uZXcgSyx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ZHQuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEUsdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSExLHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlPWR0LkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFLHRoaXMubGF5ZXJzPW5ldyBLcyx0aGlzLnZpc2libGU9ITAsdGhpcy5jYXN0U2hhZG93PSExLHRoaXMucmVjZWl2ZVNoYWRvdz0hMSx0aGlzLmZydXN0dW1DdWxsZWQ9ITAsdGhpcy5yZW5kZXJPcmRlcj0wLHRoaXMuYW5pbWF0aW9ucz1bXSx0aGlzLnVzZXJEYXRhPXt9fW9uQmVmb3JlUmVuZGVyKCl7fW9uQWZ0ZXJSZW5kZXIoKXt9YXBwbHlNYXRyaXg0KHQpe3RoaXMubWF0cml4QXV0b1VwZGF0ZSYmdGhpcy51cGRhdGVNYXRyaXgoKSx0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSh0KSx0aGlzLm1hdHJpeC5kZWNvbXBvc2UodGhpcy5wb3NpdGlvbix0aGlzLnF1YXRlcm5pb24sdGhpcy5zY2FsZSl9YXBwbHlRdWF0ZXJuaW9uKHQpe3JldHVybiB0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkodCksdGhpc31zZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUodCxlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSh0LGUpfXNldFJvdGF0aW9uRnJvbUV1bGVyKHQpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIodCwhMCl9c2V0Um90YXRpb25Gcm9tTWF0cml4KHQpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgodCl9c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0KXt0aGlzLnF1YXRlcm5pb24uY29weSh0KX1yb3RhdGVPbkF4aXModCxlKXtyZXR1cm4gRXQuc2V0RnJvbUF4aXNBbmdsZSh0LGUpLHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShFdCksdGhpc31yb3RhdGVPbldvcmxkQXhpcyh0LGUpe3JldHVybiBFdC5zZXRGcm9tQXhpc0FuZ2xlKHQsZSksdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KEV0KSx0aGlzfXJvdGF0ZVgodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKEdlLHQpfXJvdGF0ZVkodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKFplLHQpfXJvdGF0ZVoodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGplLHQpfXRyYW5zbGF0ZU9uQXhpcyh0LGUpe3JldHVybiBYZS5jb3B5KHQpLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pLHRoaXMucG9zaXRpb24uYWRkKFhlLm11bHRpcGx5U2NhbGFyKGUpKSx0aGlzfXRyYW5zbGF0ZVgodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKEdlLHQpfXRyYW5zbGF0ZVkodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKFplLHQpfXRyYW5zbGF0ZVoodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGplLHQpfWxvY2FsVG9Xb3JsZCh0KXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdC5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCl9d29ybGRUb0xvY2FsKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0LmFwcGx5TWF0cml4NChydC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpKX1sb29rQXQodCxlLHMpe3QuaXNWZWN0b3IzP0p0LmNvcHkodCk6SnQuc2V0KHQsZSxzKTtjb25zdCBpPXRoaXMucGFyZW50O3RoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLFB0LnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKSx0aGlzLmlzQ2FtZXJhfHx0aGlzLmlzTGlnaHQ/cnQubG9va0F0KFB0LEp0LHRoaXMudXApOnJ0Lmxvb2tBdChKdCxQdCx0aGlzLnVwKSx0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KHJ0KSxpJiYocnQuZXh0cmFjdFJvdGF0aW9uKGkubWF0cml4V29ybGQpLEV0LnNldEZyb21Sb3RhdGlvbk1hdHJpeChydCksdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KEV0LmludmVydCgpKSl9YWRkKHQpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKGxldCBlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0aGlzLmFkZChhcmd1bWVudHNbZV0pO3JldHVybiB0aGlzfXJldHVybiB0PT09dGhpcz8oY29uc29sZS5lcnJvcigiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuIix0KSx0aGlzKToodCYmdC5pc09iamVjdDNEPyh0LnBhcmVudCE9PW51bGwmJnQucGFyZW50LnJlbW92ZSh0KSx0LnBhcmVudD10aGlzLHRoaXMuY2hpbGRyZW4ucHVzaCh0KSx0LmRpc3BhdGNoRXZlbnQoaWkpKTpjb25zb2xlLmVycm9yKCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuIix0KSx0aGlzKX1yZW1vdmUodCl7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IobGV0IHM9MDtzPGFyZ3VtZW50cy5sZW5ndGg7cysrKXRoaXMucmVtb3ZlKGFyZ3VtZW50c1tzXSk7cmV0dXJuIHRoaXN9Y29uc3QgZT10aGlzLmNoaWxkcmVuLmluZGV4T2YodCk7cmV0dXJuIGUhPT0tMSYmKHQucGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbi5zcGxpY2UoZSwxKSx0LmRpc3BhdGNoRXZlbnQoSmUpKSx0aGlzfXJlbW92ZUZyb21QYXJlbnQoKXtjb25zdCB0PXRoaXMucGFyZW50O3JldHVybiB0IT09bnVsbCYmdC5yZW1vdmUodGhpcyksdGhpc31jbGVhcigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5jaGlsZHJlbi5sZW5ndGg7dCsrKXtjb25zdCBlPXRoaXMuY2hpbGRyZW5bdF07ZS5wYXJlbnQ9bnVsbCxlLmRpc3BhdGNoRXZlbnQoSmUpfXJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aD0wLHRoaXN9YXR0YWNoKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxydC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpLHQucGFyZW50IT09bnVsbCYmKHQucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxydC5tdWx0aXBseSh0LnBhcmVudC5tYXRyaXhXb3JsZCkpLHQuYXBwbHlNYXRyaXg0KHJ0KSx0aGlzLmFkZCh0KSx0LnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKSx0aGlzfWdldE9iamVjdEJ5SWQodCl7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgiaWQiLHQpfWdldE9iamVjdEJ5TmFtZSh0KXtyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCJuYW1lIix0KX1nZXRPYmplY3RCeVByb3BlcnR5KHQsZSl7aWYodGhpc1t0XT09PWUpcmV0dXJuIHRoaXM7Zm9yKGxldCBzPTAsaT10aGlzLmNoaWxkcmVuLmxlbmd0aDtzPGk7cysrKXtjb25zdCBhPXRoaXMuY2hpbGRyZW5bc10uZ2V0T2JqZWN0QnlQcm9wZXJ0eSh0LGUpO2lmKGEhPT12b2lkIDApcmV0dXJuIGF9fWdldE9iamVjdHNCeVByb3BlcnR5KHQsZSl7bGV0IHM9W107dGhpc1t0XT09PWUmJnMucHVzaCh0aGlzKTtmb3IobGV0IGk9MCxuPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2k8bjtpKyspe2NvbnN0IGE9dGhpcy5jaGlsZHJlbltpXS5nZXRPYmplY3RzQnlQcm9wZXJ0eSh0LGUpO2EubGVuZ3RoPjAmJihzPXMuY29uY2F0KGEpKX1yZXR1cm4gc31nZXRXb3JsZFBvc2l0aW9uKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0LnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKX1nZXRXb3JsZFF1YXRlcm5pb24odCl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKFB0LHQsZWkpLHR9Z2V0V29ybGRTY2FsZSh0KXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoUHQsc2ksdCksdH1nZXRXb3JsZERpcmVjdGlvbih0KXt0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKTtjb25zdCBlPXRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7cmV0dXJuIHQuc2V0KGVbOF0sZVs5XSxlWzEwXSkubm9ybWFsaXplKCl9cmF5Y2FzdCgpe310cmF2ZXJzZSh0KXt0KHRoaXMpO2NvbnN0IGU9dGhpcy5jaGlsZHJlbjtmb3IobGV0IHM9MCxpPWUubGVuZ3RoO3M8aTtzKyspZVtzXS50cmF2ZXJzZSh0KX10cmF2ZXJzZVZpc2libGUodCl7aWYodGhpcy52aXNpYmxlPT09ITEpcmV0dXJuO3QodGhpcyk7Y29uc3QgZT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcz0wLGk9ZS5sZW5ndGg7czxpO3MrKyllW3NdLnRyYXZlcnNlVmlzaWJsZSh0KX10cmF2ZXJzZUFuY2VzdG9ycyh0KXtjb25zdCBlPXRoaXMucGFyZW50O2UhPT1udWxsJiYodChlKSxlLnRyYXZlcnNlQW5jZXN0b3JzKHQpKX11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH11cGRhdGVNYXRyaXhXb3JsZCh0KXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZXx8dCkmJih0aGlzLnBhcmVudD09PW51bGw/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMSx0PSEwKTtjb25zdCBlPXRoaXMuY2hpbGRyZW47Zm9yKGxldCBzPTAsaT1lLmxlbmd0aDtzPGk7cysrKXtjb25zdCBuPWVbc107KG4ubWF0cml4V29ybGRBdXRvVXBkYXRlPT09ITB8fHQ9PT0hMCkmJm4udXBkYXRlTWF0cml4V29ybGQodCl9fXVwZGF0ZVdvcmxkTWF0cml4KHQsZSl7Y29uc3Qgcz10aGlzLnBhcmVudDtpZih0PT09ITAmJnMhPT1udWxsJiZzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiZzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksdGhpcy5wYXJlbnQ9PT1udWxsP3RoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk6dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLHRoaXMubWF0cml4KSxlPT09ITApe2NvbnN0IGk9dGhpcy5jaGlsZHJlbjtmb3IobGV0IG49MCxhPWkubGVuZ3RoO248YTtuKyspe2NvbnN0IG89aVtuXTtvLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZT09PSEwJiZvLnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKX19fXRvSlNPTih0KXtjb25zdCBlPXQ9PT12b2lkIDB8fHR5cGVvZiB0PT0ic3RyaW5nIixzPXt9O2UmJih0PXtnZW9tZXRyaWVzOnt9LG1hdGVyaWFsczp7fSx0ZXh0dXJlczp7fSxpbWFnZXM6e30sc2hhcGVzOnt9LHNrZWxldG9uczp7fSxhbmltYXRpb25zOnt9LG5vZGVzOnt9fSxzLm1ldGFkYXRhPXt2ZXJzaW9uOjQuNix0eXBlOiJPYmplY3QiLGdlbmVyYXRvcjoiT2JqZWN0M0QudG9KU09OIn0pO2NvbnN0IGk9e307aS51dWlkPXRoaXMudXVpZCxpLnR5cGU9dGhpcy50eXBlLHRoaXMubmFtZSE9PSIiJiYoaS5uYW1lPXRoaXMubmFtZSksdGhpcy5jYXN0U2hhZG93PT09ITAmJihpLmNhc3RTaGFkb3c9ITApLHRoaXMucmVjZWl2ZVNoYWRvdz09PSEwJiYoaS5yZWNlaXZlU2hhZG93PSEwKSx0aGlzLnZpc2libGU9PT0hMSYmKGkudmlzaWJsZT0hMSksdGhpcy5mcnVzdHVtQ3VsbGVkPT09ITEmJihpLmZydXN0dW1DdWxsZWQ9ITEpLHRoaXMucmVuZGVyT3JkZXIhPT0wJiYoaS5yZW5kZXJPcmRlcj10aGlzLnJlbmRlck9yZGVyKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKGkudXNlckRhdGE9dGhpcy51c2VyRGF0YSksaS5sYXllcnM9dGhpcy5sYXllcnMubWFzayxpLm1hdHJpeD10aGlzLm1hdHJpeC50b0FycmF5KCksaS51cD10aGlzLnVwLnRvQXJyYXkoKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9PT0hMSYmKGkubWF0cml4QXV0b1VwZGF0ZT0hMSksdGhpcy5pc0luc3RhbmNlZE1lc2gmJihpLnR5cGU9Ikluc3RhbmNlZE1lc2giLGkuY291bnQ9dGhpcy5jb3VudCxpLmluc3RhbmNlTWF0cml4PXRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCksdGhpcy5pbnN0YW5jZUNvbG9yIT09bnVsbCYmKGkuaW5zdGFuY2VDb2xvcj10aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCkpKTtmdW5jdGlvbiBuKG8saCl7cmV0dXJuIG9baC51dWlkXT09PXZvaWQgMCYmKG9baC51dWlkXT1oLnRvSlNPTih0KSksaC51dWlkfWlmKHRoaXMuaXNTY2VuZSl0aGlzLmJhY2tncm91bmQmJih0aGlzLmJhY2tncm91bmQuaXNDb2xvcj9pLmJhY2tncm91bmQ9dGhpcy5iYWNrZ3JvdW5kLnRvSlNPTigpOnRoaXMuYmFja2dyb3VuZC5pc1RleHR1cmUmJihpLmJhY2tncm91bmQ9dGhpcy5iYWNrZ3JvdW5kLnRvSlNPTih0KS51dWlkKSksdGhpcy5lbnZpcm9ubWVudCYmdGhpcy5lbnZpcm9ubWVudC5pc1RleHR1cmUmJnRoaXMuZW52aXJvbm1lbnQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlIT09ITAmJihpLmVudmlyb25tZW50PXRoaXMuZW52aXJvbm1lbnQudG9KU09OKHQpLnV1aWQpO2Vsc2UgaWYodGhpcy5pc01lc2h8fHRoaXMuaXNMaW5lfHx0aGlzLmlzUG9pbnRzKXtpLmdlb21ldHJ5PW4odC5nZW9tZXRyaWVzLHRoaXMuZ2VvbWV0cnkpO2NvbnN0IG89dGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO2lmKG8hPT12b2lkIDAmJm8uc2hhcGVzIT09dm9pZCAwKXtjb25zdCBoPW8uc2hhcGVzO2lmKEFycmF5LmlzQXJyYXkoaCkpZm9yKGxldCBsPTAsYz1oLmxlbmd0aDtsPGM7bCsrKXtjb25zdCB1PWhbbF07bih0LnNoYXBlcyx1KX1lbHNlIG4odC5zaGFwZXMsaCl9fWlmKHRoaXMuaXNTa2lubmVkTWVzaCYmKGkuYmluZE1vZGU9dGhpcy5iaW5kTW9kZSxpLmJpbmRNYXRyaXg9dGhpcy5iaW5kTWF0cml4LnRvQXJyYXkoKSx0aGlzLnNrZWxldG9uIT09dm9pZCAwJiYobih0LnNrZWxldG9ucyx0aGlzLnNrZWxldG9uKSxpLnNrZWxldG9uPXRoaXMuc2tlbGV0b24udXVpZCkpLHRoaXMubWF0ZXJpYWwhPT12b2lkIDApaWYoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSl7Y29uc3Qgbz1bXTtmb3IobGV0IGg9MCxsPXRoaXMubWF0ZXJpYWwubGVuZ3RoO2g8bDtoKyspby5wdXNoKG4odC5tYXRlcmlhbHMsdGhpcy5tYXRlcmlhbFtoXSkpO2kubWF0ZXJpYWw9b31lbHNlIGkubWF0ZXJpYWw9bih0Lm1hdGVyaWFscyx0aGlzLm1hdGVyaWFsKTtpZih0aGlzLmNoaWxkcmVuLmxlbmd0aD4wKXtpLmNoaWxkcmVuPVtdO2ZvcihsZXQgbz0wO288dGhpcy5jaGlsZHJlbi5sZW5ndGg7bysrKWkuY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW29dLnRvSlNPTih0KS5vYmplY3QpfWlmKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg+MCl7aS5hbmltYXRpb25zPVtdO2ZvcihsZXQgbz0wO288dGhpcy5hbmltYXRpb25zLmxlbmd0aDtvKyspe2NvbnN0IGg9dGhpcy5hbmltYXRpb25zW29dO2kuYW5pbWF0aW9ucy5wdXNoKG4odC5hbmltYXRpb25zLGgpKX19aWYoZSl7Y29uc3Qgbz1hKHQuZ2VvbWV0cmllcyksaD1hKHQubWF0ZXJpYWxzKSxsPWEodC50ZXh0dXJlcyksYz1hKHQuaW1hZ2VzKSx1PWEodC5zaGFwZXMpLG09YSh0LnNrZWxldG9ucyksZD1hKHQuYW5pbWF0aW9ucyksZj1hKHQubm9kZXMpO28ubGVuZ3RoPjAmJihzLmdlb21ldHJpZXM9byksaC5sZW5ndGg+MCYmKHMubWF0ZXJpYWxzPWgpLGwubGVuZ3RoPjAmJihzLnRleHR1cmVzPWwpLGMubGVuZ3RoPjAmJihzLmltYWdlcz1jKSx1Lmxlbmd0aD4wJiYocy5zaGFwZXM9dSksbS5sZW5ndGg+MCYmKHMuc2tlbGV0b25zPW0pLGQubGVuZ3RoPjAmJihzLmFuaW1hdGlvbnM9ZCksZi5sZW5ndGg+MCYmKHMubm9kZXM9Zil9cmV0dXJuIHMub2JqZWN0PWkscztmdW5jdGlvbiBhKG8pe2NvbnN0IGg9W107Zm9yKGNvbnN0IGwgaW4gbyl7Y29uc3QgYz1vW2xdO2RlbGV0ZSBjLm1ldGFkYXRhLGgucHVzaChjKX1yZXR1cm4gaH19Y2xvbmUodCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzLHQpfWNvcHkodCxlPSEwKXtpZih0aGlzLm5hbWU9dC5uYW1lLHRoaXMudXAuY29weSh0LnVwKSx0aGlzLnBvc2l0aW9uLmNvcHkodC5wb3NpdGlvbiksdGhpcy5yb3RhdGlvbi5vcmRlcj10LnJvdGF0aW9uLm9yZGVyLHRoaXMucXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbiksdGhpcy5zY2FsZS5jb3B5KHQuc2NhbGUpLHRoaXMubWF0cml4LmNvcHkodC5tYXRyaXgpLHRoaXMubWF0cml4V29ybGQuY29weSh0Lm1hdHJpeFdvcmxkKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9dC5tYXRyaXhBdXRvVXBkYXRlLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT10Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUsdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9dC5tYXRyaXhXb3JsZEF1dG9VcGRhdGUsdGhpcy5sYXllcnMubWFzaz10LmxheWVycy5tYXNrLHRoaXMudmlzaWJsZT10LnZpc2libGUsdGhpcy5jYXN0U2hhZG93PXQuY2FzdFNoYWRvdyx0aGlzLnJlY2VpdmVTaGFkb3c9dC5yZWNlaXZlU2hhZG93LHRoaXMuZnJ1c3R1bUN1bGxlZD10LmZydXN0dW1DdWxsZWQsdGhpcy5yZW5kZXJPcmRlcj10LnJlbmRlck9yZGVyLHRoaXMuYW5pbWF0aW9ucz10LmFuaW1hdGlvbnMsdGhpcy51c2VyRGF0YT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQudXNlckRhdGEpKSxlPT09ITApZm9yKGxldCBzPTA7czx0LmNoaWxkcmVuLmxlbmd0aDtzKyspe2NvbnN0IGk9dC5jaGlsZHJlbltzXTt0aGlzLmFkZChpLmNsb25lKCkpfXJldHVybiB0aGlzfX1kdC5ERUZBVUxUX1VQPW5ldyBnKDAsMSwwKSxkdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURT0hMCxkdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURT0hMDtjb25zdCBRZT17YWxpY2VibHVlOjE1NzkyMzgzLGFudGlxdWV3aGl0ZToxNjQ0NDM3NSxhcXVhOjY1NTM1LGFxdWFtYXJpbmU6ODM4ODU2NCxhenVyZToxNTc5NDE3NSxiZWlnZToxNjExOTI2MCxiaXNxdWU6MTY3NzAyNDQsYmxhY2s6MCxibGFuY2hlZGFsbW9uZDoxNjc3MjA0NSxibHVlOjI1NSxibHVldmlvbGV0OjkwNTUyMDIsYnJvd246MTA4MjQyMzQsYnVybHl3b29kOjE0NTk2MjMxLGNhZGV0Ymx1ZTo2MjY2NTI4LGNoYXJ0cmV1c2U6ODM4ODM1MixjaG9jb2xhdGU6MTM3ODk0NzAsY29yYWw6MTY3NDQyNzIsY29ybmZsb3dlcmJsdWU6NjU5MTk4MSxjb3Juc2lsazoxNjc3NTM4OCxjcmltc29uOjE0NDIzMTAwLGN5YW46NjU1MzUsZGFya2JsdWU6MTM5LGRhcmtjeWFuOjM1NzIzLGRhcmtnb2xkZW5yb2Q6MTIwOTI5MzksZGFya2dyYXk6MTExMTkwMTcsZGFya2dyZWVuOjI1NjAwLGRhcmtncmV5OjExMTE5MDE3LGRhcmtraGFraToxMjQzMzI1OSxkYXJrbWFnZW50YTo5MTA5NjQzLGRhcmtvbGl2ZWdyZWVuOjU1OTc5OTksZGFya29yYW5nZToxNjc0NzUyMCxkYXJrb3JjaGlkOjEwMDQwMDEyLGRhcmtyZWQ6OTEwOTUwNCxkYXJrc2FsbW9uOjE1MzA4NDEwLGRhcmtzZWFncmVlbjo5NDE5OTE5LGRhcmtzbGF0ZWJsdWU6NDczNDM0NyxkYXJrc2xhdGVncmF5OjMxMDA0OTUsZGFya3NsYXRlZ3JleTozMTAwNDk1LGRhcmt0dXJxdW9pc2U6NTI5NDUsZGFya3Zpb2xldDo5Njk5NTM5LGRlZXBwaW5rOjE2NzE2OTQ3LGRlZXBza3libHVlOjQ5MTUxLGRpbWdyYXk6NjkwODI2NSxkaW1ncmV5OjY5MDgyNjUsZG9kZ2VyYmx1ZToyMDAzMTk5LGZpcmVicmljazoxMTY3NDE0NixmbG9yYWx3aGl0ZToxNjc3NTkyMCxmb3Jlc3RncmVlbjoyMjYzODQyLGZ1Y2hzaWE6MTY3MTE5MzUsZ2FpbnNib3JvOjE0NDc0NDYwLGdob3N0d2hpdGU6MTYzMTY2NzEsZ29sZDoxNjc2NjcyMCxnb2xkZW5yb2Q6MTQzMjkxMjAsZ3JheTo4NDIxNTA0LGdyZWVuOjMyNzY4LGdyZWVueWVsbG93OjExNDAzMDU1LGdyZXk6ODQyMTUwNCxob25leWRldzoxNTc5NDE2MCxob3RwaW5rOjE2NzM4NzQwLGluZGlhbnJlZDoxMzQ1ODUyNCxpbmRpZ286NDkxNTMzMCxpdm9yeToxNjc3NzIwMCxraGFraToxNTc4NzY2MCxsYXZlbmRlcjoxNTEzMjQxMCxsYXZlbmRlcmJsdXNoOjE2NzczMzY1LGxhd25ncmVlbjo4MTkwOTc2LGxlbW9uY2hpZmZvbjoxNjc3NTg4NSxsaWdodGJsdWU6MTEzOTMyNTQsbGlnaHRjb3JhbDoxNTc2MTUzNixsaWdodGN5YW46MTQ3NDU1OTksbGlnaHRnb2xkZW5yb2R5ZWxsb3c6MTY0NDgyMTAsbGlnaHRncmF5OjEzODgyMzIzLGxpZ2h0Z3JlZW46OTQ5ODI1NixsaWdodGdyZXk6MTM4ODIzMjMsbGlnaHRwaW5rOjE2NzU4NDY1LGxpZ2h0c2FsbW9uOjE2NzUyNzYyLGxpZ2h0c2VhZ3JlZW46MjE0Mjg5MCxsaWdodHNreWJsdWU6ODkwMDM0NixsaWdodHNsYXRlZ3JheTo3ODMzNzUzLGxpZ2h0c2xhdGVncmV5Ojc4MzM3NTMsbGlnaHRzdGVlbGJsdWU6MTE1ODQ3MzQsbGlnaHR5ZWxsb3c6MTY3NzcxODQsbGltZTo2NTI4MCxsaW1lZ3JlZW46MzMyOTMzMCxsaW5lbjoxNjQ0NTY3MCxtYWdlbnRhOjE2NzExOTM1LG1hcm9vbjo4Mzg4NjA4LG1lZGl1bWFxdWFtYXJpbmU6NjczNzMyMixtZWRpdW1ibHVlOjIwNSxtZWRpdW1vcmNoaWQ6MTIyMTE2NjcsbWVkaXVtcHVycGxlOjk2NjI2ODMsbWVkaXVtc2VhZ3JlZW46Mzk3ODA5NyxtZWRpdW1zbGF0ZWJsdWU6ODA4Nzc5MCxtZWRpdW1zcHJpbmdncmVlbjo2NDE1NCxtZWRpdW10dXJxdW9pc2U6NDc3MjMwMCxtZWRpdW12aW9sZXRyZWQ6MTMwNDcxNzMsbWlkbmlnaHRibHVlOjE2NDQ5MTIsbWludGNyZWFtOjE2MTIxODUwLG1pc3R5cm9zZToxNjc3MDI3Myxtb2NjYXNpbjoxNjc3MDIyOSxuYXZham93aGl0ZToxNjc2ODY4NSxuYXZ5OjEyOCxvbGRsYWNlOjE2NjQzNTU4LG9saXZlOjg0MjEzNzYsb2xpdmVkcmFiOjcwNDg3Mzksb3JhbmdlOjE2NzUzOTIwLG9yYW5nZXJlZDoxNjcyOTM0NCxvcmNoaWQ6MTQzMTU3MzQscGFsZWdvbGRlbnJvZDoxNTY1NzEzMCxwYWxlZ3JlZW46MTAwMjU4ODAscGFsZXR1cnF1b2lzZToxMTUyOTk2NixwYWxldmlvbGV0cmVkOjE0MzgxMjAzLHBhcGF5YXdoaXA6MTY3NzMwNzcscGVhY2hwdWZmOjE2NzY3NjczLHBlcnU6MTM0Njg5OTEscGluazoxNjc2MTAzNSxwbHVtOjE0NTI0NjM3LHBvd2RlcmJsdWU6MTE1OTE5MTAscHVycGxlOjgzODg3MzYscmViZWNjYXB1cnBsZTo2Njk3ODgxLHJlZDoxNjcxMTY4MCxyb3N5YnJvd246MTIzNTc1MTkscm95YWxibHVlOjQyODY5NDUsc2FkZGxlYnJvd246OTEyNzE4NyxzYWxtb246MTY0MTY4ODIsc2FuZHlicm93bjoxNjAzMjg2NCxzZWFncmVlbjozMDUwMzI3LHNlYXNoZWxsOjE2Nzc0NjM4LHNpZW5uYToxMDUwNjc5NyxzaWx2ZXI6MTI2MzIyNTYsc2t5Ymx1ZTo4OTAwMzMxLHNsYXRlYmx1ZTo2OTcwMDYxLHNsYXRlZ3JheTo3MzcyOTQ0LHNsYXRlZ3JleTo3MzcyOTQ0LHNub3c6MTY3NzU5MzAsc3ByaW5nZ3JlZW46NjU0MDcsc3RlZWxibHVlOjQ2MjA5ODAsdGFuOjEzODA4NzgwLHRlYWw6MzI4OTYsdGhpc3RsZToxNDIwNDg4OCx0b21hdG86MTY3MzcwOTUsdHVycXVvaXNlOjQyNTE4NTYsdmlvbGV0OjE1NjMxMDg2LHdoZWF0OjE2MTEzMzMxLHdoaXRlOjE2Nzc3MjE1LHdoaXRlc21va2U6MTYxMTkyODUseWVsbG93OjE2Nzc2OTYwLHllbGxvd2dyZWVuOjEwMTQ1MDc0fSxRPXtoOjAsczowLGw6MH0sUXQ9e2g6MCxzOjAsbDowfTtmdW5jdGlvbiBNZShyLHQsZSl7cmV0dXJuIGU8MCYmKGUrPTEpLGU+MSYmKGUtPTEpLGU8MS82P3IrKHQtcikqNiplOmU8MS8yP3Q6ZTwyLzM/cisodC1yKSo2KigyLzMtZSk6cn1jbGFzcyB3ZXtjb25zdHJ1Y3Rvcih0LGUscyl7cmV0dXJuIHRoaXMuaXNDb2xvcj0hMCx0aGlzLnI9MSx0aGlzLmc9MSx0aGlzLmI9MSx0aGlzLnNldCh0LGUscyl9c2V0KHQsZSxzKXtpZihlPT09dm9pZCAwJiZzPT09dm9pZCAwKXtjb25zdCBpPXQ7aSYmaS5pc0NvbG9yP3RoaXMuY29weShpKTp0eXBlb2YgaT09Im51bWJlciI/dGhpcy5zZXRIZXgoaSk6dHlwZW9mIGk9PSJzdHJpbmciJiZ0aGlzLnNldFN0eWxlKGkpfWVsc2UgdGhpcy5zZXRSR0IodCxlLHMpO3JldHVybiB0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy5yPXQsdGhpcy5nPXQsdGhpcy5iPXQsdGhpc31zZXRIZXgodCxlPUcpe3JldHVybiB0PU1hdGguZmxvb3IodCksdGhpcy5yPSh0Pj4xNiYyNTUpLzI1NSx0aGlzLmc9KHQ+PjgmMjU1KS8yNTUsdGhpcy5iPSh0JjI1NSkvMjU1LGoudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLGUpLHRoaXN9c2V0UkdCKHQsZSxzLGk9ai53b3JraW5nQ29sb3JTcGFjZSl7cmV0dXJuIHRoaXMucj10LHRoaXMuZz1lLHRoaXMuYj1zLGoudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLGkpLHRoaXN9c2V0SFNMKHQsZSxzLGk9ai53b3JraW5nQ29sb3JTcGFjZSl7aWYodD1Qcyh0LDEpLGU9TihlLDAsMSkscz1OKHMsMCwxKSxlPT09MCl0aGlzLnI9dGhpcy5nPXRoaXMuYj1zO2Vsc2V7Y29uc3Qgbj1zPD0uNT9zKigxK2UpOnMrZS1zKmUsYT0yKnMtbjt0aGlzLnI9TWUoYSxuLHQrMS8zKSx0aGlzLmc9TWUoYSxuLHQpLHRoaXMuYj1NZShhLG4sdC0xLzMpfXJldHVybiBqLnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcyxpKSx0aGlzfXNldFN0eWxlKHQsZT1HKXtmdW5jdGlvbiBzKG4pe24hPT12b2lkIDAmJnBhcnNlRmxvYXQobik8MSYmY29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICIrdCsiIHdpbGwgYmUgaWdub3JlZC4iKX1sZXQgaTtpZihpPS9eKFx3KylcKChbXlwpXSopXCkvLmV4ZWModCkpe2xldCBuO2NvbnN0IGE9aVsxXSxvPWlbMl07c3dpdGNoKGEpe2Nhc2UicmdiIjpjYXNlInJnYmEiOmlmKG49L15ccyooXGQrKVxzKixccyooXGQrKVxzKixccyooXGQrKVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhvKSlyZXR1cm4gcyhuWzRdKSx0aGlzLnNldFJHQihNYXRoLm1pbigyNTUscGFyc2VJbnQoblsxXSwxMCkpLzI1NSxNYXRoLm1pbigyNTUscGFyc2VJbnQoblsyXSwxMCkpLzI1NSxNYXRoLm1pbigyNTUscGFyc2VJbnQoblszXSwxMCkpLzI1NSxlKTtpZihuPS9eXHMqKFxkKylcJVxzKixccyooXGQrKVwlXHMqLFxzKihcZCspXCVccyooPzosXHMqKFxkKlwuP1xkKylccyopPyQvLmV4ZWMobykpcmV0dXJuIHMobls0XSksdGhpcy5zZXRSR0IoTWF0aC5taW4oMTAwLHBhcnNlSW50KG5bMV0sMTApKS8xMDAsTWF0aC5taW4oMTAwLHBhcnNlSW50KG5bMl0sMTApKS8xMDAsTWF0aC5taW4oMTAwLHBhcnNlSW50KG5bM10sMTApKS8xMDAsZSk7YnJlYWs7Y2FzZSJoc2wiOmNhc2UiaHNsYSI6aWYobj0vXlxzKihcZCpcLj9cZCspXHMqLFxzKihcZCpcLj9cZCspXCVccyosXHMqKFxkKlwuP1xkKylcJVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhvKSlyZXR1cm4gcyhuWzRdKSx0aGlzLnNldEhTTChwYXJzZUZsb2F0KG5bMV0pLzM2MCxwYXJzZUZsb2F0KG5bMl0pLzEwMCxwYXJzZUZsb2F0KG5bM10pLzEwMCxlKTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgbW9kZWwgIit0KX19ZWxzZSBpZihpPS9eXCMoW0EtRmEtZlxkXSspJC8uZXhlYyh0KSl7Y29uc3Qgbj1pWzFdLGE9bi5sZW5ndGg7aWYoYT09PTMpcmV0dXJuIHRoaXMuc2V0UkdCKHBhcnNlSW50KG4uY2hhckF0KDApLDE2KS8xNSxwYXJzZUludChuLmNoYXJBdCgxKSwxNikvMTUscGFyc2VJbnQobi5jaGFyQXQoMiksMTYpLzE1LGUpO2lmKGE9PT02KXJldHVybiB0aGlzLnNldEhleChwYXJzZUludChuLDE2KSxlKTtjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBJbnZhbGlkIGhleCBjb2xvciAiK3QpfWVsc2UgaWYodCYmdC5sZW5ndGg+MClyZXR1cm4gdGhpcy5zZXRDb2xvck5hbWUodCxlKTtyZXR1cm4gdGhpc31zZXRDb2xvck5hbWUodCxlPUcpe2NvbnN0IHM9UWVbdC50b0xvd2VyQ2FzZSgpXTtyZXR1cm4gcyE9PXZvaWQgMD90aGlzLnNldEhleChzLGUpOmNvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgIit0KSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucix0aGlzLmcsdGhpcy5iKX1jb3B5KHQpe3JldHVybiB0aGlzLnI9dC5yLHRoaXMuZz10LmcsdGhpcy5iPXQuYix0aGlzfWNvcHlTUkdCVG9MaW5lYXIodCl7cmV0dXJuIHRoaXMucj13dCh0LnIpLHRoaXMuZz13dCh0LmcpLHRoaXMuYj13dCh0LmIpLHRoaXN9Y29weUxpbmVhclRvU1JHQih0KXtyZXR1cm4gdGhpcy5yPXllKHQuciksdGhpcy5nPXllKHQuZyksdGhpcy5iPXllKHQuYiksdGhpc31jb252ZXJ0U1JHQlRvTGluZWFyKCl7cmV0dXJuIHRoaXMuY29weVNSR0JUb0xpbmVhcih0aGlzKSx0aGlzfWNvbnZlcnRMaW5lYXJUb1NSR0IoKXtyZXR1cm4gdGhpcy5jb3B5TGluZWFyVG9TUkdCKHRoaXMpLHRoaXN9Z2V0SGV4KHQ9Ryl7cmV0dXJuIGouZnJvbVdvcmtpbmdDb2xvclNwYWNlKFUuY29weSh0aGlzKSx0KSxNYXRoLnJvdW5kKE4oVS5yKjI1NSwwLDI1NSkpKjY1NTM2K01hdGgucm91bmQoTihVLmcqMjU1LDAsMjU1KSkqMjU2K01hdGgucm91bmQoTihVLmIqMjU1LDAsMjU1KSl9Z2V0SGV4U3RyaW5nKHQ9Ryl7cmV0dXJuKCIwMDAwMDAiK3RoaXMuZ2V0SGV4KHQpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpfWdldEhTTCh0LGU9ai53b3JraW5nQ29sb3JTcGFjZSl7ai5mcm9tV29ya2luZ0NvbG9yU3BhY2UoVS5jb3B5KHRoaXMpLGUpO2NvbnN0IHM9VS5yLGk9VS5nLG49VS5iLGE9TWF0aC5tYXgocyxpLG4pLG89TWF0aC5taW4ocyxpLG4pO2xldCBoLGw7Y29uc3QgYz0obythKS8yO2lmKG89PT1hKWg9MCxsPTA7ZWxzZXtjb25zdCB1PWEtbztzd2l0Y2gobD1jPD0uNT91LyhhK28pOnUvKDItYS1vKSxhKXtjYXNlIHM6aD0oaS1uKS91KyhpPG4/NjowKTticmVhaztjYXNlIGk6aD0obi1zKS91KzI7YnJlYWs7Y2FzZSBuOmg9KHMtaSkvdSs0O2JyZWFrfWgvPTZ9cmV0dXJuIHQuaD1oLHQucz1sLHQubD1jLHR9Z2V0UkdCKHQsZT1qLndvcmtpbmdDb2xvclNwYWNlKXtyZXR1cm4gai5mcm9tV29ya2luZ0NvbG9yU3BhY2UoVS5jb3B5KHRoaXMpLGUpLHQucj1VLnIsdC5nPVUuZyx0LmI9VS5iLHR9Z2V0U3R5bGUodD1HKXtqLmZyb21Xb3JraW5nQ29sb3JTcGFjZShVLmNvcHkodGhpcyksdCk7Y29uc3QgZT1VLnIscz1VLmcsaT1VLmI7cmV0dXJuIHQhPT1HP2Bjb2xvcigke3R9ICR7ZS50b0ZpeGVkKDMpfSAke3MudG9GaXhlZCgzKX0gJHtpLnRvRml4ZWQoMyl9KWA6YHJnYigke01hdGgucm91bmQoZSoyNTUpfSwke01hdGgucm91bmQocyoyNTUpfSwke01hdGgucm91bmQoaSoyNTUpfSlgfW9mZnNldEhTTCh0LGUscyl7cmV0dXJuIHRoaXMuZ2V0SFNMKFEpLFEuaCs9dCxRLnMrPWUsUS5sKz1zLHRoaXMuc2V0SFNMKFEuaCxRLnMsUS5sKSx0aGlzfWFkZCh0KXtyZXR1cm4gdGhpcy5yKz10LnIsdGhpcy5nKz10LmcsdGhpcy5iKz10LmIsdGhpc31hZGRDb2xvcnModCxlKXtyZXR1cm4gdGhpcy5yPXQucitlLnIsdGhpcy5nPXQuZytlLmcsdGhpcy5iPXQuYitlLmIsdGhpc31hZGRTY2FsYXIodCl7cmV0dXJuIHRoaXMucis9dCx0aGlzLmcrPXQsdGhpcy5iKz10LHRoaXN9c3ViKHQpe3JldHVybiB0aGlzLnI9TWF0aC5tYXgoMCx0aGlzLnItdC5yKSx0aGlzLmc9TWF0aC5tYXgoMCx0aGlzLmctdC5nKSx0aGlzLmI9TWF0aC5tYXgoMCx0aGlzLmItdC5iKSx0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLnIqPXQucix0aGlzLmcqPXQuZyx0aGlzLmIqPXQuYix0aGlzfW11bHRpcGx5U2NhbGFyKHQpe3JldHVybiB0aGlzLnIqPXQsdGhpcy5nKj10LHRoaXMuYio9dCx0aGlzfWxlcnAodCxlKXtyZXR1cm4gdGhpcy5yKz0odC5yLXRoaXMucikqZSx0aGlzLmcrPSh0LmctdGhpcy5nKSplLHRoaXMuYis9KHQuYi10aGlzLmIpKmUsdGhpc31sZXJwQ29sb3JzKHQsZSxzKXtyZXR1cm4gdGhpcy5yPXQucisoZS5yLXQucikqcyx0aGlzLmc9dC5nKyhlLmctdC5nKSpzLHRoaXMuYj10LmIrKGUuYi10LmIpKnMsdGhpc31sZXJwSFNMKHQsZSl7dGhpcy5nZXRIU0woUSksdC5nZXRIU0woUXQpO2NvbnN0IHM9ZGUoUS5oLFF0LmgsZSksaT1kZShRLnMsUXQucyxlKSxuPWRlKFEubCxRdC5sLGUpO3JldHVybiB0aGlzLnNldEhTTChzLGksbiksdGhpc31zZXRGcm9tVmVjdG9yMyh0KXtyZXR1cm4gdGhpcy5yPXQueCx0aGlzLmc9dC55LHRoaXMuYj10LnosdGhpc31hcHBseU1hdHJpeDModCl7Y29uc3QgZT10aGlzLnIscz10aGlzLmcsaT10aGlzLmIsbj10LmVsZW1lbnRzO3JldHVybiB0aGlzLnI9blswXSplK25bM10qcytuWzZdKmksdGhpcy5nPW5bMV0qZStuWzRdKnMrbls3XSppLHRoaXMuYj1uWzJdKmUrbls1XSpzK25bOF0qaSx0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC5yPT09dGhpcy5yJiZ0Lmc9PT10aGlzLmcmJnQuYj09PXRoaXMuYn1mcm9tQXJyYXkodCxlPTApe3JldHVybiB0aGlzLnI9dFtlXSx0aGlzLmc9dFtlKzFdLHRoaXMuYj10W2UrMl0sdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLnIsdFtlKzFdPXRoaXMuZyx0W2UrMl09dGhpcy5iLHR9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpe3JldHVybiB0aGlzLnI9dC5nZXRYKGUpLHRoaXMuZz10LmdldFkoZSksdGhpcy5iPXQuZ2V0WihlKSx0aGlzfXRvSlNPTigpe3JldHVybiB0aGlzLmdldEhleCgpfSpbU3ltYm9sLml0ZXJhdG9yXSgpe3lpZWxkIHRoaXMucix5aWVsZCB0aGlzLmcseWllbGQgdGhpcy5ifX1jb25zdCBVPW5ldyB3ZTt3ZS5OQU1FUz1RZTtjb25zdCB2PW5ldyBnLEt0PW5ldyBldDtjbGFzcyBudHtjb25zdHJ1Y3Rvcih0LGUscz0hMSl7aWYoQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LiIpO3RoaXMuaXNCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5uYW1lPSIiLHRoaXMuYXJyYXk9dCx0aGlzLml0ZW1TaXplPWUsdGhpcy5jb3VudD10IT09dm9pZCAwP3QubGVuZ3RoL2U6MCx0aGlzLm5vcm1hbGl6ZWQ9cyx0aGlzLnVzYWdlPXFlLHRoaXMudXBkYXRlUmFuZ2U9e29mZnNldDowLGNvdW50Oi0xfSx0aGlzLmdwdVR5cGU9UnMsdGhpcy52ZXJzaW9uPTB9b25VcGxvYWRDYWxsYmFjaygpe31zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiZ0aGlzLnZlcnNpb24rK31zZXRVc2FnZSh0KXtyZXR1cm4gdGhpcy51c2FnZT10LHRoaXN9Y29weSh0KXtyZXR1cm4gdGhpcy5uYW1lPXQubmFtZSx0aGlzLmFycmF5PW5ldyB0LmFycmF5LmNvbnN0cnVjdG9yKHQuYXJyYXkpLHRoaXMuaXRlbVNpemU9dC5pdGVtU2l6ZSx0aGlzLmNvdW50PXQuY291bnQsdGhpcy5ub3JtYWxpemVkPXQubm9ybWFsaXplZCx0aGlzLnVzYWdlPXQudXNhZ2UsdGhpcy5ncHVUeXBlPXQuZ3B1VHlwZSx0aGlzfWNvcHlBdCh0LGUscyl7dCo9dGhpcy5pdGVtU2l6ZSxzKj1lLml0ZW1TaXplO2ZvcihsZXQgaT0wLG49dGhpcy5pdGVtU2l6ZTtpPG47aSsrKXRoaXMuYXJyYXlbdCtpXT1lLmFycmF5W3MraV07cmV0dXJuIHRoaXN9Y29weUFycmF5KHQpe3JldHVybiB0aGlzLmFycmF5LnNldCh0KSx0aGlzfWFwcGx5TWF0cml4Myh0KXtpZih0aGlzLml0ZW1TaXplPT09Milmb3IobGV0IGU9MCxzPXRoaXMuY291bnQ7ZTxzO2UrKylLdC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsZSksS3QuYXBwbHlNYXRyaXgzKHQpLHRoaXMuc2V0WFkoZSxLdC54LEt0LnkpO2Vsc2UgaWYodGhpcy5pdGVtU2l6ZT09PTMpZm9yKGxldCBlPTAscz10aGlzLmNvdW50O2U8cztlKyspdi5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsZSksdi5hcHBseU1hdHJpeDModCksdGhpcy5zZXRYWVooZSx2Lngsdi55LHYueik7cmV0dXJuIHRoaXN9YXBwbHlNYXRyaXg0KHQpe2ZvcihsZXQgZT0wLHM9dGhpcy5jb3VudDtlPHM7ZSsrKXYuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLHYuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0WFlaKGUsdi54LHYueSx2LnopO3JldHVybiB0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KHQpe2ZvcihsZXQgZT0wLHM9dGhpcy5jb3VudDtlPHM7ZSsrKXYuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLHYuYXBwbHlOb3JtYWxNYXRyaXgodCksdGhpcy5zZXRYWVooZSx2Lngsdi55LHYueik7cmV0dXJuIHRoaXN9dHJhbnNmb3JtRGlyZWN0aW9uKHQpe2ZvcihsZXQgZT0wLHM9dGhpcy5jb3VudDtlPHM7ZSsrKXYuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLHYudHJhbnNmb3JtRGlyZWN0aW9uKHQpLHRoaXMuc2V0WFlaKGUsdi54LHYueSx2LnopO3JldHVybiB0aGlzfXNldCh0LGU9MCl7cmV0dXJuIHRoaXMuYXJyYXkuc2V0KHQsZSksdGhpc31nZXRYKHQpe2xldCBlPXRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1ZdChlLHRoaXMuYXJyYXkpKSxlfXNldFgodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1WKGUsdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplXT1lLHRoaXN9Z2V0WSh0KXtsZXQgZT10aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsxXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1ZdChlLHRoaXMuYXJyYXkpKSxlfXNldFkodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1WKGUsdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplKzFdPWUsdGhpc31nZXRaKHQpe2xldCBlPXRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplKzJdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPVl0KGUsdGhpcy5hcnJheSkpLGV9c2V0Wih0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPVYoZSx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrMl09ZSx0aGlzfWdldFcodCl7bGV0IGU9dGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrM107cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9WXQoZSx0aGlzLmFycmF5KSksZX1zZXRXKHQsZSl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9VihlLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSszXT1lLHRoaXN9c2V0WFkodCxlLHMpe3JldHVybiB0Kj10aGlzLml0ZW1TaXplLHRoaXMubm9ybWFsaXplZCYmKGU9VihlLHRoaXMuYXJyYXkpLHM9VihzLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QrMF09ZSx0aGlzLmFycmF5W3QrMV09cyx0aGlzfXNldFhZWih0LGUscyxpKXtyZXR1cm4gdCo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJihlPVYoZSx0aGlzLmFycmF5KSxzPVYocyx0aGlzLmFycmF5KSxpPVYoaSx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KzBdPWUsdGhpcy5hcnJheVt0KzFdPXMsdGhpcy5hcnJheVt0KzJdPWksdGhpc31zZXRYWVpXKHQsZSxzLGksbil7cmV0dXJuIHQqPXRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkJiYoZT1WKGUsdGhpcy5hcnJheSkscz1WKHMsdGhpcy5hcnJheSksaT1WKGksdGhpcy5hcnJheSksbj1WKG4sdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCswXT1lLHRoaXMuYXJyYXlbdCsxXT1zLHRoaXMuYXJyYXlbdCsyXT1pLHRoaXMuYXJyYXlbdCszXT1uLHRoaXN9b25VcGxvYWQodCl7cmV0dXJuIHRoaXMub25VcGxvYWRDYWxsYmFjaz10LHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hcnJheSx0aGlzLml0ZW1TaXplKS5jb3B5KHRoaXMpfXRvSlNPTigpe2NvbnN0IHQ9e2l0ZW1TaXplOnRoaXMuaXRlbVNpemUsdHlwZTp0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsYXJyYXk6QXJyYXkuZnJvbSh0aGlzLmFycmF5KSxub3JtYWxpemVkOnRoaXMubm9ybWFsaXplZH07cmV0dXJuIHRoaXMubmFtZSE9PSIiJiYodC5uYW1lPXRoaXMubmFtZSksdGhpcy51c2FnZSE9PXFlJiYodC51c2FnZT10aGlzLnVzYWdlKSwodGhpcy51cGRhdGVSYW5nZS5vZmZzZXQhPT0wfHx0aGlzLnVwZGF0ZVJhbmdlLmNvdW50IT09LTEpJiYodC51cGRhdGVSYW5nZT10aGlzLnVwZGF0ZVJhbmdlKSx0fWNvcHlDb2xvcnNBcnJheSgpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogY29weUNvbG9yc0FycmF5KCkgd2FzIHJlbW92ZWQgaW4gcjE0NC4iKX1jb3B5VmVjdG9yMnNBcnJheSgpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogY29weVZlY3RvcjJzQXJyYXkoKSB3YXMgcmVtb3ZlZCBpbiByMTQ0LiIpfWNvcHlWZWN0b3Izc0FycmF5KCl7Y29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBjb3B5VmVjdG9yM3NBcnJheSgpIHdhcyByZW1vdmVkIGluIHIxNDQuIil9Y29weVZlY3RvcjRzQXJyYXkoKXtjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGNvcHlWZWN0b3I0c0FycmF5KCkgd2FzIHJlbW92ZWQgaW4gcjE0NC4iKX19Y2xhc3MgcmkgZXh0ZW5kcyBudHtjb25zdHJ1Y3Rvcih0LGUscyl7c3VwZXIobmV3IFVpbnQxNkFycmF5KHQpLGUscyl9fWNsYXNzIG5pIGV4dGVuZHMgbnR7Y29uc3RydWN0b3IodCxlLHMpe3N1cGVyKG5ldyBVaW50MzJBcnJheSh0KSxlLHMpfX1jbGFzcyBfZSBleHRlbmRzIG50e2NvbnN0cnVjdG9yKHQsZSxzKXtzdXBlcihuZXcgRmxvYXQzMkFycmF5KHQpLGUscyl9fWxldCBhaT0wO2NvbnN0IFo9bmV3IEssQWU9bmV3IGR0LEN0PW5ldyBnLFg9bmV3IFJ0LE90PW5ldyBSdCxSPW5ldyBnO2NsYXNzIHRlIGV4dGVuZHMgdWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuaXNCdWZmZXJHZW9tZXRyeT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTphaSsrfSksdGhpcy51dWlkPVZ0KCksdGhpcy5uYW1lPSIiLHRoaXMudHlwZT0iQnVmZmVyR2VvbWV0cnkiLHRoaXMuaW5kZXg9bnVsbCx0aGlzLmF0dHJpYnV0ZXM9e30sdGhpcy5tb3JwaEF0dHJpYnV0ZXM9e30sdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT0hMSx0aGlzLmdyb3Vwcz1bXSx0aGlzLmJvdW5kaW5nQm94PW51bGwsdGhpcy5ib3VuZGluZ1NwaGVyZT1udWxsLHRoaXMuZHJhd1JhbmdlPXtzdGFydDowLGNvdW50OjEvMH0sdGhpcy51c2VyRGF0YT17fX1nZXRJbmRleCgpe3JldHVybiB0aGlzLmluZGV4fXNldEluZGV4KHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP3RoaXMuaW5kZXg9bmV3KE9zKHQpP25pOnJpKSh0LDEpOnRoaXMuaW5kZXg9dCx0aGlzfWdldEF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW3RdfXNldEF0dHJpYnV0ZSh0LGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF09ZSx0aGlzfWRlbGV0ZUF0dHJpYnV0ZSh0KXtyZXR1cm4gZGVsZXRlIHRoaXMuYXR0cmlidXRlc1t0XSx0aGlzfWhhc0F0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW3RdIT09dm9pZCAwfWFkZEdyb3VwKHQsZSxzPTApe3RoaXMuZ3JvdXBzLnB1c2goe3N0YXJ0OnQsY291bnQ6ZSxtYXRlcmlhbEluZGV4OnN9KX1jbGVhckdyb3Vwcygpe3RoaXMuZ3JvdXBzPVtdfXNldERyYXdSYW5nZSh0LGUpe3RoaXMuZHJhd1JhbmdlLnN0YXJ0PXQsdGhpcy5kcmF3UmFuZ2UuY291bnQ9ZX1hcHBseU1hdHJpeDQodCl7Y29uc3QgZT10aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247ZSE9PXZvaWQgMCYmKGUuYXBwbHlNYXRyaXg0KHQpLGUubmVlZHNVcGRhdGU9ITApO2NvbnN0IHM9dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtpZihzIT09dm9pZCAwKXtjb25zdCBuPW5ldyBodCgpLmdldE5vcm1hbE1hdHJpeCh0KTtzLmFwcGx5Tm9ybWFsTWF0cml4KG4pLHMubmVlZHNVcGRhdGU9ITB9Y29uc3QgaT10aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtyZXR1cm4gaSE9PXZvaWQgMCYmKGkudHJhbnNmb3JtRGlyZWN0aW9uKHQpLGkubmVlZHNVcGRhdGU9ITApLHRoaXMuYm91bmRpbmdCb3ghPT1udWxsJiZ0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuYm91bmRpbmdTcGhlcmUhPT1udWxsJiZ0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKHQpe3JldHVybiBaLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpLHRoaXMuYXBwbHlNYXRyaXg0KFopLHRoaXN9cm90YXRlWCh0KXtyZXR1cm4gWi5tYWtlUm90YXRpb25YKHQpLHRoaXMuYXBwbHlNYXRyaXg0KFopLHRoaXN9cm90YXRlWSh0KXtyZXR1cm4gWi5tYWtlUm90YXRpb25ZKHQpLHRoaXMuYXBwbHlNYXRyaXg0KFopLHRoaXN9cm90YXRlWih0KXtyZXR1cm4gWi5tYWtlUm90YXRpb25aKHQpLHRoaXMuYXBwbHlNYXRyaXg0KFopLHRoaXN9dHJhbnNsYXRlKHQsZSxzKXtyZXR1cm4gWi5tYWtlVHJhbnNsYXRpb24odCxlLHMpLHRoaXMuYXBwbHlNYXRyaXg0KFopLHRoaXN9c2NhbGUodCxlLHMpe3JldHVybiBaLm1ha2VTY2FsZSh0LGUscyksdGhpcy5hcHBseU1hdHJpeDQoWiksdGhpc31sb29rQXQodCl7cmV0dXJuIEFlLmxvb2tBdCh0KSxBZS51cGRhdGVNYXRyaXgoKSx0aGlzLmFwcGx5TWF0cml4NChBZS5tYXRyaXgpLHRoaXN9Y2VudGVyKCl7cmV0dXJuIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoQ3QpLm5lZ2F0ZSgpLHRoaXMudHJhbnNsYXRlKEN0LngsQ3QueSxDdC56KSx0aGlzfXNldEZyb21Qb2ludHModCl7Y29uc3QgZT1bXTtmb3IobGV0IHM9MCxpPXQubGVuZ3RoO3M8aTtzKyspe2NvbnN0IG49dFtzXTtlLnB1c2gobi54LG4ueSxuLnp8fDApfXJldHVybiB0aGlzLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyBfZShlLDMpKSx0aGlzfWNvbXB1dGVCb3VuZGluZ0JveCgpe3RoaXMuYm91bmRpbmdCb3g9PT1udWxsJiYodGhpcy5ib3VuZGluZ0JveD1uZXcgUnQpO2NvbnN0IHQ9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLGU9dGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247aWYodCYmdC5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiBBbHRlcm5hdGl2ZWx5IHNldCAibWVzaC5mcnVzdHVtQ3VsbGVkIiB0byAiZmFsc2UiLicsdGhpcyksdGhpcy5ib3VuZGluZ0JveC5zZXQobmV3IGcoLTEvMCwtMS8wLC0xLzApLG5ldyBnKDEvMCwxLzAsMS8wKSk7cmV0dXJufWlmKHQhPT12b2lkIDApe2lmKHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSh0KSxlKWZvcihsZXQgcz0wLGk9ZS5sZW5ndGg7czxpO3MrKyl7Y29uc3Qgbj1lW3NdO1guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShuKSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPyhSLmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5taW4sWC5taW4pLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChSKSxSLmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5tYXgsWC5tYXgpLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChSKSk6KHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChYLm1pbiksdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KFgubWF4KSl9fWVsc2UgdGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTsoaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueCl8fGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnkpfHxpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi56KSkmJmNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlICJwb3NpdGlvbiIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJyx0aGlzKX1jb21wdXRlQm91bmRpbmdTcGhlcmUoKXt0aGlzLmJvdW5kaW5nU3BoZXJlPT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bmV3IGpzKTtjb25zdCB0PXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbixlPXRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO2lmKHQmJnQuaXNHTEJ1ZmZlckF0dHJpYnV0ZSl7Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIHNwaGVyZS4gQWx0ZXJuYXRpdmVseSBzZXQgIm1lc2guZnJ1c3R1bUN1bGxlZCIgdG8gImZhbHNlIi4nLHRoaXMpLHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KG5ldyBnLDEvMCk7cmV0dXJufWlmKHQpe2NvbnN0IHM9dGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7aWYoWC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHQpLGUpZm9yKGxldCBuPTAsYT1lLmxlbmd0aDtuPGE7bisrKXtjb25zdCBvPWVbbl07T3Quc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShvKSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPyhSLmFkZFZlY3RvcnMoWC5taW4sT3QubWluKSxYLmV4cGFuZEJ5UG9pbnQoUiksUi5hZGRWZWN0b3JzKFgubWF4LE90Lm1heCksWC5leHBhbmRCeVBvaW50KFIpKTooWC5leHBhbmRCeVBvaW50KE90Lm1pbiksWC5leHBhbmRCeVBvaW50KE90Lm1heCkpfVguZ2V0Q2VudGVyKHMpO2xldCBpPTA7Zm9yKGxldCBuPTAsYT10LmNvdW50O248YTtuKyspUi5mcm9tQnVmZmVyQXR0cmlidXRlKHQsbiksaT1NYXRoLm1heChpLHMuZGlzdGFuY2VUb1NxdWFyZWQoUikpO2lmKGUpZm9yKGxldCBuPTAsYT1lLmxlbmd0aDtuPGE7bisrKXtjb25zdCBvPWVbbl0saD10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2ZvcihsZXQgbD0wLGM9by5jb3VudDtsPGM7bCsrKVIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShvLGwpLGgmJihDdC5mcm9tQnVmZmVyQXR0cmlidXRlKHQsbCksUi5hZGQoQ3QpKSxpPU1hdGgubWF4KGkscy5kaXN0YW5jZVRvU3F1YXJlZChSKSl9dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM9TWF0aC5zcXJ0KGkpLGlzTmFOKHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzKSYmY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSAicG9zaXRpb24iIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsdGhpcyl9fWNvbXB1dGVUYW5nZW50cygpe2NvbnN0IHQ9dGhpcy5pbmRleCxlPXRoaXMuYXR0cmlidXRlcztpZih0PT09bnVsbHx8ZS5wb3NpdGlvbj09PXZvaWQgMHx8ZS5ub3JtYWw9PT12b2lkIDB8fGUudXY9PT12b2lkIDApe2NvbnNvbGUuZXJyb3IoIlRIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgZmFpbGVkLiBNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMgKGluZGV4LCBwb3NpdGlvbiwgbm9ybWFsIG9yIHV2KSIpO3JldHVybn1jb25zdCBzPXQuYXJyYXksaT1lLnBvc2l0aW9uLmFycmF5LG49ZS5ub3JtYWwuYXJyYXksYT1lLnV2LmFycmF5LG89aS5sZW5ndGgvMzt0aGlzLmhhc0F0dHJpYnV0ZSgidGFuZ2VudCIpPT09ITEmJnRoaXMuc2V0QXR0cmlidXRlKCJ0YW5nZW50IixuZXcgbnQobmV3IEZsb2F0MzJBcnJheSg0Km8pLDQpKTtjb25zdCBoPXRoaXMuZ2V0QXR0cmlidXRlKCJ0YW5nZW50IikuYXJyYXksbD1bXSxjPVtdO2ZvcihsZXQgQT0wO0E8bztBKyspbFtBXT1uZXcgZyxjW0FdPW5ldyBnO2NvbnN0IHU9bmV3IGcsbT1uZXcgZyxkPW5ldyBnLGY9bmV3IGV0LHk9bmV3IGV0LHg9bmV3IGV0LHA9bmV3IGcsRj1uZXcgZztmdW5jdGlvbiBTKEEseixFKXt1LmZyb21BcnJheShpLEEqMyksbS5mcm9tQXJyYXkoaSx6KjMpLGQuZnJvbUFycmF5KGksRSozKSxmLmZyb21BcnJheShhLEEqMikseS5mcm9tQXJyYXkoYSx6KjIpLHguZnJvbUFycmF5KGEsRSoyKSxtLnN1Yih1KSxkLnN1Yih1KSx5LnN1YihmKSx4LnN1YihmKTtjb25zdCBCPTEvKHkueCp4LnkteC54KnkueSk7aXNGaW5pdGUoQikmJihwLmNvcHkobSkubXVsdGlwbHlTY2FsYXIoeC55KS5hZGRTY2FsZWRWZWN0b3IoZCwteS55KS5tdWx0aXBseVNjYWxhcihCKSxGLmNvcHkoZCkubXVsdGlwbHlTY2FsYXIoeS54KS5hZGRTY2FsZWRWZWN0b3IobSwteC54KS5tdWx0aXBseVNjYWxhcihCKSxsW0FdLmFkZChwKSxsW3pdLmFkZChwKSxsW0VdLmFkZChwKSxjW0FdLmFkZChGKSxjW3pdLmFkZChGKSxjW0VdLmFkZChGKSl9bGV0IHc9dGhpcy5ncm91cHM7dy5sZW5ndGg9PT0wJiYodz1be3N0YXJ0OjAsY291bnQ6cy5sZW5ndGh9XSk7Zm9yKGxldCBBPTAsej13Lmxlbmd0aDtBPHo7KytBKXtjb25zdCBFPXdbQV0sQj1FLnN0YXJ0LHR0PUUuY291bnQ7Zm9yKGxldCBMPUIsST1CK3R0O0w8STtMKz0zKVMoc1tMKzBdLHNbTCsxXSxzW0wrMl0pfWNvbnN0IF89bmV3IGcsaz1uZXcgZyxNPW5ldyBnLFA9bmV3IGc7ZnVuY3Rpb24gcShBKXtNLmZyb21BcnJheShuLEEqMyksUC5jb3B5KE0pO2NvbnN0IHo9bFtBXTtfLmNvcHkoeiksXy5zdWIoTS5tdWx0aXBseVNjYWxhcihNLmRvdCh6KSkpLm5vcm1hbGl6ZSgpLGsuY3Jvc3NWZWN0b3JzKFAseik7Y29uc3QgQj1rLmRvdChjW0FdKTwwPy0xOjE7aFtBKjRdPV8ueCxoW0EqNCsxXT1fLnksaFtBKjQrMl09Xy56LGhbQSo0KzNdPUJ9Zm9yKGxldCBBPTAsej13Lmxlbmd0aDtBPHo7KytBKXtjb25zdCBFPXdbQV0sQj1FLnN0YXJ0LHR0PUUuY291bnQ7Zm9yKGxldCBMPUIsST1CK3R0O0w8STtMKz0zKXEoc1tMKzBdKSxxKHNbTCsxXSkscShzW0wrMl0pfX1jb21wdXRlVmVydGV4Tm9ybWFscygpe2NvbnN0IHQ9dGhpcy5pbmRleCxlPXRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpO2lmKGUhPT12b2lkIDApe2xldCBzPXRoaXMuZ2V0QXR0cmlidXRlKCJub3JtYWwiKTtpZihzPT09dm9pZCAwKXM9bmV3IG50KG5ldyBGbG9hdDMyQXJyYXkoZS5jb3VudCozKSwzKSx0aGlzLnNldEF0dHJpYnV0ZSgibm9ybWFsIixzKTtlbHNlIGZvcihsZXQgbT0wLGQ9cy5jb3VudDttPGQ7bSsrKXMuc2V0WFlaKG0sMCwwLDApO2NvbnN0IGk9bmV3IGcsbj1uZXcgZyxhPW5ldyBnLG89bmV3IGcsaD1uZXcgZyxsPW5ldyBnLGM9bmV3IGcsdT1uZXcgZztpZih0KWZvcihsZXQgbT0wLGQ9dC5jb3VudDttPGQ7bSs9Myl7Y29uc3QgZj10LmdldFgobSswKSx5PXQuZ2V0WChtKzEpLHg9dC5nZXRYKG0rMik7aS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsZiksbi5mcm9tQnVmZmVyQXR0cmlidXRlKGUseSksYS5mcm9tQnVmZmVyQXR0cmlidXRlKGUseCksYy5zdWJWZWN0b3JzKGEsbiksdS5zdWJWZWN0b3JzKGksbiksYy5jcm9zcyh1KSxvLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxmKSxoLmZyb21CdWZmZXJBdHRyaWJ1dGUocyx5KSxsLmZyb21CdWZmZXJBdHRyaWJ1dGUocyx4KSxvLmFkZChjKSxoLmFkZChjKSxsLmFkZChjKSxzLnNldFhZWihmLG8ueCxvLnksby56KSxzLnNldFhZWih5LGgueCxoLnksaC56KSxzLnNldFhZWih4LGwueCxsLnksbC56KX1lbHNlIGZvcihsZXQgbT0wLGQ9ZS5jb3VudDttPGQ7bSs9MylpLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxtKzApLG4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLG0rMSksYS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsbSsyKSxjLnN1YlZlY3RvcnMoYSxuKSx1LnN1YlZlY3RvcnMoaSxuKSxjLmNyb3NzKHUpLHMuc2V0WFlaKG0rMCxjLngsYy55LGMueikscy5zZXRYWVoobSsxLGMueCxjLnksYy56KSxzLnNldFhZWihtKzIsYy54LGMueSxjLnopO3RoaXMubm9ybWFsaXplTm9ybWFscygpLHMubmVlZHNVcGRhdGU9ITB9fW1lcmdlKCl7cmV0dXJuIGNvbnNvbGUuZXJyb3IoIlRIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMubWVyZ2VHZW9tZXRyaWVzKCkgaW5zdGVhZC4iKSx0aGlzfW5vcm1hbGl6ZU5vcm1hbHMoKXtjb25zdCB0PXRoaXMuYXR0cmlidXRlcy5ub3JtYWw7Zm9yKGxldCBlPTAscz10LmNvdW50O2U8cztlKyspUi5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSksUi5ub3JtYWxpemUoKSx0LnNldFhZWihlLFIueCxSLnksUi56KX10b05vbkluZGV4ZWQoKXtmdW5jdGlvbiB0KG8saCl7Y29uc3QgbD1vLmFycmF5LGM9by5pdGVtU2l6ZSx1PW8ubm9ybWFsaXplZCxtPW5ldyBsLmNvbnN0cnVjdG9yKGgubGVuZ3RoKmMpO2xldCBkPTAsZj0wO2ZvcihsZXQgeT0wLHg9aC5sZW5ndGg7eTx4O3krKyl7by5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlP2Q9aFt5XSpvLmRhdGEuc3RyaWRlK28ub2Zmc2V0OmQ9aFt5XSpjO2ZvcihsZXQgcD0wO3A8YztwKyspbVtmKytdPWxbZCsrXX1yZXR1cm4gbmV3IG50KG0sYyx1KX1pZih0aGlzLmluZGV4PT09bnVsbClyZXR1cm4gY29uc29sZS53YXJuKCJUSFJFRS5CdWZmZXJHZW9tZXRyeS50b05vbkluZGV4ZWQoKTogQnVmZmVyR2VvbWV0cnkgaXMgYWxyZWFkeSBub24taW5kZXhlZC4iKSx0aGlzO2NvbnN0IGU9bmV3IHRlLHM9dGhpcy5pbmRleC5hcnJheSxpPXRoaXMuYXR0cmlidXRlcztmb3IoY29uc3QgbyBpbiBpKXtjb25zdCBoPWlbb10sbD10KGgscyk7ZS5zZXRBdHRyaWJ1dGUobyxsKX1jb25zdCBuPXRoaXMubW9ycGhBdHRyaWJ1dGVzO2Zvcihjb25zdCBvIGluIG4pe2NvbnN0IGg9W10sbD1uW29dO2ZvcihsZXQgYz0wLHU9bC5sZW5ndGg7Yzx1O2MrKyl7Y29uc3QgbT1sW2NdLGQ9dChtLHMpO2gucHVzaChkKX1lLm1vcnBoQXR0cmlidXRlc1tvXT1ofWUubW9ycGhUYXJnZXRzUmVsYXRpdmU9dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtjb25zdCBhPXRoaXMuZ3JvdXBzO2ZvcihsZXQgbz0wLGg9YS5sZW5ndGg7bzxoO28rKyl7Y29uc3QgbD1hW29dO2UuYWRkR3JvdXAobC5zdGFydCxsLmNvdW50LGwubWF0ZXJpYWxJbmRleCl9cmV0dXJuIGV9dG9KU09OKCl7Y29uc3QgdD17bWV0YWRhdGE6e3ZlcnNpb246NC42LHR5cGU6IkJ1ZmZlckdlb21ldHJ5IixnZW5lcmF0b3I6IkJ1ZmZlckdlb21ldHJ5LnRvSlNPTiJ9fTtpZih0LnV1aWQ9dGhpcy51dWlkLHQudHlwZT10aGlzLnR5cGUsdGhpcy5uYW1lIT09IiImJih0Lm5hbWU9dGhpcy5uYW1lKSxPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGg+MCYmKHQudXNlckRhdGE9dGhpcy51c2VyRGF0YSksdGhpcy5wYXJhbWV0ZXJzIT09dm9pZCAwKXtjb25zdCBoPXRoaXMucGFyYW1ldGVycztmb3IoY29uc3QgbCBpbiBoKWhbbF0hPT12b2lkIDAmJih0W2xdPWhbbF0pO3JldHVybiB0fXQuZGF0YT17YXR0cmlidXRlczp7fX07Y29uc3QgZT10aGlzLmluZGV4O2UhPT1udWxsJiYodC5kYXRhLmluZGV4PXt0eXBlOmUuYXJyYXkuY29uc3RydWN0b3IubmFtZSxhcnJheTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLmFycmF5KX0pO2NvbnN0IHM9dGhpcy5hdHRyaWJ1dGVzO2Zvcihjb25zdCBoIGluIHMpe2NvbnN0IGw9c1toXTt0LmRhdGEuYXR0cmlidXRlc1toXT1sLnRvSlNPTih0LmRhdGEpfWNvbnN0IGk9e307bGV0IG49ITE7Zm9yKGNvbnN0IGggaW4gdGhpcy5tb3JwaEF0dHJpYnV0ZXMpe2NvbnN0IGw9dGhpcy5tb3JwaEF0dHJpYnV0ZXNbaF0sYz1bXTtmb3IobGV0IHU9MCxtPWwubGVuZ3RoO3U8bTt1Kyspe2NvbnN0IGQ9bFt1XTtjLnB1c2goZC50b0pTT04odC5kYXRhKSl9Yy5sZW5ndGg+MCYmKGlbaF09YyxuPSEwKX1uJiYodC5kYXRhLm1vcnBoQXR0cmlidXRlcz1pLHQuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZT10aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKTtjb25zdCBhPXRoaXMuZ3JvdXBzO2EubGVuZ3RoPjAmJih0LmRhdGEuZ3JvdXBzPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYSkpKTtjb25zdCBvPXRoaXMuYm91bmRpbmdTcGhlcmU7cmV0dXJuIG8hPT1udWxsJiYodC5kYXRhLmJvdW5kaW5nU3BoZXJlPXtjZW50ZXI6by5jZW50ZXIudG9BcnJheSgpLHJhZGl1czpvLnJhZGl1c30pLHR9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7dGhpcy5pbmRleD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLmdyb3Vwcz1bXSx0aGlzLmJvdW5kaW5nQm94PW51bGwsdGhpcy5ib3VuZGluZ1NwaGVyZT1udWxsO2NvbnN0IGU9e307dGhpcy5uYW1lPXQubmFtZTtjb25zdCBzPXQuaW5kZXg7cyE9PW51bGwmJnRoaXMuc2V0SW5kZXgocy5jbG9uZShlKSk7Y29uc3QgaT10LmF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGwgaW4gaSl7Y29uc3QgYz1pW2xdO3RoaXMuc2V0QXR0cmlidXRlKGwsYy5jbG9uZShlKSl9Y29uc3Qgbj10Lm1vcnBoQXR0cmlidXRlcztmb3IoY29uc3QgbCBpbiBuKXtjb25zdCBjPVtdLHU9bltsXTtmb3IobGV0IG09MCxkPXUubGVuZ3RoO208ZDttKyspYy5wdXNoKHVbbV0uY2xvbmUoZSkpO3RoaXMubW9ycGhBdHRyaWJ1dGVzW2xdPWN9dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT10Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO2NvbnN0IGE9dC5ncm91cHM7Zm9yKGxldCBsPTAsYz1hLmxlbmd0aDtsPGM7bCsrKXtjb25zdCB1PWFbbF07dGhpcy5hZGRHcm91cCh1LnN0YXJ0LHUuY291bnQsdS5tYXRlcmlhbEluZGV4KX1jb25zdCBvPXQuYm91bmRpbmdCb3g7byE9PW51bGwmJih0aGlzLmJvdW5kaW5nQm94PW8uY2xvbmUoKSk7Y29uc3QgaD10LmJvdW5kaW5nU3BoZXJlO3JldHVybiBoIT09bnVsbCYmKHRoaXMuYm91bmRpbmdTcGhlcmU9aC5jbG9uZSgpKSx0aGlzLmRyYXdSYW5nZS5zdGFydD10LmRyYXdSYW5nZS5zdGFydCx0aGlzLmRyYXdSYW5nZS5jb3VudD10LmRyYXdSYW5nZS5jb3VudCx0aGlzLnVzZXJEYXRhPXQudXNlckRhdGEsdGhpc31kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pfX1jb25zdCBLZT17ZW5hYmxlZDohMSxmaWxlczp7fSxhZGQ6ZnVuY3Rpb24ocix0KXt0aGlzLmVuYWJsZWQhPT0hMSYmKHRoaXMuZmlsZXNbcl09dCl9LGdldDpmdW5jdGlvbihyKXtpZih0aGlzLmVuYWJsZWQhPT0hMSlyZXR1cm4gdGhpcy5maWxlc1tyXX0scmVtb3ZlOmZ1bmN0aW9uKHIpe2RlbGV0ZSB0aGlzLmZpbGVzW3JdfSxjbGVhcjpmdW5jdGlvbigpe3RoaXMuZmlsZXM9e319fTtjbGFzcyBvaXtjb25zdHJ1Y3Rvcih0LGUscyl7Y29uc3QgaT10aGlzO2xldCBuPSExLGE9MCxvPTAsaDtjb25zdCBsPVtdO3RoaXMub25TdGFydD12b2lkIDAsdGhpcy5vbkxvYWQ9dCx0aGlzLm9uUHJvZ3Jlc3M9ZSx0aGlzLm9uRXJyb3I9cyx0aGlzLml0ZW1TdGFydD1mdW5jdGlvbihjKXtvKyssbj09PSExJiZpLm9uU3RhcnQhPT12b2lkIDAmJmkub25TdGFydChjLGEsbyksbj0hMH0sdGhpcy5pdGVtRW5kPWZ1bmN0aW9uKGMpe2ErKyxpLm9uUHJvZ3Jlc3MhPT12b2lkIDAmJmkub25Qcm9ncmVzcyhjLGEsbyksYT09PW8mJihuPSExLGkub25Mb2FkIT09dm9pZCAwJiZpLm9uTG9hZCgpKX0sdGhpcy5pdGVtRXJyb3I9ZnVuY3Rpb24oYyl7aS5vbkVycm9yIT09dm9pZCAwJiZpLm9uRXJyb3IoYyl9LHRoaXMucmVzb2x2ZVVSTD1mdW5jdGlvbihjKXtyZXR1cm4gaD9oKGMpOmN9LHRoaXMuc2V0VVJMTW9kaWZpZXI9ZnVuY3Rpb24oYyl7cmV0dXJuIGg9Yyx0aGlzfSx0aGlzLmFkZEhhbmRsZXI9ZnVuY3Rpb24oYyx1KXtyZXR1cm4gbC5wdXNoKGMsdSksdGhpc30sdGhpcy5yZW1vdmVIYW5kbGVyPWZ1bmN0aW9uKGMpe2NvbnN0IHU9bC5pbmRleE9mKGMpO3JldHVybiB1IT09LTEmJmwuc3BsaWNlKHUsMiksdGhpc30sdGhpcy5nZXRIYW5kbGVyPWZ1bmN0aW9uKGMpe2ZvcihsZXQgdT0wLG09bC5sZW5ndGg7dTxtO3UrPTIpe2NvbnN0IGQ9bFt1XSxmPWxbdSsxXTtpZihkLmdsb2JhbCYmKGQubGFzdEluZGV4PTApLGQudGVzdChjKSlyZXR1cm4gZn1yZXR1cm4gbnVsbH19fWNvbnN0IGhpPW5ldyBvaTtjbGFzcyB0c3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm1hbmFnZXI9dCE9PXZvaWQgMD90OmhpLHRoaXMuY3Jvc3NPcmlnaW49ImFub255bW91cyIsdGhpcy53aXRoQ3JlZGVudGlhbHM9ITEsdGhpcy5wYXRoPSIiLHRoaXMucmVzb3VyY2VQYXRoPSIiLHRoaXMucmVxdWVzdEhlYWRlcj17fX1sb2FkKCl7fWxvYWRBc3luYyh0LGUpe2NvbnN0IHM9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaSxuKXtzLmxvYWQodCxpLGUsbil9KX1wYXJzZSgpe31zZXRDcm9zc09yaWdpbih0KXtyZXR1cm4gdGhpcy5jcm9zc09yaWdpbj10LHRoaXN9c2V0V2l0aENyZWRlbnRpYWxzKHQpe3JldHVybiB0aGlzLndpdGhDcmVkZW50aWFscz10LHRoaXN9c2V0UGF0aCh0KXtyZXR1cm4gdGhpcy5wYXRoPXQsdGhpc31zZXRSZXNvdXJjZVBhdGgodCl7cmV0dXJuIHRoaXMucmVzb3VyY2VQYXRoPXQsdGhpc31zZXRSZXF1ZXN0SGVhZGVyKHQpe3JldHVybiB0aGlzLnJlcXVlc3RIZWFkZXI9dCx0aGlzfX1jb25zdCBhdD17fTtjbGFzcyBsaSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIodCksdGhpcy5yZXNwb25zZT1lfX1jbGFzcyBjaSBleHRlbmRzIHRze2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWxvYWQodCxlLHMsaSl7dD09PXZvaWQgMCYmKHQ9IiIpLHRoaXMucGF0aCE9PXZvaWQgMCYmKHQ9dGhpcy5wYXRoK3QpLHQ9dGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwodCk7Y29uc3Qgbj1LZS5nZXQodCk7aWYobiE9PXZvaWQgMClyZXR1cm4gdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh0KSxzZXRUaW1lb3V0KCgpPT57ZSYmZShuKSx0aGlzLm1hbmFnZXIuaXRlbUVuZCh0KX0sMCksbjtpZihhdFt0XSE9PXZvaWQgMCl7YXRbdF0ucHVzaCh7b25Mb2FkOmUsb25Qcm9ncmVzczpzLG9uRXJyb3I6aX0pO3JldHVybn1hdFt0XT1bXSxhdFt0XS5wdXNoKHtvbkxvYWQ6ZSxvblByb2dyZXNzOnMsb25FcnJvcjppfSk7Y29uc3QgYT1uZXcgUmVxdWVzdCh0LHtoZWFkZXJzOm5ldyBIZWFkZXJzKHRoaXMucmVxdWVzdEhlYWRlciksY3JlZGVudGlhbHM6dGhpcy53aXRoQ3JlZGVudGlhbHM/ImluY2x1ZGUiOiJzYW1lLW9yaWdpbiJ9KSxvPXRoaXMubWltZVR5cGUsaD10aGlzLnJlc3BvbnNlVHlwZTtmZXRjaChhKS50aGVuKGw9PntpZihsLnN0YXR1cz09PTIwMHx8bC5zdGF0dXM9PT0wKXtpZihsLnN0YXR1cz09PTAmJmNvbnNvbGUud2FybigiVEhSRUUuRmlsZUxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4iKSx0eXBlb2YgUmVhZGFibGVTdHJlYW0+InUifHxsLmJvZHk9PT12b2lkIDB8fGwuYm9keS5nZXRSZWFkZXI9PT12b2lkIDApcmV0dXJuIGw7Y29uc3QgYz1hdFt0XSx1PWwuYm9keS5nZXRSZWFkZXIoKSxtPWwuaGVhZGVycy5nZXQoIkNvbnRlbnQtTGVuZ3RoIil8fGwuaGVhZGVycy5nZXQoIlgtRmlsZS1TaXplIiksZD1tP3BhcnNlSW50KG0pOjAsZj1kIT09MDtsZXQgeT0wO2NvbnN0IHg9bmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChwKXtGKCk7ZnVuY3Rpb24gRigpe3UucmVhZCgpLnRoZW4oKHtkb25lOlMsdmFsdWU6d30pPT57aWYoUylwLmNsb3NlKCk7ZWxzZXt5Kz13LmJ5dGVMZW5ndGg7Y29uc3QgXz1uZXcgUHJvZ3Jlc3NFdmVudCgicHJvZ3Jlc3MiLHtsZW5ndGhDb21wdXRhYmxlOmYsbG9hZGVkOnksdG90YWw6ZH0pO2ZvcihsZXQgaz0wLE09Yy5sZW5ndGg7azxNO2srKyl7Y29uc3QgUD1jW2tdO1Aub25Qcm9ncmVzcyYmUC5vblByb2dyZXNzKF8pfXAuZW5xdWV1ZSh3KSxGKCl9fSl9fX0pO3JldHVybiBuZXcgUmVzcG9uc2UoeCl9ZWxzZSB0aHJvdyBuZXcgbGkoYGZldGNoIGZvciAiJHtsLnVybH0iIHJlc3BvbmRlZCB3aXRoICR7bC5zdGF0dXN9OiAke2wuc3RhdHVzVGV4dH1gLGwpfSkudGhlbihsPT57c3dpdGNoKGgpe2Nhc2UiYXJyYXlidWZmZXIiOnJldHVybiBsLmFycmF5QnVmZmVyKCk7Y2FzZSJibG9iIjpyZXR1cm4gbC5ibG9iKCk7Y2FzZSJkb2N1bWVudCI6cmV0dXJuIGwudGV4dCgpLnRoZW4oYz0+bmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhjLG8pKTtjYXNlImpzb24iOnJldHVybiBsLmpzb24oKTtkZWZhdWx0OmlmKG89PT12b2lkIDApcmV0dXJuIGwudGV4dCgpO3tjb25zdCB1PS9jaGFyc2V0PSI/KFteOyJcc10qKSI/L2kuZXhlYyhvKSxtPXUmJnVbMV0/dVsxXS50b0xvd2VyQ2FzZSgpOnZvaWQgMCxkPW5ldyBUZXh0RGVjb2RlcihtKTtyZXR1cm4gbC5hcnJheUJ1ZmZlcigpLnRoZW4oZj0+ZC5kZWNvZGUoZikpfX19KS50aGVuKGw9PntLZS5hZGQodCxsKTtjb25zdCBjPWF0W3RdO2RlbGV0ZSBhdFt0XTtmb3IobGV0IHU9MCxtPWMubGVuZ3RoO3U8bTt1Kyspe2NvbnN0IGQ9Y1t1XTtkLm9uTG9hZCYmZC5vbkxvYWQobCl9fSkuY2F0Y2gobD0+e2NvbnN0IGM9YXRbdF07aWYoYz09PXZvaWQgMCl0aHJvdyB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHQpLGw7ZGVsZXRlIGF0W3RdO2ZvcihsZXQgdT0wLG09Yy5sZW5ndGg7dTxtO3UrKyl7Y29uc3QgZD1jW3VdO2Qub25FcnJvciYmZC5vbkVycm9yKGwpfXRoaXMubWFuYWdlci5pdGVtRXJyb3IodCl9KS5maW5hbGx5KCgpPT57dGhpcy5tYW5hZ2VyLml0ZW1FbmQodCl9KSx0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHQpfXNldFJlc3BvbnNlVHlwZSh0KXtyZXR1cm4gdGhpcy5yZXNwb25zZVR5cGU9dCx0aGlzfXNldE1pbWVUeXBlKHQpe3JldHVybiB0aGlzLm1pbWVUeXBlPXQsdGhpc319dHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXzwidSImJl9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgicmVnaXN0ZXIiLHtkZXRhaWw6e3JldmlzaW9uOkxlfX0pKSx0eXBlb2Ygd2luZG93PCJ1IiYmKHdpbmRvdy5fX1RIUkVFX18/Y29uc29sZS53YXJuKCJXQVJOSU5HOiBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgVGhyZWUuanMgYmVpbmcgaW1wb3J0ZWQuIik6d2luZG93Ll9fVEhSRUVfXz1MZSk7Y2xhc3MgdWkgZXh0ZW5kcyB0c3tjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1sb2FkKHQsZSxzLGkpe2NvbnN0IG49dGhpcyxhPW5ldyBjaSh0aGlzLm1hbmFnZXIpO2Euc2V0UGF0aCh0aGlzLnBhdGgpLGEuc2V0UmVzcG9uc2VUeXBlKCJhcnJheWJ1ZmZlciIpLGEuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpLGEuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKSxhLmxvYWQodCxmdW5jdGlvbihvKXt0cnl7ZShuLnBhcnNlKG8pKX1jYXRjaChoKXtpP2koaCk6Y29uc29sZS5lcnJvcihoKSxuLm1hbmFnZXIuaXRlbUVycm9yKHQpfX0scyxpKX1wYXJzZSh0KXtmdW5jdGlvbiBlKGwpe2NvbnN0IGM9bmV3IERhdGFWaWV3KGwpLHU9MzIvOCozKzMyLzgqMyozKzE2LzgsbT1jLmdldFVpbnQzMig4MCwhMCk7aWYoODArMzIvOCttKnU9PT1jLmJ5dGVMZW5ndGgpcmV0dXJuITA7Y29uc3QgZj1bMTE1LDExMSwxMDgsMTA1LDEwMF07Zm9yKGxldCB5PTA7eTw1O3krKylpZihzKGYsYyx5KSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBzKGwsYyx1KXtmb3IobGV0IG09MCxkPWwubGVuZ3RoO208ZDttKyspaWYobFttXSE9PWMuZ2V0VWludDgodSttKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBpKGwpe2NvbnN0IGM9bmV3IERhdGFWaWV3KGwpLHU9Yy5nZXRVaW50MzIoODAsITApO2xldCBtLGQsZix5PSExLHgscCxGLFMsdztmb3IobGV0IHo9MDt6PDgwLTEwO3orKyljLmdldFVpbnQzMih6LCExKT09MTEyOTI3MDM1MSYmYy5nZXRVaW50OCh6KzQpPT04MiYmYy5nZXRVaW50OCh6KzUpPT02MSYmKHk9ITAseD1uZXcgRmxvYXQzMkFycmF5KHUqMyozKSxwPWMuZ2V0VWludDgoeis2KS8yNTUsRj1jLmdldFVpbnQ4KHorNykvMjU1LFM9Yy5nZXRVaW50OCh6KzgpLzI1NSx3PWMuZ2V0VWludDgoeis5KS8yNTUpO2NvbnN0IF89ODQsaz0xMio0KzIsTT1uZXcgdGUsUD1uZXcgRmxvYXQzMkFycmF5KHUqMyozKSxxPW5ldyBGbG9hdDMyQXJyYXkodSozKjMpLEE9bmV3IHdlO2ZvcihsZXQgej0wO3o8dTt6Kyspe2NvbnN0IEU9Xyt6KmssQj1jLmdldEZsb2F0MzIoRSwhMCksdHQ9Yy5nZXRGbG9hdDMyKEUrNCwhMCksTD1jLmdldEZsb2F0MzIoRSs4LCEwKTtpZih5KXtjb25zdCBJPWMuZ2V0VWludDE2KEUrNDgsITApO0kmMzI3Njg/KG09cCxkPUYsZj1TKToobT0oSSYzMSkvMzEsZD0oST4+NSYzMSkvMzEsZj0oST4+MTAmMzEpLzMxKX1mb3IobGV0IEk9MTtJPD0zO0krKyl7Y29uc3QgbXQ9RStJKjEyLEg9eiozKjMrKEktMSkqMztQW0hdPWMuZ2V0RmxvYXQzMihtdCwhMCksUFtIKzFdPWMuZ2V0RmxvYXQzMihtdCs0LCEwKSxQW0grMl09Yy5nZXRGbG9hdDMyKG10KzgsITApLHFbSF09QixxW0grMV09dHQscVtIKzJdPUwseSYmKEEuc2V0KG0sZCxmKS5jb252ZXJ0U1JHQlRvTGluZWFyKCkseFtIXT1BLnIseFtIKzFdPUEuZyx4W0grMl09QS5iKX19cmV0dXJuIE0uc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IG50KFAsMykpLE0uc2V0QXR0cmlidXRlKCJub3JtYWwiLG5ldyBudChxLDMpKSx5JiYoTS5zZXRBdHRyaWJ1dGUoImNvbG9yIixuZXcgbnQoeCwzKSksTS5oYXNDb2xvcnM9ITAsTS5hbHBoYT13KSxNfWZ1bmN0aW9uIG4obCl7Y29uc3QgYz1uZXcgdGUsdT0vc29saWQoW1xzXFNdKj8pZW5kc29saWQvZyxtPS9mYWNldChbXHNcU10qPyllbmRmYWNldC9nO2xldCBkPTA7Y29uc3QgZj0vW1xzXSsoWystXT8oPzpcZCopKD86XC5cZCopPyg/OltlRV1bKy1dP1xkKyk/KS8uc291cmNlLHk9bmV3IFJlZ0V4cCgidmVydGV4IitmK2YrZiwiZyIpLHg9bmV3IFJlZ0V4cCgibm9ybWFsIitmK2YrZiwiZyIpLHA9W10sRj1bXSxTPW5ldyBnO2xldCB3LF89MCxrPTAsTT0wO2Zvcig7KHc9dS5leGVjKGwpKSE9PW51bGw7KXtrPU07Y29uc3QgUD13WzBdO2Zvcig7KHc9bS5leGVjKFApKSE9PW51bGw7KXtsZXQgej0wLEU9MDtjb25zdCBCPXdbMF07Zm9yKDsodz14LmV4ZWMoQikpIT09bnVsbDspUy54PXBhcnNlRmxvYXQod1sxXSksUy55PXBhcnNlRmxvYXQod1syXSksUy56PXBhcnNlRmxvYXQod1szXSksRSsrO2Zvcig7KHc9eS5leGVjKEIpKSE9PW51bGw7KXAucHVzaChwYXJzZUZsb2F0KHdbMV0pLHBhcnNlRmxvYXQod1syXSkscGFyc2VGbG9hdCh3WzNdKSksRi5wdXNoKFMueCxTLnksUy56KSx6KyssTSsrO0UhPT0xJiZjb25zb2xlLmVycm9yKCJUSFJFRS5TVExMb2FkZXI6IFNvbWV0aGluZyBpc24ndCByaWdodCB3aXRoIHRoZSBub3JtYWwgb2YgZmFjZSBudW1iZXIgIitkKSx6IT09MyYmY29uc29sZS5lcnJvcigiVEhSRUUuU1RMTG9hZGVyOiBTb21ldGhpbmcgaXNuJ3QgcmlnaHQgd2l0aCB0aGUgdmVydGljZXMgb2YgZmFjZSBudW1iZXIgIitkKSxkKyt9Y29uc3QgcT1rLEE9TS1rO2MuYWRkR3JvdXAocSxBLF8pLF8rK31yZXR1cm4gYy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIixuZXcgX2UocCwzKSksYy5zZXRBdHRyaWJ1dGUoIm5vcm1hbCIsbmV3IF9lKEYsMykpLGN9ZnVuY3Rpb24gYShsKXtyZXR1cm4gdHlwZW9mIGwhPSJzdHJpbmciP25ldyBUZXh0RGVjb2RlcigpLmRlY29kZShsKTpsfWZ1bmN0aW9uIG8obCl7aWYodHlwZW9mIGw9PSJzdHJpbmciKXtjb25zdCBjPW5ldyBVaW50OEFycmF5KGwubGVuZ3RoKTtmb3IobGV0IHU9MDt1PGwubGVuZ3RoO3UrKyljW3VdPWwuY2hhckNvZGVBdCh1KSYyNTU7cmV0dXJuIGMuYnVmZmVyfHxjfWVsc2UgcmV0dXJuIGx9Y29uc3QgaD1vKHQpO3JldHVybiBlKGgpP2koaCk6bihhKHQpKX19c2VsZi5vbm1lc3NhZ2U9YXN5bmMgcj0+e2NvbnN0IHQ9ci5kYXRhO3RyeXtwb3N0TWVzc2FnZSh7cHJvZ3Jlc3NNZXNzYWdlOiJQYXJzaW5nIFNUTCBmaWxlLi4uIn0pO2NvbnN0IGU9ZGkodC5zdGwpO3Bvc3RNZXNzYWdlKHtwcm9ncmVzc01lc3NhZ2U6IkZpbmRpbmcgY2VudHJvaWQuLi4ifSk7Y29uc3Qgcz1taShlKTtwb3N0TWVzc2FnZSh7cHJvZ3Jlc3NNZXNzYWdlOiJHZW5lcmF0aW5nIG1vdmVtZW50IGluc3RydWN0aW9ucy4uLiJ9KTtjb25zdCBpPUh0KHplKGUsMCxzLHQucHhQZXJNbSksKCk9Pnt9KSxuPUh0KHplKGUsMSxzLHQucHhQZXJNbSksKCk9Pnt9KSxhPUh0KHplKGUsMixzLHQucHhQZXJNbSksKCk9Pnt9KTtwb3N0TWVzc2FnZSh7bW92ZU9wdGlvbnM6W2ksbixhXX0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHtlcnJvcjplfSl9fTtmdW5jdGlvbiBkaShyKXtjb25zdCBlPW5ldyB1aSgpLnBhcnNlKHIpLHM9QXJyYXkuZnJvbShlLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkpLGk9W107Zm9yKGxldCBuPTA7bjxzLmxlbmd0aDtuKz05KWkucHVzaChbbi8zLChuKzMpLzMsKG4rNikvM10pO3JldHVybnt2ZXJ0aWNlczpzLGZhY2VzOml9fWZ1bmN0aW9uIG1pKHIpe2NvbnN0e3ZlcnRpY2VzOnR9PXIsZT1bMCwwLDBdO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cys9MyllWzBdKz10W3NdLGVbMV0rPXRbcysxXSxlWzJdKz10W3MrMl07cmV0dXJuIGVbMF0vPXQubGVuZ3RoLzMsZVsxXS89dC5sZW5ndGgvMyxlWzJdLz10Lmxlbmd0aC8zLGV9ZnVuY3Rpb24gemUocix0LGUscyl7Y29uc3R7dmVydGljZXM6aX09cixuPWkucmVkdWNlKChmLHkseCk9Pih4JTMhPT10JiZmLnB1c2goTWF0aC5yb3VuZCgoaVt4XS1lW3glM10pKnMpKSxmKSxbXSk7bGV0IGE9MS8wLG89LTEvMCxoPTEvMCxsPS0xLzA7Zm9yKGxldCBmPTA7ZjxuLmxlbmd0aDtmKz0yKWE9TWF0aC5taW4oYSxuW2ZdKSxvPU1hdGgubWF4KG8sbltmXSksaD1NYXRoLm1pbihoLG5bZisxXSksbD1NYXRoLm1heChsLG5bZisxXSk7Y29uc3QgYz1bXTtmb3IobGV0IGY9MDtmPG4ubGVuZ3RoLTI7Zis9Mil7Y29uc3QgeT1uW2ZdLHg9bltmKzFdO3g8MCYmYy5wdXNoKHt4OnktYSx5Ok1hdGguYWJzKHgpfSl9aWYoIWMubGVuZ3RoKXJldHVybltdO2lmKGNbMF0ueT5jW2MubGVuZ3RoLTFdLnkpe2xldCBmPTA7Zm9yKGxldCB5IG9mIGMpeS54PmYmJihmPXkueCk7Zm9yKGxldCB5IG9mIGMpeS54PWYteS54fWMuc29ydCgoZix5KT0+Zi54LXkueCk7Y29uc3QgdT1bY1swXV07Zm9yKGxldCBmIG9mIGMpe2NvbnN0IHk9dVt1Lmxlbmd0aC0xXTtmLng9PXkueD95Lnk9TWF0aC5tYXgoeS55LGYueSk6dS5wdXNoKGYpfWNvbnN0IG09W107bGV0IGQ9bnVsbDtmb3IobGV0IGYgb2YgdSlkJiZtLnB1c2gobmV3IGZ0KGQueCxkLnksZi54LWQueCxmLnktZC55LDEsW10pKSxkPWY7cmV0dXJuIG0uc29ydCgoZix5KT0+Zi54U3RhcnQteS54U3RhcnQpLG19fSkoKTsK",pr=typeof window<"u"&&window.Blob&&new Blob([atob($r)],{type:"text/javascript;charset=utf-8"});function _m(){let s;try{if(s=pr&&(window.URL||window.webkitURL).createObjectURL(pr),!s)throw"";return new Worker(s)}catch{return new Worker("data:application/javascript;base64,"+$r)}finally{s&&(window.URL||window.webkitURL).revokeObjectURL(s)}}class Um{constructor(t,e,n,a,i){this.xStartMm=t,this.yStartMm=e,this.xDeltaMm=n,this.yDeltaMm=a,this.cutAreaMmSq=i}toString(){return`${this.xDeltaMm},${this.yDeltaMm}:${this.cutAreaMmSq}`}toConstructorString(){return`new Move(${this.xStartMm}, ${this.yStartMm}, ${this.xDeltaMm}, ${this.yDeltaMm}, ${this.cutAreaMmSq})`}isEmpty(){return!this.xDeltaMm&&!this.yDeltaMm}isBasic(){return Math.abs(this.xDeltaMm)<=.01&&Math.abs(this.yDeltaMm)<=.01}toLatheCode(){if(!this.xDeltaMm)return"";const t=e=>Math.abs(e).toFixed(3);return this.yDeltaMm?`L${t(this.xDeltaMm)} RS${t(this.yStartMm)} RE${t(this.yStartMm+this.yDeltaMm)}`:`L${t(this.xDeltaMm)} R${t(this.yStartMm)}`}}class Ti{constructor(t,e,n,a,i,r){this.xStart=t,this.yStart=e,this.xDelta=n,this.yDelta=a,this.cutArea=i,this.cutPixels=r}static withoutCut(t,e,n,a){return new Ti(t,e,n,a,0,[])}toString(){return`${this.xDelta},${this.yDelta}:${this.cutArea}`}toConstructorString(){return`new PixelMove(${this.xStart}, ${this.yStart}, ${this.xDelta}, ${this.yDelta}, ${this.cutArea}, [])`}toMove(t){return new Um(-this.xStart/t,-this.yStart/t,-this.xDelta/t,-this.yDelta/t,this.cutArea/t/t)}isEmpty(){return!this.xDelta&&!this.yDelta}isBasic(){return(this.xDelta===1||this.xDelta===0||this.xDelta===-1)&&(this.yDelta===1||this.yDelta===0||this.yDelta===-1)}length(){return Math.sqrt(this.xDelta*this.xDelta+this.yDelta*this.yDelta)}isHorizontalOrVertical(){return this.xDelta*this.yDelta===0&&!this.isEmpty()}getAngleDegrees(){if(this.isEmpty())return NaN;let t=Math.atan2(this.yDelta,this.xDelta)*180/Math.PI;return t<0&&(t+=360),t}getAngleToDegrees(t){let e=Math.abs(this.getAngleDegrees()-t.getAngleDegrees());return 360-e<e?360-e:e}merge(t){if(this.xStart+this.xDelta!==t.xStart||this.yStart+this.yDelta!==t.yStart)throw new Error(`merge error: ${this} + ${t}`);return new Ti(this.xStart,this.yStart,this.xDelta+t.xDelta,this.yDelta+t.yDelta,this.cutArea+t.cutArea,this.cutPixels.concat(t.cutPixels))}getCut(){if(!this.cutArea)return{width:0,height:0};let t=1/0,e=-1/0,n=1/0,a=-1/0;for(let i of this.cutPixels)i.x<t&&(t=i.x),i.x>e&&(e=i.x),i.y<n&&(n=i.y),i.y>a&&(a=i.y);return{width:e-t+1,height:a-n+1}}}function tl(s,t,e=()=>{}){const n=document.createElement("div");n.style.position="fixed",n.style.top="0",n.style.left="0",n.style.width="100%",n.style.height="100%",n.style.backgroundColor="white",n.style.padding="12px";const a=document.createElement("h2");a.textContent=t,n.appendChild(a),n.appendChild(s),s.style.margin="12px";const i=document.createElement("button");return i.textContent="Close",i.style.display="block",i.addEventListener("click",()=>{document.body.removeChild(n),e()}),n.appendChild(i),document.body.appendChild(n),n}class km{async pickLatheCode(t){return new Promise(e=>{const n=document.createElement("div");n.className="selectorContainer";const a=tl(n,"Select one",()=>e(null));t.map(i=>{const r=document.createElement("div");r.className="selectorScene",r.addEventListener("click",()=>{a.remove(),e(i)}),n.appendChild(r);const o=new jr(r);return o.setLatheCode(i),o})})}}const ba=100;class Dm extends EventTarget{constructor(e){super();Tt(this,"errorContainer");Tt(this,"latheCodeInput");Tt(this,"planButton");Tt(this,"expandCollapseButton");Tt(this,"moreOptionsSection");Tt(this,"saveButton");Tt(this,"loadButton");Tt(this,"loadSelect");Tt(this,"deleteButton");Tt(this,"exportButton");Tt(this,"importInput");Tt(this,"latheCode",null);Tt(this,"worker",null);this.planButton=e.querySelector(".planButton"),this.errorContainer=e.querySelector(".errorContainer"),this.latheCodeInput=e.querySelector(".latheCodeInput"),this.latheCodeInput.addEventListener("input",()=>this.update()),this.latheCodeInput.value=localStorage.getItem("latheCode")||this.latheCodeInput.value,this.update(),e.querySelector(".stlButton").addEventListener("click",()=>{this.dispatchEvent(new Event("stl"))}),this.planButton.addEventListener("click",()=>{this.dispatchEvent(new Event("plan"))}),e.querySelector(".imageButton").addEventListener("click",()=>{this.errorContainer.textContent="";const n=document.createElement("input");n.type="file",n.accept="image/*,.stl",n.addEventListener("change",()=>{var i;const a=(i=n.files)==null?void 0:i[0];a!=null&&a.name.endsWith(".stl")?this.importStl(a):a&&this.recognize(a)}),n.click()}),this.saveButton=e.querySelector(".saveButton"),this.loadButton=e.querySelector(".loadButton"),this.loadSelect=e.querySelector(".loadSelect"),this.deleteButton=e.querySelector(".deleteButton"),this.exportButton=e.querySelector(".exportButton"),this.importInput=e.querySelector("#importFile"),this.expandCollapseButton=e.querySelector(".expandCollapseButton"),this.moreOptionsSection=e.querySelector("#moreOptions"),this.saveButton.addEventListener("click",()=>this.saveLatheCode()),this.loadButton.addEventListener("click",()=>this.loadLatheCode()),this.deleteButton.addEventListener("click",()=>this.deleteLatheCode()),this.exportButton.addEventListener("click",()=>this.exportLocalStorage()),this.importInput.addEventListener("change",n=>this.handleImportInputChange(n)),this.expandCollapseButton.addEventListener("click",()=>this.toggleMoreOptions()),this.updateLoadSelect()}handleImportInputChange(e){var a;const n=(a=e.target.files)==null?void 0:a[0];n&&this.importLocalStorage(n)}toggleMoreOptions(){this.moreOptionsSection.classList.toggle("expanded")}isRelevantLocalStorageKey(e){const n=localStorage.getItem(e);return n?n.indexOf(`
`)>=0:!1}updateLoadSelect(){this.loadSelect.innerHTML="";let e=!1;for(let n=0;n<localStorage.length;n++){const a=localStorage.key(n);if(a&&a!=="latheCode"&&this.isRelevantLocalStorageKey(a)){e=!0;const i=document.createElement("option");i.value=a,i.textContent=a,this.loadSelect.appendChild(i)}}if(e){const n=Array.from(this.loadSelect.options).sort((a,i)=>a.text.localeCompare(i.text));this.loadSelect.innerHTML="",n.forEach(a=>{this.loadSelect.appendChild(a)})}else{const n=document.createElement("option");n.textContent="No items saved",n.disabled=!0,this.loadSelect.appendChild(n)}}saveLatheCode(){let e=this.latheCodeInput.value;e.indexOf(`
`)===-1&&(e+=`
`);const n=prompt("Enter the name for this lathecode file",new Date().toLocaleString());n&&(localStorage.setItem(n,e),this.updateLoadSelect(),this.loadSelect.value=n)}loadLatheCode(){const n=document.querySelector(".loadSelect").value,a=localStorage.getItem(n);a&&(this.latheCodeInput.value=a,this.update())}deleteLatheCode(){const e=this.loadSelect.value;e&&(localStorage.removeItem(e),this.updateLoadSelect())}getLatheCode(){return this.latheCode}update(){try{localStorage.setItem("latheCode",this.latheCodeInput.value),this.latheCode=new lr(this.latheCodeInput.value+`
`),this.planButton.style.display=this.latheCode.getInsideSegments().length?"none":"inline",this.errorContainer.textContent=""}catch(e){this.latheCode=null,this.errorContainer.textContent=e.message}this.dispatchEvent(new Event("change"))}recognize(e){const n=new FileReader;n.onload=async()=>{let a=n.result;this.worker&&(this.worker.onmessage=null,this.worker.terminate());const r=await Am(a)/ba,o=Number(prompt("How long should the part be in mm?",r.toFixed(2)));if(isNaN(o)||o<=0)return;a=await Jm(a,o/r),this.worker=new Fm,this.worker.onmessage=h=>{const p=h.data;p.moves&&p.moves.length?this.setLatheCodeFromPixelMoves(p.moves.map(u=>(Object.setPrototypeOf(u,Ti.prototype),u))):p.error&&(this.errorContainer.textContent=p.error)};const l=Number(prompt("How smooth should it be? Use values between 1 and 10:","1"));if(isNaN(l)||l<0)return;const c={image:a,pxPerMm:100,smoothEpsilon:l};this.worker.postMessage(c)},n.readAsArrayBuffer(e)}importStl(e){const n=new FileReader;n.onload=async()=>{const a=n.result;this.worker&&(this.worker.onmessage=null,this.worker.terminate()),this.worker=new _m,this.worker.onmessage=r=>{const o=r.data;o.moveOptions&&o.moveOptions.length?new km().pickLatheCode(o.moveOptions.map(l=>new lr(l.map(c=>(Object.setPrototypeOf(c,Ti.prototype),c.toMove(ba).toLatheCode())).join(`
`)))).then(l=>{l&&(this.latheCodeInput.value=`; ${e.name}

; Uncomment and modify lines below as needed
; STOCK D5
; TOOL RECT R0.2 L2
; DEPTH CUT1 FINISH0.1
; FEED MOVE200 PASS50 PART10 ; speeds mm/min
; MODE TURN ; for classic style of material removal
; AXES RIGHT DOWN ; for non-NanoEls controllers

`+l.getText(),this.update())}):o.error&&(this.errorContainer.textContent=o.error)};const i={stl:a,pxPerMm:100};this.worker.postMessage(i)},n.readAsArrayBuffer(e)}setLatheCodeFromPixelMoves(e){const n=e.map(a=>a.toMove(ba).toLatheCode()).filter(a=>!!a);this.latheCodeInput.value=n.join(`
`),this.update()}exportLocalStorage(){const e={};for(let o=0;o<localStorage.length;o++){const l=localStorage.key(o);l&&(e[l]=localStorage.getItem(l)??"")}const n=JSON.stringify(e,null,2),a=new Blob([n],{type:"application/json"}),i=URL.createObjectURL(a),r=document.createElement("a");r.href=i,r.download="localStorageBackup.json",r.click(),URL.revokeObjectURL(i)}importLocalStorage(e){const n=new FileReader;n.onload=()=>{try{const a=JSON.parse(n.result);for(const i in a)Object.prototype.hasOwnProperty.call(a,i)&&localStorage.setItem(i,a[i]);this.updateLoadSelect()}catch(a){console.error("Failed to import data: ",a)}},n.readAsText(e)}}function Am(s){return new Promise((t,e)=>{const n=new Blob([s]),a=new Image;a.onload=()=>t(a.height),a.onerror=()=>e(new Error("Failed to load the image.")),a.src=URL.createObjectURL(n)})}function Jm(s,t){return new Promise((e,n)=>{const a=new Blob([s]),i=new Image;i.onload=()=>{const r=document.createElement("canvas"),o=i.width*t,l=i.height*t;r.width=o,r.height=l,r.getContext("2d").drawImage(i,0,0,o,l),r.toBlob(h=>{const p=new FileReader;p.onloadend=()=>e(p.result),p.onerror=()=>n(new Error("Failed to read the scaled image data.")),p.readAsArrayBuffer(h)},"image/png",1)},i.onerror=()=>n(new Error("Failed to load the image.")),i.src=URL.createObjectURL(a)})}const el="dmFyIF9yPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgSHI9KFEsRCxJKT0+RCBpbiBRP19yKFEsRCx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6SX0pOlFbRF09STt2YXIgVD0oUSxELEkpPT4oSHIoUSx0eXBlb2YgRCE9InN5bWJvbCI/RCsiIjpELEkpLEkpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijtjb25zdCBRPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcyhpLG4pe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPWl9dC5wcm90b3R5cGU9bi5wcm90b3R5cGUsaS5wcm90b3R5cGU9bmV3IHR9ZnVuY3Rpb24gZShpLG4sdCxsKXt0aGlzLm1lc3NhZ2U9aSx0aGlzLmV4cGVjdGVkPW4sdGhpcy5mb3VuZD10LHRoaXMubG9jYXRpb249bCx0aGlzLm5hbWU9IlN5bnRheEVycm9yIix0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U9PSJmdW5jdGlvbiImJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsZSl9cyhlLEVycm9yKSxlLmJ1aWxkTWVzc2FnZT1mdW5jdGlvbihpLG4pe3ZhciB0PXtsaXRlcmFsOmZ1bmN0aW9uKHYpe3JldHVybiciJytjKHYudGV4dCkrJyInfSxjbGFzczpmdW5jdGlvbih2KXt2YXIgQz0iIixPO2ZvcihPPTA7Tzx2LnBhcnRzLmxlbmd0aDtPKyspQys9di5wYXJ0c1tPXWluc3RhbmNlb2YgQXJyYXk/Zih2LnBhcnRzW09dWzBdKSsiLSIrZih2LnBhcnRzW09dWzFdKTpmKHYucGFydHNbT10pO3JldHVybiJbIisodi5pbnZlcnRlZD8iXiI6IiIpK0MrIl0ifSxhbnk6ZnVuY3Rpb24odil7cmV0dXJuImFueSBjaGFyYWN0ZXIifSxlbmQ6ZnVuY3Rpb24odil7cmV0dXJuImVuZCBvZiBpbnB1dCJ9LG90aGVyOmZ1bmN0aW9uKHYpe3JldHVybiB2LmRlc2NyaXB0aW9ufX07ZnVuY3Rpb24gbCh2KXtyZXR1cm4gdi5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWZ1bmN0aW9uIGModil7cmV0dXJuIHYucmVwbGFjZSgvXFwvZywiXFxcXCIpLnJlcGxhY2UoLyIvZywnXFwiJykucmVwbGFjZSgvXDAvZywiXFwwIikucmVwbGFjZSgvXHQvZywiXFx0IikucmVwbGFjZSgvXG4vZywiXFxuIikucmVwbGFjZSgvXHIvZywiXFxyIikucmVwbGFjZSgvW1x4MDAtXHgwRl0vZyxmdW5jdGlvbihDKXtyZXR1cm4iXFx4MCIrbChDKX0pLnJlcGxhY2UoL1tceDEwLVx4MUZceDdGLVx4OUZdL2csZnVuY3Rpb24oQyl7cmV0dXJuIlxceCIrbChDKX0pfWZ1bmN0aW9uIGYodil7cmV0dXJuIHYucmVwbGFjZSgvXFwvZywiXFxcXCIpLnJlcGxhY2UoL1xdL2csIlxcXSIpLnJlcGxhY2UoL1xeL2csIlxcXiIpLnJlcGxhY2UoLy0vZywiXFwtIikucmVwbGFjZSgvXDAvZywiXFwwIikucmVwbGFjZSgvXHQvZywiXFx0IikucmVwbGFjZSgvXG4vZywiXFxuIikucmVwbGFjZSgvXHIvZywiXFxyIikucmVwbGFjZSgvW1x4MDAtXHgwRl0vZyxmdW5jdGlvbihDKXtyZXR1cm4iXFx4MCIrbChDKX0pLnJlcGxhY2UoL1tceDEwLVx4MUZceDdGLVx4OUZdL2csZnVuY3Rpb24oQyl7cmV0dXJuIlxceCIrbChDKX0pfWZ1bmN0aW9uIHcodil7cmV0dXJuIHRbdi50eXBlXSh2KX1mdW5jdGlvbiBTKHYpe3ZhciBDPW5ldyBBcnJheSh2Lmxlbmd0aCksTyxydDtmb3IoTz0wO088di5sZW5ndGg7TysrKUNbT109dyh2W09dKTtpZihDLnNvcnQoKSxDLmxlbmd0aD4wKXtmb3IoTz0xLHJ0PTE7TzxDLmxlbmd0aDtPKyspQ1tPLTFdIT09Q1tPXSYmKENbcnRdPUNbT10scnQrKyk7Qy5sZW5ndGg9cnR9c3dpdGNoKEMubGVuZ3RoKXtjYXNlIDE6cmV0dXJuIENbMF07Y2FzZSAyOnJldHVybiBDWzBdKyIgb3IgIitDWzFdO2RlZmF1bHQ6cmV0dXJuIEMuc2xpY2UoMCwtMSkuam9pbigiLCAiKSsiLCBvciAiK0NbQy5sZW5ndGgtMV19fWZ1bmN0aW9uIGsodil7cmV0dXJuIHY/JyInK2ModikrJyInOiJlbmQgb2YgaW5wdXQifXJldHVybiJFeHBlY3RlZCAiK1MoaSkrIiBidXQgIitrKG4pKyIgZm91bmQuIn07ZnVuY3Rpb24gcihpLG4pe249biE9PXZvaWQgMD9uOnt9O3ZhciB0PXt9LGw9e3N0YXJ0OkxlfSxjPUxlLGY9IlVOSVRTIix3PXgoIlVOSVRTIiwhMSksUz0iTU0iLGs9eCgiTU0iLCExKSx2PSJDTSIsQz14KCJDTSIsITEpLE89Ik0iLHJ0PXgoIk0iLCExKSx0ZT0iRlQiLEFzPXgoIkZUIiwhMSksZWU9IklOIixPcz14KCJJTiIsITEpLHNlPSJTVE9DSyIsVHM9eCgiU1RPQ0siLCExKSxBdD0iUiIsT3Q9eCgiUiIsITEpLHJlPSJEIixpZT14KCJEIiwhMSksbmU9IkEiLGFlPXgoIkEiLCExKSxvZT0iVE9PTCIsRnM9eCgiVE9PTCIsITEpLGxlPSJSRUNUIixOcz14KCJSRUNUIiwhMSksaGU9IlJPVU5EIixScz14KCJST1VORCIsITEpLGNlPSJBTkciLElzPXgoIkFORyIsITEpLHB0PSJMIixkdD14KCJMIiwhMSksenM9IkgiLExzPXgoIkgiLCExKSx1ZT0iTkEiLFhzPXgoIk5BIiwhMSksZmU9IkRFUFRIIixZcz14KCJERVBUSCIsITEpLGdlPSJDVVQiLFVzPXgoIkNVVCIsITEpLHBlPSJGSU5JU0giLEJzPXgoIkZJTklTSCIsITEpLGRlPSJGRUVEIixxcz14KCJGRUVEIiwhMSksbWU9Ik1PVkUiLF9zPXgoIk1PVkUiLCExKSx5ZT0iUEFTUyIsSHM9eCgiUEFTUyIsITEpLHdlPSJQQVJUIixHcz14KCJQQVJUIiwhMSksYmU9Ik1PREUiLFZzPXgoIk1PREUiLCExKSx2ZT0iRkFDRSIsV3M9eCgiRkFDRSIsITEpLHhlPSJUVVJOIixLcz14KCJUVVJOIiwhMSksTWU9IkFYRVMiLGpzPXgoIkFYRVMiLCExKSwkZT0iTEVGVCIsWnM9eCgiTEVGVCIsITEpLENlPSJSSUdIVCIsSnM9eCgiUklHSFQiLCExKSxTZT0iVVAiLFFzPXgoIlVQIiwhMSksRWU9IkRPV04iLHRyPXgoIkRPV04iLCExKSxEZT0iSU5TSURFIixlcj14KCJJTlNJREUiLCExKSxQZT0iRFMiLHNyPXgoIkRTIiwhMSksa2U9IlJTIixycj14KCJSUyIsITEpLEFlPSJERSIsaXI9eCgiREUiLCExKSxPZT0iUkUiLG5yPXgoIlJFIiwhMSksVGU9IkNPTlYiLGFyPXgoIkNPTlYiLCExKSxGZT0iQ09OQyIsb3I9eCgiQ09OQyIsITEpLGxyPSI7Iixocj14KCI7IiwhMSksTmU9Q3IoKSxjcj1mdW5jdGlvbihhKXtyZXR1cm4gUmUoKS5zdWJzdHJpbmcoMSkudHJpbSgpfSx1cj0iLiIsZnI9eCgiLiIsITEpLGdyPWZ1bmN0aW9uKCl7cmV0dXJuIHBhcnNlRmxvYXQoUmUoKSl9LHByPS9eWzAtOV0vLGRyPSRyKFtbIjAiLCI5Il1dLCExLCExKSxtcj1mdW5jdGlvbigpe3JldHVybiBudWxsfSx5cj0iICIsd3I9eCgiICIsITEpLGJyPSJcciIsdnI9eCgiXHIiLCExKSx4cj1gCmAsTXI9eChgCmAsITEpLG89MCxtdD0wLHl0PVt7bGluZToxLGNvbHVtbjoxfV0sVj0wLFR0PVtdLHk9MCx3dDtpZigic3RhcnRSdWxlImluIG4pe2lmKCEobi5zdGFydFJ1bGUgaW4gbCkpdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSAiYCtuLnN0YXJ0UnVsZSsnIi4nKTtjPWxbbi5zdGFydFJ1bGVdfWZ1bmN0aW9uIFJlKCl7cmV0dXJuIGkuc3Vic3RyaW5nKG10LG8pfWZ1bmN0aW9uIHgoYSxoKXtyZXR1cm57dHlwZToibGl0ZXJhbCIsdGV4dDphLGlnbm9yZUNhc2U6aH19ZnVuY3Rpb24gJHIoYSxoLHUpe3JldHVybnt0eXBlOiJjbGFzcyIscGFydHM6YSxpbnZlcnRlZDpoLGlnbm9yZUNhc2U6dX19ZnVuY3Rpb24gQ3IoKXtyZXR1cm57dHlwZToiYW55In19ZnVuY3Rpb24gU3IoKXtyZXR1cm57dHlwZToiZW5kIn19ZnVuY3Rpb24gSWUoYSl7dmFyIGg9eXRbYV0sdTtpZihoKXJldHVybiBoO2Zvcih1PWEtMTsheXRbdV07KXUtLTtmb3IoaD15dFt1XSxoPXtsaW5lOmgubGluZSxjb2x1bW46aC5jb2x1bW59O3U8YTspaS5jaGFyQ29kZUF0KHUpPT09MTA/KGgubGluZSsrLGguY29sdW1uPTEpOmguY29sdW1uKyssdSsrO3JldHVybiB5dFthXT1oLGh9ZnVuY3Rpb24gemUoYSxoKXt2YXIgdT1JZShhKSxnPUllKGgpO3JldHVybntzdGFydDp7b2Zmc2V0OmEsbGluZTp1LmxpbmUsY29sdW1uOnUuY29sdW1ufSxlbmQ6e29mZnNldDpoLGxpbmU6Zy5saW5lLGNvbHVtbjpnLmNvbHVtbn19fWZ1bmN0aW9uIGIoYSl7bzxWfHwobz5WJiYoVj1vLFR0PVtdKSxUdC5wdXNoKGEpKX1mdW5jdGlvbiBFcihhLGgsdSl7cmV0dXJuIG5ldyBlKGUuYnVpbGRNZXNzYWdlKGEsaCksYSxoLHUpfWZ1bmN0aW9uIExlKCl7dmFyIGEsaCx1LGcscCxkLE0sRSxfLHZ0LEsseHQsaixNdCxaLCR0LFAsTixBLG90LFksSCxVO2ZvcihhPW8saD1bXSx1PSQoKTt1IT09dDspaC5wdXNoKHUpLHU9JCgpO2lmKGghPT10KWlmKHU9RHIoKSx1PT09dCYmKHU9bnVsbCksdSE9PXQpe2ZvcihnPVtdLHA9JCgpO3AhPT10OylnLnB1c2gocCkscD0kKCk7aWYoZyE9PXQpaWYocD1rcigpLHA9PT10JiYocD1udWxsKSxwIT09dCl7Zm9yKGQ9W10sTT0kKCk7TSE9PXQ7KWQucHVzaChNKSxNPSQoKTtpZihkIT09dClpZihNPU9yKCksTT09PXQmJihNPW51bGwpLE0hPT10KXtmb3IoRT1bXSxfPSQoKTtfIT09dDspRS5wdXNoKF8pLF89JCgpO2lmKEUhPT10KWlmKF89TnIoKSxfPT09dCYmKF89bnVsbCksXyE9PXQpe2Zvcih2dD1bXSxLPSQoKTtLIT09dDspdnQucHVzaChLKSxLPSQoKTtpZih2dCE9PXQpaWYoSz1JcigpLEs9PT10JiYoSz1udWxsKSxLIT09dCl7Zm9yKHh0PVtdLGo9JCgpO2ohPT10Oyl4dC5wdXNoKGopLGo9JCgpO2lmKHh0IT09dClpZihqPUxyKCksaj09PXQmJihqPW51bGwpLGohPT10KXtmb3IoTXQ9W10sWj0kKCk7WiE9PXQ7KU10LnB1c2goWiksWj0kKCk7aWYoTXQhPT10KWlmKFo9WXIoKSxaPT09dCYmKFo9bnVsbCksWiE9PXQpe2ZvcigkdD1bXSxQPW8sTj1bXSxBPSQoKTtBIT09dDspTi5wdXNoKEEpLEE9JCgpO2ZvcihOIT09dD8oQT1idCgpLEEhPT10PyhOPVtOLEFdLFA9Tik6KG89UCxQPXQpKToobz1QLFA9dCk7UCE9PXQ7KXtmb3IoJHQucHVzaChQKSxQPW8sTj1bXSxBPSQoKTtBIT09dDspTi5wdXNoKEEpLEE9JCgpO04hPT10PyhBPWJ0KCksQSE9PXQ/KE49W04sQV0sUD1OKToobz1QLFA9dCkpOihvPVAsUD10KX1pZigkdCE9PXQpe2ZvcihQPW8sTj1bXSxBPSQoKTtBIT09dDspTi5wdXNoKEEpLEE9JCgpO2lmKE4hPT10KWlmKEE9QnIoKSxBIT09dCl7Zm9yKG90PVtdLFk9byxIPVtdLFU9JCgpO1UhPT10OylILnB1c2goVSksVT0kKCk7aWYoSCE9PXQ/KFU9YnQoKSxVIT09dD8oSD1bSCxVXSxZPUgpOihvPVksWT10KSk6KG89WSxZPXQpLFkhPT10KWZvcig7WSE9PXQ7KXtmb3Iob3QucHVzaChZKSxZPW8sSD1bXSxVPSQoKTtVIT09dDspSC5wdXNoKFUpLFU9JCgpO0ghPT10PyhVPWJ0KCksVSE9PXQ/KEg9W0gsVV0sWT1IKToobz1ZLFk9dCkpOihvPVksWT10KX1lbHNlIG90PXQ7b3QhPT10PyhOPVtOLEEsb3RdLFA9Tik6KG89UCxQPXQpfWVsc2Ugbz1QLFA9dDtlbHNlIG89UCxQPXQ7aWYoUD09PXQmJihQPW51bGwpLFAhPT10KXtmb3IoTj1bXSxBPSQoKTtBIT09dDspTi5wdXNoKEEpLEE9JCgpO04hPT10PyhoPVtoLHUsZyxwLGQsTSxFLF8sdnQsSyx4dCxqLE10LFosJHQsUCxOXSxhPWgpOihvPWEsYT10KX1lbHNlIG89YSxhPXR9ZWxzZSBvPWEsYT10fWVsc2Ugbz1hLGE9dDtlbHNlIG89YSxhPXR9ZWxzZSBvPWEsYT10O2Vsc2Ugbz1hLGE9dH1lbHNlIG89YSxhPXQ7ZWxzZSBvPWEsYT10fWVsc2Ugbz1hLGE9dDtlbHNlIG89YSxhPXR9ZWxzZSBvPWEsYT10O2Vsc2Ugbz1hLGE9dH1lbHNlIG89YSxhPXQ7ZWxzZSBvPWEsYT10fWVsc2Ugbz1hLGE9dDtlbHNlIG89YSxhPXQ7cmV0dXJuIGF9ZnVuY3Rpb24gRHIoKXt2YXIgYSxoLHUsZyxwO3JldHVybiBhPW8saS5zdWJzdHIobyw1KT09PWY/KGg9ZixvKz01KTooaD10LHk9PT0wJiZiKHcpKSxoIT09dD8odT1HKCksdSE9PXQ/KGc9UHIoKSxnIT09dD8ocD0kKCkscCE9PXQ/KGg9W2gsdSxnLHBdLGE9aCk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpLGF9ZnVuY3Rpb24gUHIoKXt2YXIgYTtyZXR1cm4gaS5zdWJzdHIobywyKT09PVM/KGE9UyxvKz0yKTooYT10LHk9PT0wJiZiKGspKSxhPT09dCYmKGkuc3Vic3RyKG8sMik9PT12PyhhPXYsbys9Mik6KGE9dCx5PT09MCYmYihDKSksYT09PXQmJihpLmNoYXJDb2RlQXQobyk9PT03Nz8oYT1PLG8rKyk6KGE9dCx5PT09MCYmYihydCkpLGE9PT10JiYoaS5zdWJzdHIobywyKT09PXRlPyhhPXRlLG8rPTIpOihhPXQseT09PTAmJmIoQXMpKSxhPT09dCYmKGkuc3Vic3RyKG8sMik9PT1lZT8oYT1lZSxvKz0yKTooYT10LHk9PT0wJiZiKE9zKSkpKSkpLGF9ZnVuY3Rpb24ga3IoKXt2YXIgYSxoLHUsZyxwO3JldHVybiBhPW8saS5zdWJzdHIobyw1KT09PXNlPyhoPXNlLG8rPTUpOihoPXQseT09PTAmJmIoVHMpKSxoIT09dD8odT1HKCksdSE9PXQ/KGc9QXIoKSxnIT09dD8ocD0kKCkscCE9PXQ/KGg9W2gsdSxnLHBdLGE9aCk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpLGF9ZnVuY3Rpb24gQXIoKXt2YXIgYSxoLHUsZyxwLGQ7cmV0dXJuIGE9byxpLmNoYXJDb2RlQXQobyk9PT04Mj8oaD1BdCxvKyspOihoPXQseT09PTAmJmIoT3QpKSxoPT09dCYmKGkuY2hhckNvZGVBdChvKT09PTY4PyhoPXJlLG8rKyk6KGg9dCx5PT09MCYmYihpZSkpKSxoIT09dD8odT1YKCksdSE9PXQ/KGc9byxpLmNoYXJDb2RlQXQobyk9PT02NT8ocD1uZSxvKyspOihwPXQseT09PTAmJmIoYWUpKSxwIT09dD8oZD1YKCksZCE9PXQ/KHA9W3AsZF0sZz1wKToobz1nLGc9dCkpOihvPWcsZz10KSxnPT09dCYmKGc9bnVsbCksZyE9PXQ/KGg9W2gsdSxnXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCksYX1mdW5jdGlvbiBPcigpe3ZhciBhLGgsdSxnLHAsZCxNO3JldHVybiBhPW8saS5zdWJzdHIobyw0KT09PW9lPyhoPW9lLG8rPTQpOihoPXQseT09PTAmJmIoRnMpKSxoIT09dD8odT1HKCksdSE9PXQ/KGc9VHIoKSxnIT09dD8ocD1HKCkscCE9PXQ/KGQ9RnIoKSxkIT09dD8oTT0kKCksTSE9PXQ/KGg9W2gsdSxnLHAsZCxNXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCksYX1mdW5jdGlvbiBUcigpe3ZhciBhO3JldHVybiBpLnN1YnN0cihvLDQpPT09bGU/KGE9bGUsbys9NCk6KGE9dCx5PT09MCYmYihOcykpLGE9PT10JiYoaS5zdWJzdHIobyw1KT09PWhlPyhhPWhlLG8rPTUpOihhPXQseT09PTAmJmIoUnMpKSxhPT09dCYmKGkuc3Vic3RyKG8sMyk9PT1jZT8oYT1jZSxvKz0zKTooYT10LHk9PT0wJiZiKElzKSkpKSxhfWZ1bmN0aW9uIEZyKCl7dmFyIGEsaCx1LGcscCxkLE0sRTtyZXR1cm4gYT1vLGg9byxpLmNoYXJDb2RlQXQobyk9PT04Mj8odT1BdCxvKyspOih1PXQseT09PTAmJmIoT3QpKSx1IT09dD8oZz1YKCksZyE9PXQ/KHU9W3UsZ10saD11KToobz1oLGg9dCkpOihvPWgsaD10KSxoPT09dCYmKGg9bnVsbCksaCE9PXQ/KHU9byxpLmNoYXJDb2RlQXQobyk9PT03Nj8oZz1wdCxvKyspOihnPXQseT09PTAmJmIoZHQpKSxnIT09dD8ocD1YKCkscCE9PXQ/KGc9W2cscF0sdT1nKToobz11LHU9dCkpOihvPXUsdT10KSx1PT09dCYmKHU9bnVsbCksdSE9PXQ/KGc9byxpLmNoYXJDb2RlQXQobyk9PT03Mj8ocD16cyxvKyspOihwPXQseT09PTAmJmIoTHMpKSxwIT09dD8oZD1YKCksZCE9PXQ/KHA9W3AsZF0sZz1wKToobz1nLGc9dCkpOihvPWcsZz10KSxnPT09dCYmKGc9bnVsbCksZyE9PXQ/KHA9byxpLmNoYXJDb2RlQXQobyk9PT02NT8oZD1uZSxvKyspOihkPXQseT09PTAmJmIoYWUpKSxkIT09dD8oTT1YKCksTSE9PXQ/KGQ9W2QsTV0scD1kKToobz1wLHA9dCkpOihvPXAscD10KSxwPT09dCYmKHA9bnVsbCkscCE9PXQ/KGQ9byxpLnN1YnN0cihvLDIpPT09dWU/KE09dWUsbys9Mik6KE09dCx5PT09MCYmYihYcykpLE0hPT10PyhFPVgoKSxFIT09dD8oTT1bTSxFXSxkPU0pOihvPWQsZD10KSk6KG89ZCxkPXQpLGQ9PT10JiYoZD1udWxsKSxkIT09dD8oaD1baCx1LGcscCxkXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpLGF9ZnVuY3Rpb24gTnIoKXt2YXIgYSxoLHUsZyxwO3JldHVybiBhPW8saS5zdWJzdHIobyw1KT09PWZlPyhoPWZlLG8rPTUpOihoPXQseT09PTAmJmIoWXMpKSxoIT09dD8odT1HKCksdSE9PXQ/KGc9UnIoKSxnIT09dD8ocD0kKCkscCE9PXQ/KGg9W2gsdSxnLHBdLGE9aCk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpLGF9ZnVuY3Rpb24gUnIoKXt2YXIgYSxoLHUsZyxwO3JldHVybiBhPW8saD1vLGkuc3Vic3RyKG8sMyk9PT1nZT8odT1nZSxvKz0zKToodT10LHk9PT0wJiZiKFVzKSksdSE9PXQ/KGc9WCgpLGchPT10Pyh1PVt1LGddLGg9dSk6KG89aCxoPXQpKToobz1oLGg9dCksaD09PXQmJihoPW51bGwpLGghPT10Pyh1PW8saS5zdWJzdHIobyw2KT09PXBlPyhnPXBlLG8rPTYpOihnPXQseT09PTAmJmIoQnMpKSxnIT09dD8ocD1YKCkscCE9PXQ/KGc9W2cscF0sdT1nKToobz11LHU9dCkpOihvPXUsdT10KSx1PT09dCYmKHU9bnVsbCksdSE9PXQ/KGg9W2gsdV0sYT1oKToobz1hLGE9dCkpOihvPWEsYT10KSxhfWZ1bmN0aW9uIElyKCl7dmFyIGEsaCx1LGcscDtyZXR1cm4gYT1vLGkuc3Vic3RyKG8sNCk9PT1kZT8oaD1kZSxvKz00KTooaD10LHk9PT0wJiZiKHFzKSksaCE9PXQ/KHU9RygpLHUhPT10PyhnPXpyKCksZyE9PXQ/KHA9JCgpLHAhPT10PyhoPVtoLHUsZyxwXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSxhfWZ1bmN0aW9uIHpyKCl7dmFyIGEsaCx1LGcscCxkO3JldHVybiBhPW8saD1vLGkuc3Vic3RyKG8sNCk9PT1tZT8odT1tZSxvKz00KToodT10LHk9PT0wJiZiKF9zKSksdSE9PXQ/KGc9WCgpLGchPT10Pyh1PVt1LGddLGg9dSk6KG89aCxoPXQpKToobz1oLGg9dCksaD09PXQmJihoPW51bGwpLGghPT10Pyh1PW8saS5zdWJzdHIobyw0KT09PXllPyhnPXllLG8rPTQpOihnPXQseT09PTAmJmIoSHMpKSxnIT09dD8ocD1YKCkscCE9PXQ/KGc9W2cscF0sdT1nKToobz11LHU9dCkpOihvPXUsdT10KSx1PT09dCYmKHU9bnVsbCksdSE9PXQ/KGc9byxpLnN1YnN0cihvLDQpPT09d2U/KHA9d2Usbys9NCk6KHA9dCx5PT09MCYmYihHcykpLHAhPT10PyhkPVgoKSxkIT09dD8ocD1bcCxkXSxnPXApOihvPWcsZz10KSk6KG89ZyxnPXQpLGc9PT10JiYoZz1udWxsKSxnIT09dD8oaD1baCx1LGddLGE9aCk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSxhfWZ1bmN0aW9uIExyKCl7dmFyIGEsaCx1LGcscDtyZXR1cm4gYT1vLGkuc3Vic3RyKG8sNCk9PT1iZT8oaD1iZSxvKz00KTooaD10LHk9PT0wJiZiKFZzKSksaCE9PXQ/KHU9RygpLHUhPT10PyhnPVhyKCksZyE9PXQ/KHA9JCgpLHAhPT10PyhoPVtoLHUsZyxwXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSxhfWZ1bmN0aW9uIFhyKCl7dmFyIGE7cmV0dXJuIGkuc3Vic3RyKG8sNCk9PT12ZT8oYT12ZSxvKz00KTooYT10LHk9PT0wJiZiKFdzKSksYT09PXQmJihpLnN1YnN0cihvLDQpPT09eGU/KGE9eGUsbys9NCk6KGE9dCx5PT09MCYmYihLcykpKSxhfWZ1bmN0aW9uIFlyKCl7dmFyIGEsaCx1LGcscDtyZXR1cm4gYT1vLGkuc3Vic3RyKG8sNCk9PT1NZT8oaD1NZSxvKz00KTooaD10LHk9PT0wJiZiKGpzKSksaCE9PXQ/KHU9RygpLHUhPT10PyhnPVVyKCksZyE9PXQ/KHA9JCgpLHAhPT10PyhoPVtoLHUsZyxwXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSxhfWZ1bmN0aW9uIFVyKCl7dmFyIGEsaCx1LGc7cmV0dXJuIGE9byxpLnN1YnN0cihvLDQpPT09JGU/KGg9JGUsbys9NCk6KGg9dCx5PT09MCYmYihacykpLGg9PT10JiYoaS5zdWJzdHIobyw1KT09PUNlPyhoPUNlLG8rPTUpOihoPXQseT09PTAmJmIoSnMpKSksaCE9PXQ/KHU9RygpLHUhPT10PyhpLnN1YnN0cihvLDIpPT09U2U/KGc9U2Usbys9Mik6KGc9dCx5PT09MCYmYihRcykpLGc9PT10JiYoaS5zdWJzdHIobyw0KT09PUVlPyhnPUVlLG8rPTQpOihnPXQseT09PTAmJmIodHIpKSksZyE9PXQ/KGg9W2gsdSxnXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCksYX1mdW5jdGlvbiBCcigpe3ZhciBhLGgsdTtyZXR1cm4gYT1vLGkuc3Vic3RyKG8sNik9PT1EZT8oaD1EZSxvKz02KTooaD10LHk9PT0wJiZiKGVyKSksaCE9PXQ/KHU9JCgpLHUhPT10PyhoPVtoLHVdLGE9aCk6KG89YSxhPXQpKToobz1hLGE9dCksYX1mdW5jdGlvbiBidCgpe3ZhciBhLGgsdSxnLHAsZCxNLEUsXztyZXR1cm4gYT1vLGkuY2hhckNvZGVBdChvKT09PTc2PyhoPXB0LG8rKyk6KGg9dCx5PT09MCYmYihkdCkpLGghPT10Pyh1PVgoKSx1IT09dD8oZz0kKCksZyE9PXQ/KGg9W2gsdSxnXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCksYT09PXQmJihhPW8saS5jaGFyQ29kZUF0KG8pPT09NzY/KGg9cHQsbysrKTooaD10LHk9PT0wJiZiKGR0KSksaCE9PXQ/KHU9WCgpLHUhPT10PyhpLmNoYXJDb2RlQXQobyk9PT02OD8oZz1yZSxvKyspOihnPXQseT09PTAmJmIoaWUpKSxnPT09dCYmKGkuY2hhckNvZGVBdChvKT09PTgyPyhnPUF0LG8rKyk6KGc9dCx5PT09MCYmYihPdCkpKSxnIT09dD8ocD1YKCkscCE9PXQ/KGQ9JCgpLGQhPT10PyhoPVtoLHUsZyxwLGRdLGE9aCk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCksYT09PXQmJihhPW8saS5jaGFyQ29kZUF0KG8pPT09NzY/KGg9cHQsbysrKTooaD10LHk9PT0wJiZiKGR0KSksaCE9PXQ/KHU9WCgpLHUhPT10PyhpLnN1YnN0cihvLDIpPT09UGU/KGc9UGUsbys9Mik6KGc9dCx5PT09MCYmYihzcikpLGc9PT10JiYoaS5zdWJzdHIobywyKT09PWtlPyhnPWtlLG8rPTIpOihnPXQseT09PTAmJmIocnIpKSksZyE9PXQ/KHA9WCgpLHAhPT10PyhpLnN1YnN0cihvLDIpPT09QWU/KGQ9QWUsbys9Mik6KGQ9dCx5PT09MCYmYihpcikpLGQ9PT10JiYoaS5zdWJzdHIobywyKT09PU9lPyhkPU9lLG8rPTIpOihkPXQseT09PTAmJmIobnIpKSksZCE9PXQ/KE09WCgpLE0hPT10PyhFPXFyKCksRT09PXQmJihFPW51bGwpLEUhPT10PyhfPSQoKSxfIT09dD8oaD1baCx1LGcscCxkLE0sRSxfXSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCkpOihvPWEsYT10KSk6KG89YSxhPXQpKSksYX1mdW5jdGlvbiBxcigpe3ZhciBhO3JldHVybiBpLnN1YnN0cihvLDQpPT09VGU/KGE9VGUsbys9NCk6KGE9dCx5PT09MCYmYihhcikpLGE9PT10JiYoaS5zdWJzdHIobyw0KT09PUZlPyhhPUZlLG8rPTQpOihhPXQseT09PTAmJmIob3IpKSksYX1mdW5jdGlvbiAkKCl7dmFyIGEsaCx1LGcscCxkLE0sRTtpZihhPW8saD1HKCksaCE9PXQpe2lmKHU9byxpLmNoYXJDb2RlQXQobyk9PT01OT8oZz1scixvKyspOihnPXQseT09PTAmJmIoaHIpKSxnIT09dCl7Zm9yKHA9W10sZD1vLE09byx5KyssRT1GdCgpLHktLSxFPT09dD9NPXZvaWQgMDoobz1NLE09dCksTSE9PXQ/KGkubGVuZ3RoPm8/KEU9aS5jaGFyQXQobyksbysrKTooRT10LHk9PT0wJiZiKE5lKSksRSE9PXQ/KE09W00sRV0sZD1NKToobz1kLGQ9dCkpOihvPWQsZD10KTtkIT09dDspcC5wdXNoKGQpLGQ9byxNPW8seSsrLEU9RnQoKSx5LS0sRT09PXQ/TT12b2lkIDA6KG89TSxNPXQpLE0hPT10PyhpLmxlbmd0aD5vPyhFPWkuY2hhckF0KG8pLG8rKyk6KEU9dCx5PT09MCYmYihOZSkpLEUhPT10PyhNPVtNLEVdLGQ9TSk6KG89ZCxkPXQpKToobz1kLGQ9dCk7cCE9PXQ/KGc9W2cscF0sdT1nKToobz11LHU9dCl9ZWxzZSBvPXUsdT10O3U9PT10JiYodT1udWxsKSx1IT09dD8oZz1GdCgpLGchPT10PyhtdD1hLGg9Y3IoKSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpfWVsc2Ugbz1hLGE9dDtyZXR1cm4gYX1mdW5jdGlvbiBYKCl7dmFyIGEsaCx1LGcscDtyZXR1cm4gYT1vLGg9WGUoKSxoIT09dD8odT1vLGkuY2hhckNvZGVBdChvKT09PTQ2PyhnPXVyLG8rKyk6KGc9dCx5PT09MCYmYihmcikpLGchPT10PyhwPVhlKCkscCE9PXQ/KGc9W2cscF0sdT1nKToobz11LHU9dCkpOihvPXUsdT10KSx1PT09dCYmKHU9bnVsbCksdSE9PXQ/KGc9RygpLGchPT10PyhtdD1hLGg9Z3IoKSxhPWgpOihvPWEsYT10KSk6KG89YSxhPXQpKToobz1hLGE9dCksYX1mdW5jdGlvbiBYZSgpe3ZhciBhLGg7aWYoYT1bXSxoPVllKCksaCE9PXQpZm9yKDtoIT09dDspYS5wdXNoKGgpLGg9WWUoKTtlbHNlIGE9dDtyZXR1cm4gYX1mdW5jdGlvbiBZZSgpe3ZhciBhO3JldHVybiBwci50ZXN0KGkuY2hhckF0KG8pKT8oYT1pLmNoYXJBdChvKSxvKyspOihhPXQseT09PTAmJmIoZHIpKSxhfWZ1bmN0aW9uIEcoKXt2YXIgYSxoLHU7Zm9yKGE9byxoPVtdLHU9VWUoKTt1IT09dDspaC5wdXNoKHUpLHU9VWUoKTtyZXR1cm4gaCE9PXQmJihtdD1hLGg9bXIoKSksYT1oLGF9ZnVuY3Rpb24gVWUoKXt2YXIgYTtyZXR1cm4gaS5jaGFyQ29kZUF0KG8pPT09MzI/KGE9eXIsbysrKTooYT10LHk9PT0wJiZiKHdyKSksYX1mdW5jdGlvbiBGdCgpe3ZhciBhLGgsdTtyZXR1cm4gYT1vLGkuY2hhckNvZGVBdChvKT09PTEzPyhoPWJyLG8rKyk6KGg9dCx5PT09MCYmYih2cikpLGg9PT10JiYoaD1udWxsKSxoIT09dD8oaS5jaGFyQ29kZUF0KG8pPT09MTA/KHU9eHIsbysrKToodT10LHk9PT0wJiZiKE1yKSksdSE9PXQ/KGg9W2gsdV0sYT1oKToobz1hLGE9dCkpOihvPWEsYT10KSxhfWlmKHd0PWMoKSx3dCE9PXQmJm89PT1pLmxlbmd0aClyZXR1cm4gd3Q7dGhyb3cgd3QhPT10JiZvPGkubGVuZ3RoJiZiKFNyKCkpLEVyKFR0LFY8aS5sZW5ndGg/aS5jaGFyQXQoVik6bnVsbCxWPGkubGVuZ3RoP3plKFYsVisxKTp6ZShWLFYpKX1yZXR1cm57U3ludGF4RXJyb3I6ZSxwYXJzZTpyfX0oKTtjbGFzcyBEe2NvbnN0cnVjdG9yKGUscil7dGhpcy54PWUsdGhpcy56PXJ9aXNFcXVhbChlKXtyZXR1cm4gdGhpcy54PT09ZS54JiZ0aGlzLno9PT1lLnp9dG9TdHJpbmcoKXtyZXR1cm5gJHt0aGlzLnh9LCR7dGhpcy56fWB9b2Zmc2V0QnkoZSxyPTApe3JldHVybiBuZXcgRCh0aGlzLngrZSx0aGlzLnorcil9fWNsYXNzIEl7Y29uc3RydWN0b3IoZSxyLGkpe3RoaXMudHlwZT1lLHRoaXMuc3RhcnQ9cix0aGlzLmVuZD1pfWlzRXF1YWwoZSl7cmV0dXJuIHRoaXMudHlwZT09PWUudHlwZSYmdGhpcy5zdGFydC5pc0VxdWFsKGUuc3RhcnQpJiZ0aGlzLmVuZC5pc0VxdWFsKGUuZW5kKX1pc0NvbGluZWFyKGUpe2lmKHRoaXMudHlwZSE9PSJMSU5FInx8dGhpcy50eXBlIT09ZS50eXBlKXJldHVybjtjb25zdCByPXRoaXMuZW5kLngtdGhpcy5zdGFydC54LGk9ZS5lbmQueC1lLnN0YXJ0Lngsbj0odGhpcy5lbmQuei10aGlzLnN0YXJ0LnopL3IsdD0oZS5lbmQuei1lLnN0YXJ0LnopL2k7cmV0dXJuIShyPT09MCYmaT09PTApJiZNYXRoLmFicyhuLXQpPjFlLTU/ITE6KHRoaXMuc3RhcnQueC1lLnN0YXJ0LngpKih0aGlzLmVuZC56LXRoaXMuc3RhcnQueik9PT1yKih0aGlzLnN0YXJ0LnotZS5zdGFydC56KX1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuc3RhcnQuaXNFcXVhbCh0aGlzLmVuZCl9dG9TdHJpbmcoKXtyZXR1cm5gJHt0aGlzLnR5cGV9OiR7dGhpcy5zdGFydH0tJHt0aGlzLmVuZH1gfW9mZnNldEJ5KGUscil7cmV0dXJuIG5ldyBJKHRoaXMudHlwZSx0aGlzLnN0YXJ0Lm9mZnNldEJ5KGUsciksdGhpcy5lbmQub2Zmc2V0QnkoZSxyKSl9fWNsYXNzIEJle2NvbnN0cnVjdG9yKGUscil7dGhpcy5kaWFtZXRlcj1lLHRoaXMubGVuZ3RoPXJ9Z2V0U2VnbWVudHMoKXtyZXR1cm5bbmV3IEkoIkxJTkUiLG5ldyBEKDAsMCksbmV3IEQodGhpcy5kaWFtZXRlci8yLDApKSxuZXcgSSgiTElORSIsbmV3IEQodGhpcy5kaWFtZXRlci8yLDApLG5ldyBEKHRoaXMuZGlhbWV0ZXIvMix0aGlzLmxlbmd0aCkpLG5ldyBJKCJMSU5FIixuZXcgRCh0aGlzLmRpYW1ldGVyLzIsdGhpcy5sZW5ndGgpLG5ldyBEKDAsdGhpcy5sZW5ndGgpKSxuZXcgSSgiTElORSIsbmV3IEQoMCx0aGlzLmxlbmd0aCksbmV3IEQoMCwwKSldfX1jbGFzcyBsdHtjb25zdHJ1Y3RvcihlLHIsaSxuLHQsbCl7dGhpcy50eXBlPWUsdGhpcy53aWR0aE1tPXIsdGhpcy5oZWlnaHRNbT1pLHRoaXMuY29ybmVyUmFkaXVzTW09bix0aGlzLmFuZ2xlRGVnPXQsdGhpcy5ub3NlQW5nbGVEZWc9bH19Y2xhc3MgcWV7Y29uc3RydWN0b3IoZSxyLGkpe3RoaXMubW92ZU1tTWluPWUsdGhpcy5wYXNzTW1NaW49cix0aGlzLnBhcnRNbU1pbj1pfX1jbGFzcyBfZXtjb25zdHJ1Y3RvcihlLHIpe3RoaXMuY3V0TW09ZSx0aGlzLmZpbmlzaE1tPXJ9fWNvbnN0IEhlPXtNTToxLENNOjEwLE06MWUzLEZUOjMwNC44LElOOjI1LjR9O2NsYXNzIE50e2NvbnN0cnVjdG9yKGUpe1QodGhpcywiZGF0YSIpO1QodGhpcywidW5pdHNNdWx0aXBsaWVyIiwxKTtUKHRoaXMsIm91dHNpZGVNYXhSYWRpdXMiLDApO1QodGhpcywib3V0c2lkZSIpO1QodGhpcywib3V0c2lkZVNlZ21lbnRzIik7VCh0aGlzLCJpbnNpZGUiKTtUKHRoaXMsImluc2lkZVNlZ21lbnRzIik7dGhpcy50ZXh0PWUsdGhpcy5kYXRhPVEucGFyc2UoZStgCmApLHRoaXMudW5pdHNNdWx0aXBsaWVyPXRoaXMuZGF0YVsxXT9IZVt0aGlzLmRhdGFbMV1bMl1dOjEsdGhpcy5vdXRzaWRlPXRoaXMuZ2V0U2VnbWVudHNGb3JTaWRlKHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoLTNdLDApLHRoaXMub3V0c2lkZU1heFJhZGl1cz10aGlzLm91dHNpZGUubGVuZ3RoP01hdGgubWF4LmFwcGx5KG51bGwsdGhpcy5vdXRzaWRlLm1hcChyPT5NYXRoLm1heChyLnN0YXJ0Lngsci5lbmQueCkpKTowLHRoaXMuaW5zaWRlPXRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoLTJdP3RoaXMuZ2V0U2VnbWVudHNGb3JTaWRlKHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoLTJdWzJdLHRoaXMuZ2V0U3RvY2tEaWFtZXRlcigpLzIpOltdLHRoaXMub3V0c2lkZVNlZ21lbnRzPXRoaXMuY2xvc2VMb29wKHRoaXMub3V0c2lkZSwwKSx0aGlzLmluc2lkZVNlZ21lbnRzPXRoaXMuZ2V0U3RvY2tEaWFtZXRlcigpPjA/dGhpcy5jbG9zZUxvb3AodGhpcy5pbnNpZGUsdGhpcy5nZXRTdG9ja0RpYW1ldGVyKCkvMik6W10sdGhpcy5nZXRUb29sKCl9Z2V0VGV4dCgpe3JldHVybiB0aGlzLnRleHR9Z2V0VGl0bGUoKXtyZXR1cm4gdGhpcy5kYXRhWzBdWzFdfHwiIn1nZXRTdG9jaygpe2NvbnN0IGU9dGhpcy5nZXRTdG9ja0RpYW1ldGVyKCkscj10aGlzLmdldFN0b2NrTGVuZ3RoKCk7cmV0dXJuIGU+MCYmcj4wP25ldyBCZShlLHIpOm51bGx9Z2V0VG9vbCgpe2lmKCF0aGlzLmRhdGFbNV0pcmV0dXJuIG5ldyBsdCgiUkVDVCIsMywzLC40KTtjb25zdCBlPXRoaXMuZGF0YVs1XVsyXSxyPXRoaXMuZGF0YVs1XVs0XSxpPXJbMF0/clswXVsxXSp0aGlzLnVuaXRzTXVsdGlwbGllcjowLG49clsxXT9yWzFdWzFdKnRoaXMudW5pdHNNdWx0aXBsaWVyOjAsdD1yWzJdP3JbMl1bMV0qdGhpcy51bml0c011bHRpcGxpZXI6MCxsPXJbM10/clszXVsxXSp0aGlzLnVuaXRzTXVsdGlwbGllcjowLGM9cls0XT9yWzRdWzFdKnRoaXMudW5pdHNNdWx0aXBsaWVyOjA7aWYoZT09PSJSRUNUIil7aWYobCl0aHJvdyBuZXcgRXJyb3IoIkEgbm90IGltcGxlbWVudGVkIGZvciBUT09MIFJFQ1QiKTtpZihjKXRocm93IG5ldyBFcnJvcigiTkEgbm90IHN1cHBvcnRlZCBmb3IgVE9PTCBSRUNUIik7cmV0dXJuIG5ldyBsdCgiUkVDVCIsbnx8Myx0fHxufHwzLGkpfWVsc2UgaWYoZT09PSJST1VORCIpe2lmKG4pdGhyb3cgbmV3IEVycm9yKCJUT09MIFJPVU5EIEwgaXMgYWxyZWFkeSBkZWZpbmVkIGJ5IFIiKTtpZih0KXRocm93IG5ldyBFcnJvcigiVE9PTCBST1VORCBIIGlzIGFscmVhZHkgZGVmaW5lZCBieSBSIik7cmV0dXJuIG5ldyBsdCgiUk9VTkQiLGkqMixpKjIsaSl9ZWxzZSBpZihlPT09IkFORyIpe2lmKGM8PTApdGhyb3cgbmV3IEVycm9yKCJTcGVjaWZ5IHBvc2l0aXZlIHRvb2wgbm9zZSBhbmdsZSBOQSIpO2lmKHQpdGhyb3cgbmV3IEVycm9yKCJUT09MIEFORyBIIGlzIGlnbm9yZWQsIHVzZSBMIik7cmV0dXJuIG5ldyBsdCgiQU5HIixufHwxMCx0fHwxMCxpLGwsYyl9dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIHRvb2wgIitlKX1nZXRGZWVkKCl7Y29uc3QgZT10aGlzLmRhdGFbOV0/dGhpcy5kYXRhWzldWzJdOltdO3JldHVybiBuZXcgcWUoKGVbMF0/ZVswXVsxXTowKSp0aGlzLnVuaXRzTXVsdGlwbGllcnx8MjAwLChlWzFdP2VbMV1bMV06MCkqdGhpcy51bml0c011bHRpcGxpZXJ8fDUwLChlWzJdP2VbMl1bMV06MCkqdGhpcy51bml0c011bHRpcGxpZXJ8fDEwKX1nZXREZXB0aCgpe2NvbnN0IGU9dGhpcy5kYXRhWzddP3RoaXMuZGF0YVs3XVsyXTpbXSxyPWVbMF0saT1lWzFdO3JldHVybiBuZXcgX2UoKHI/clsxXTowKSp0aGlzLnVuaXRzTXVsdGlwbGllcnx8LjUsKGk/aVsxXTowKSp0aGlzLnVuaXRzTXVsdGlwbGllcnx8LjEpfWdldE1vZGUoKXt2YXIgZTtyZXR1cm4oZT10aGlzLmRhdGFbMTFdKSE9bnVsbCYmZS5sZW5ndGg/dGhpcy5kYXRhWzExXVsyXToiRkFDRSJ9Z2V0WkRpcmVjdGlvbigpe3JldHVybiF0aGlzLmRhdGFbMTNdfHwhdGhpcy5kYXRhWzEzXVsyXT8iTEVGVCI6dGhpcy5kYXRhWzEzXVsyXVswXX1nZXRYRGlyZWN0aW9uKCl7cmV0dXJuIXRoaXMuZGF0YVsxM118fCF0aGlzLmRhdGFbMTNdWzJdPyJVUCI6dGhpcy5kYXRhWzEzXVsyXVsyXX1pc05hbm9FbHNDb21wYXRpYmxlKCl7cmV0dXJuIHRoaXMuZ2V0WkRpcmVjdGlvbigpPT09IkxFRlQiJiZ0aGlzLmdldFhEaXJlY3Rpb24oKT09PSJVUCJ9Z2V0T3V0c2lkZVNlZ21lbnRzKCl7cmV0dXJuIHRoaXMub3V0c2lkZVNlZ21lbnRzLmNvbmNhdCgpfWdldEluc2lkZVNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuaW5zaWRlU2VnbWVudHMuY29uY2F0KCl9Z2V0Q3V0b2ZmU3RhcnRzKCl7Y29uc3QgZT1bXTtsZXQgcj0hMSxpPTA7Zm9yKGxldCBuIG9mIHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoLTNdKXtsZXQgdD1uWzFdO0l0KHQpJiZyP2UucHVzaChpKTpyPSEwLGkrPXRbMV0qdGhpcy51bml0c011bHRpcGxpZXJ9cmV0dXJuIGV9Z2V0U3RvY2tMZW5ndGgoKXtsZXQgZT0xLzAscj0tMS8wO2ZvcihsZXQgaSBvZlsuLi50aGlzLm91dHNpZGUsLi4udGhpcy5pbnNpZGVdKWkuc3RhcnQuejxlJiYoZT1pLnN0YXJ0LnopLGkuZW5kLno8ZSYmKGU9aS5lbmQueiksaS5zdGFydC56PnImJihyPWkuc3RhcnQueiksaS5lbmQuej5yJiYocj1pLmVuZC56KTtyZXR1cm4gci1lfWdldFN0b2NrRGlhbWV0ZXIoKXtpZighdGhpcy5kYXRhfHwhdGhpcy5kYXRhWzNdKXJldHVybiB0aGlzLm91dHNpZGVNYXhSYWRpdXMqMjtjb25zdCBlPXRoaXMuZGF0YVszXVsyXTtyZXR1cm4gZVsxXSooZVswXT09IkQiPzE6MikqdGhpcy51bml0c011bHRpcGxpZXJ9Y2xvc2VMb29wKGUscil7aWYoIWUubGVuZ3RoKXJldHVybltdO2NvbnN0IGk9ZS5hdCgwKSxuPWUuYXQoLTEpO2xldCB0PVJ0KEN0KFJ0KFtuZXcgSSgiTElORSIsbmV3IEQocixpLnN0YXJ0LnopLGkuc3RhcnQpLC4uLmUsbmV3IEkoIkxJTkUiLG4uZW5kLG5ldyBEKHIsbi5lbmQueikpLG5ldyBJKCJMSU5FIixuZXcgRChyLG4uZW5kLnopLG5ldyBEKHIsaS5zdGFydC56KSldKSkpO3JldHVybiB0Lmxlbmd0aCYmKHQudW5zaGlmdCh0LnBvcCgpKSx0PUN0KHQpKSx0Lmxlbmd0aDwzP1tdOnR9Z2V0U2VnbWVudHNGb3JTaWRlKGUscil7Y29uc3QgaT1bXTtsZXQgbj0wO2ZvcihsZXQgdCBvZiBlKXtsZXQgbD10WzFdLGMsZjtpZihsWzJdPT09IlIiKWM9Zj1sWzNdKnRoaXMudW5pdHNNdWx0aXBsaWVyO2Vsc2UgaWYobFsyXT09PSJEIiljPWY9bFszXS8yKnRoaXMudW5pdHNNdWx0aXBsaWVyO2Vsc2UgaWYobFsyXT09PSJEUyJ8fGxbMl09PT0iUlMiKWM9bFszXS8obFsyXT09PSJEUyI/MjoxKSp0aGlzLnVuaXRzTXVsdGlwbGllcixmPWxbNV0vKGxbNF09PT0iREUiPzI6MSkqdGhpcy51bml0c011bHRpcGxpZXI7ZWxzZSBpZihJdChsKSljPXIsZj1yO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJ1bmltcGxlbWVudGVkICIrbCk7Y29uc3Qgdz1uZXcgRChjLG4pO2lmKGkubGVuZ3RoKXtjb25zdCBTPWkuYXQoLTEpLmVuZDtTLmlzRXF1YWwodyl8fGkucHVzaChuZXcgSSgiTElORSIsUyx3KSl9aS5wdXNoKG5ldyBJKGxbNl18fCJMSU5FIix3LG5ldyBEKGYsbis9bFsxXSp0aGlzLnVuaXRzTXVsdGlwbGllcikpKX1yZXR1cm4gaX19ZnVuY3Rpb24gQ3Qocyl7Zm9yKGxldCBlPTA7ZTxzLmxlbmd0aC0xO2UrKyl7Y29uc3Qgcj1zW2VdLGk9c1tlKzFdO2lmKHIuaXNDb2xpbmVhcihpKSl7Y29uc3Qgbj1zLmNvbmNhdCgpO3JldHVybiBuLnNwbGljZShlLDIsbmV3IEkoci50eXBlLHIuc3RhcnQsaS5lbmQpKSxDdChuKX19cmV0dXJuIHN9ZnVuY3Rpb24gUnQocyl7Y29uc3QgZT1bXTtmb3IobGV0IHIgb2YgcylyLmlzRW1wdHkoKXx8ZS5wdXNoKHIpO3JldHVybiBlfWZ1bmN0aW9uIEl0KHMpe3JldHVybiBzLmxlbmd0aD09PTN8fHNbMl09PT0iRCImJiFzWzNdfWZ1bmN0aW9uIEdlKHMpe3JldHVybiBzJiZzLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCJkZWZhdWx0Iik/cy5kZWZhdWx0OnN9dmFyIHp0PXtleHBvcnRzOnt9fSxMdD17YWxpY2VibHVlOlsyNDAsMjQ4LDI1NV0sYW50aXF1ZXdoaXRlOlsyNTAsMjM1LDIxNV0sYXF1YTpbMCwyNTUsMjU1XSxhcXVhbWFyaW5lOlsxMjcsMjU1LDIxMl0sYXp1cmU6WzI0MCwyNTUsMjU1XSxiZWlnZTpbMjQ1LDI0NSwyMjBdLGJpc3F1ZTpbMjU1LDIyOCwxOTZdLGJsYWNrOlswLDAsMF0sYmxhbmNoZWRhbG1vbmQ6WzI1NSwyMzUsMjA1XSxibHVlOlswLDAsMjU1XSxibHVldmlvbGV0OlsxMzgsNDMsMjI2XSxicm93bjpbMTY1LDQyLDQyXSxidXJseXdvb2Q6WzIyMiwxODQsMTM1XSxjYWRldGJsdWU6Wzk1LDE1OCwxNjBdLGNoYXJ0cmV1c2U6WzEyNywyNTUsMF0sY2hvY29sYXRlOlsyMTAsMTA1LDMwXSxjb3JhbDpbMjU1LDEyNyw4MF0sY29ybmZsb3dlcmJsdWU6WzEwMCwxNDksMjM3XSxjb3Juc2lsazpbMjU1LDI0OCwyMjBdLGNyaW1zb246WzIyMCwyMCw2MF0sY3lhbjpbMCwyNTUsMjU1XSxkYXJrYmx1ZTpbMCwwLDEzOV0sZGFya2N5YW46WzAsMTM5LDEzOV0sZGFya2dvbGRlbnJvZDpbMTg0LDEzNCwxMV0sZGFya2dyYXk6WzE2OSwxNjksMTY5XSxkYXJrZ3JlZW46WzAsMTAwLDBdLGRhcmtncmV5OlsxNjksMTY5LDE2OV0sZGFya2toYWtpOlsxODksMTgzLDEwN10sZGFya21hZ2VudGE6WzEzOSwwLDEzOV0sZGFya29saXZlZ3JlZW46Wzg1LDEwNyw0N10sZGFya29yYW5nZTpbMjU1LDE0MCwwXSxkYXJrb3JjaGlkOlsxNTMsNTAsMjA0XSxkYXJrcmVkOlsxMzksMCwwXSxkYXJrc2FsbW9uOlsyMzMsMTUwLDEyMl0sZGFya3NlYWdyZWVuOlsxNDMsMTg4LDE0M10sZGFya3NsYXRlYmx1ZTpbNzIsNjEsMTM5XSxkYXJrc2xhdGVncmF5Ols0Nyw3OSw3OV0sZGFya3NsYXRlZ3JleTpbNDcsNzksNzldLGRhcmt0dXJxdW9pc2U6WzAsMjA2LDIwOV0sZGFya3Zpb2xldDpbMTQ4LDAsMjExXSxkZWVwcGluazpbMjU1LDIwLDE0N10sZGVlcHNreWJsdWU6WzAsMTkxLDI1NV0sZGltZ3JheTpbMTA1LDEwNSwxMDVdLGRpbWdyZXk6WzEwNSwxMDUsMTA1XSxkb2RnZXJibHVlOlszMCwxNDQsMjU1XSxmaXJlYnJpY2s6WzE3OCwzNCwzNF0sZmxvcmFsd2hpdGU6WzI1NSwyNTAsMjQwXSxmb3Jlc3RncmVlbjpbMzQsMTM5LDM0XSxmdWNoc2lhOlsyNTUsMCwyNTVdLGdhaW5zYm9ybzpbMjIwLDIyMCwyMjBdLGdob3N0d2hpdGU6WzI0OCwyNDgsMjU1XSxnb2xkOlsyNTUsMjE1LDBdLGdvbGRlbnJvZDpbMjE4LDE2NSwzMl0sZ3JheTpbMTI4LDEyOCwxMjhdLGdyZWVuOlswLDEyOCwwXSxncmVlbnllbGxvdzpbMTczLDI1NSw0N10sZ3JleTpbMTI4LDEyOCwxMjhdLGhvbmV5ZGV3OlsyNDAsMjU1LDI0MF0saG90cGluazpbMjU1LDEwNSwxODBdLGluZGlhbnJlZDpbMjA1LDkyLDkyXSxpbmRpZ286Wzc1LDAsMTMwXSxpdm9yeTpbMjU1LDI1NSwyNDBdLGtoYWtpOlsyNDAsMjMwLDE0MF0sbGF2ZW5kZXI6WzIzMCwyMzAsMjUwXSxsYXZlbmRlcmJsdXNoOlsyNTUsMjQwLDI0NV0sbGF3bmdyZWVuOlsxMjQsMjUyLDBdLGxlbW9uY2hpZmZvbjpbMjU1LDI1MCwyMDVdLGxpZ2h0Ymx1ZTpbMTczLDIxNiwyMzBdLGxpZ2h0Y29yYWw6WzI0MCwxMjgsMTI4XSxsaWdodGN5YW46WzIyNCwyNTUsMjU1XSxsaWdodGdvbGRlbnJvZHllbGxvdzpbMjUwLDI1MCwyMTBdLGxpZ2h0Z3JheTpbMjExLDIxMSwyMTFdLGxpZ2h0Z3JlZW46WzE0NCwyMzgsMTQ0XSxsaWdodGdyZXk6WzIxMSwyMTEsMjExXSxsaWdodHBpbms6WzI1NSwxODIsMTkzXSxsaWdodHNhbG1vbjpbMjU1LDE2MCwxMjJdLGxpZ2h0c2VhZ3JlZW46WzMyLDE3OCwxNzBdLGxpZ2h0c2t5Ymx1ZTpbMTM1LDIwNiwyNTBdLGxpZ2h0c2xhdGVncmF5OlsxMTksMTM2LDE1M10sbGlnaHRzbGF0ZWdyZXk6WzExOSwxMzYsMTUzXSxsaWdodHN0ZWVsYmx1ZTpbMTc2LDE5NiwyMjJdLGxpZ2h0eWVsbG93OlsyNTUsMjU1LDIyNF0sbGltZTpbMCwyNTUsMF0sbGltZWdyZWVuOls1MCwyMDUsNTBdLGxpbmVuOlsyNTAsMjQwLDIzMF0sbWFnZW50YTpbMjU1LDAsMjU1XSxtYXJvb246WzEyOCwwLDBdLG1lZGl1bWFxdWFtYXJpbmU6WzEwMiwyMDUsMTcwXSxtZWRpdW1ibHVlOlswLDAsMjA1XSxtZWRpdW1vcmNoaWQ6WzE4Niw4NSwyMTFdLG1lZGl1bXB1cnBsZTpbMTQ3LDExMiwyMTldLG1lZGl1bXNlYWdyZWVuOls2MCwxNzksMTEzXSxtZWRpdW1zbGF0ZWJsdWU6WzEyMywxMDQsMjM4XSxtZWRpdW1zcHJpbmdncmVlbjpbMCwyNTAsMTU0XSxtZWRpdW10dXJxdW9pc2U6WzcyLDIwOSwyMDRdLG1lZGl1bXZpb2xldHJlZDpbMTk5LDIxLDEzM10sbWlkbmlnaHRibHVlOlsyNSwyNSwxMTJdLG1pbnRjcmVhbTpbMjQ1LDI1NSwyNTBdLG1pc3R5cm9zZTpbMjU1LDIyOCwyMjVdLG1vY2Nhc2luOlsyNTUsMjI4LDE4MV0sbmF2YWpvd2hpdGU6WzI1NSwyMjIsMTczXSxuYXZ5OlswLDAsMTI4XSxvbGRsYWNlOlsyNTMsMjQ1LDIzMF0sb2xpdmU6WzEyOCwxMjgsMF0sb2xpdmVkcmFiOlsxMDcsMTQyLDM1XSxvcmFuZ2U6WzI1NSwxNjUsMF0sb3JhbmdlcmVkOlsyNTUsNjksMF0sb3JjaGlkOlsyMTgsMTEyLDIxNF0scGFsZWdvbGRlbnJvZDpbMjM4LDIzMiwxNzBdLHBhbGVncmVlbjpbMTUyLDI1MSwxNTJdLHBhbGV0dXJxdW9pc2U6WzE3NSwyMzgsMjM4XSxwYWxldmlvbGV0cmVkOlsyMTksMTEyLDE0N10scGFwYXlhd2hpcDpbMjU1LDIzOSwyMTNdLHBlYWNocHVmZjpbMjU1LDIxOCwxODVdLHBlcnU6WzIwNSwxMzMsNjNdLHBpbms6WzI1NSwxOTIsMjAzXSxwbHVtOlsyMjEsMTYwLDIyMV0scG93ZGVyYmx1ZTpbMTc2LDIyNCwyMzBdLHB1cnBsZTpbMTI4LDAsMTI4XSxyZWJlY2NhcHVycGxlOlsxMDIsNTEsMTUzXSxyZWQ6WzI1NSwwLDBdLHJvc3licm93bjpbMTg4LDE0MywxNDNdLHJveWFsYmx1ZTpbNjUsMTA1LDIyNV0sc2FkZGxlYnJvd246WzEzOSw2OSwxOV0sc2FsbW9uOlsyNTAsMTI4LDExNF0sc2FuZHlicm93bjpbMjQ0LDE2NCw5Nl0sc2VhZ3JlZW46WzQ2LDEzOSw4N10sc2Vhc2hlbGw6WzI1NSwyNDUsMjM4XSxzaWVubmE6WzE2MCw4Miw0NV0sc2lsdmVyOlsxOTIsMTkyLDE5Ml0sc2t5Ymx1ZTpbMTM1LDIwNiwyMzVdLHNsYXRlYmx1ZTpbMTA2LDkwLDIwNV0sc2xhdGVncmF5OlsxMTIsMTI4LDE0NF0sc2xhdGVncmV5OlsxMTIsMTI4LDE0NF0sc25vdzpbMjU1LDI1MCwyNTBdLHNwcmluZ2dyZWVuOlswLDI1NSwxMjddLHN0ZWVsYmx1ZTpbNzAsMTMwLDE4MF0sdGFuOlsyMTAsMTgwLDE0MF0sdGVhbDpbMCwxMjgsMTI4XSx0aGlzdGxlOlsyMTYsMTkxLDIxNl0sdG9tYXRvOlsyNTUsOTksNzFdLHR1cnF1b2lzZTpbNjQsMjI0LDIwOF0sdmlvbGV0OlsyMzgsMTMwLDIzOF0sd2hlYXQ6WzI0NSwyMjIsMTc5XSx3aGl0ZTpbMjU1LDI1NSwyNTVdLHdoaXRlc21va2U6WzI0NSwyNDUsMjQ1XSx5ZWxsb3c6WzI1NSwyNTUsMF0seWVsbG93Z3JlZW46WzE1NCwyMDUsNTBdfSxYdD17ZXhwb3J0czp7fX0sVmU9ZnVuY3Rpb24oZSl7cmV0dXJuIWV8fHR5cGVvZiBlPT0ic3RyaW5nIj8hMTplIGluc3RhbmNlb2YgQXJyYXl8fEFycmF5LmlzQXJyYXkoZSl8fGUubGVuZ3RoPj0wJiYoZS5zcGxpY2UgaW5zdGFuY2VvZiBGdW5jdGlvbnx8T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLGUubGVuZ3RoLTEpJiZlLmNvbnN0cnVjdG9yLm5hbWUhPT0iU3RyaW5nIil9LFdlPVZlLEtlPUFycmF5LnByb3RvdHlwZS5jb25jYXQsamU9QXJyYXkucHJvdG90eXBlLnNsaWNlLFl0PVh0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7Zm9yKHZhciByPVtdLGk9MCxuPWUubGVuZ3RoO2k8bjtpKyspe3ZhciB0PWVbaV07V2UodCk/cj1LZS5jYWxsKHIsamUuY2FsbCh0KSk6ci5wdXNoKHQpfXJldHVybiByfTtZdC53cmFwPWZ1bmN0aW9uKHMpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBzKFl0KGFyZ3VtZW50cykpfX07dmFyIFplPVh0LmV4cG9ydHMsaXQ9THQsbnQ9WmUsVXQ9T2JqZWN0Lmhhc093blByb3BlcnR5LEJ0PU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKHZhciBTdCBpbiBpdClVdC5jYWxsKGl0LFN0KSYmKEJ0W2l0W1N0XV09U3QpO3ZhciBCPXp0LmV4cG9ydHM9e3RvOnt9LGdldDp7fX07Qi5nZXQ9ZnVuY3Rpb24ocyl7dmFyIGU9cy5zdWJzdHJpbmcoMCwzKS50b0xvd2VyQ2FzZSgpLHIsaTtzd2l0Y2goZSl7Y2FzZSJoc2wiOnI9Qi5nZXQuaHNsKHMpLGk9ImhzbCI7YnJlYWs7Y2FzZSJod2IiOnI9Qi5nZXQuaHdiKHMpLGk9Imh3YiI7YnJlYWs7ZGVmYXVsdDpyPUIuZ2V0LnJnYihzKSxpPSJyZ2IiO2JyZWFrfXJldHVybiByP3ttb2RlbDppLHZhbHVlOnJ9Om51bGx9LEIuZ2V0LnJnYj1mdW5jdGlvbihzKXtpZighcylyZXR1cm4gbnVsbDt2YXIgZT0vXiMoW2EtZjAtOV17Myw0fSkkL2kscj0vXiMoW2EtZjAtOV17Nn0pKFthLWYwLTldezJ9KT8kL2ksaT0vXnJnYmE/XChccyooWystXT9cZCspKD89W1xzLF0pXHMqKD86LFxzKik/KFsrLV0/XGQrKSg/PVtccyxdKVxzKig/OixccyopPyhbKy1dP1xkKylccyooPzpbLHxcL11ccyooWystXT9bXGRcLl0rKSglPylccyopP1wpJC8sbj0vXnJnYmE/XChccyooWystXT9bXGRcLl0rKVwlXHMqLD9ccyooWystXT9bXGRcLl0rKVwlXHMqLD9ccyooWystXT9bXGRcLl0rKVwlXHMqKD86Wyx8XC9dXHMqKFsrLV0/W1xkXC5dKykoJT8pXHMqKT9cKSQvLHQ9L14oXHcrKSQvLGw9WzAsMCwwLDFdLGMsZix3O2lmKGM9cy5tYXRjaChyKSl7Zm9yKHc9Y1syXSxjPWNbMV0sZj0wO2Y8MztmKyspe3ZhciBTPWYqMjtsW2ZdPXBhcnNlSW50KGMuc2xpY2UoUyxTKzIpLDE2KX13JiYobFszXT1wYXJzZUludCh3LDE2KS8yNTUpfWVsc2UgaWYoYz1zLm1hdGNoKGUpKXtmb3IoYz1jWzFdLHc9Y1szXSxmPTA7ZjwzO2YrKylsW2ZdPXBhcnNlSW50KGNbZl0rY1tmXSwxNik7dyYmKGxbM109cGFyc2VJbnQodyt3LDE2KS8yNTUpfWVsc2UgaWYoYz1zLm1hdGNoKGkpKXtmb3IoZj0wO2Y8MztmKyspbFtmXT1wYXJzZUludChjW2YrMV0sMCk7Y1s0XSYmKGNbNV0/bFszXT1wYXJzZUZsb2F0KGNbNF0pKi4wMTpsWzNdPXBhcnNlRmxvYXQoY1s0XSkpfWVsc2UgaWYoYz1zLm1hdGNoKG4pKXtmb3IoZj0wO2Y8MztmKyspbFtmXT1NYXRoLnJvdW5kKHBhcnNlRmxvYXQoY1tmKzFdKSoyLjU1KTtjWzRdJiYoY1s1XT9sWzNdPXBhcnNlRmxvYXQoY1s0XSkqLjAxOmxbM109cGFyc2VGbG9hdChjWzRdKSl9ZWxzZSByZXR1cm4oYz1zLm1hdGNoKHQpKT9jWzFdPT09InRyYW5zcGFyZW50Ij9bMCwwLDAsMF06VXQuY2FsbChpdCxjWzFdKT8obD1pdFtjWzFdXSxsWzNdPTEsbCk6bnVsbDpudWxsO2ZvcihmPTA7ZjwzO2YrKylsW2ZdPUoobFtmXSwwLDI1NSk7cmV0dXJuIGxbM109SihsWzNdLDAsMSksbH0sQi5nZXQuaHNsPWZ1bmN0aW9uKHMpe2lmKCFzKXJldHVybiBudWxsO3ZhciBlPS9eaHNsYT9cKFxzKihbKy1dPyg/OlxkezAsM31cLik/XGQrKSg/OmRlZyk/XHMqLD9ccyooWystXT9bXGRcLl0rKSVccyosP1xzKihbKy1dP1tcZFwuXSspJVxzKig/OlssfFwvXVxzKihbKy1dPyg/PVwuXGR8XGQpKD86MHxbMS05XVxkKik/KD86XC5cZCopPyg/OltlRV1bKy1dP1xkKyk/KVxzKik/XCkkLyxyPXMubWF0Y2goZSk7aWYocil7dmFyIGk9cGFyc2VGbG9hdChyWzRdKSxuPShwYXJzZUZsb2F0KHJbMV0pJTM2MCszNjApJTM2MCx0PUoocGFyc2VGbG9hdChyWzJdKSwwLDEwMCksbD1KKHBhcnNlRmxvYXQoclszXSksMCwxMDApLGM9Sihpc05hTihpKT8xOmksMCwxKTtyZXR1cm5bbix0LGwsY119cmV0dXJuIG51bGx9LEIuZ2V0Lmh3Yj1mdW5jdGlvbihzKXtpZighcylyZXR1cm4gbnVsbDt2YXIgZT0vXmh3YlwoXHMqKFsrLV0/XGR7MCwzfSg/OlwuXGQrKT8pKD86ZGVnKT9ccyosXHMqKFsrLV0/W1xkXC5dKyklXHMqLFxzKihbKy1dP1tcZFwuXSspJVxzKig/OixccyooWystXT8oPz1cLlxkfFxkKSg/OjB8WzEtOV1cZCopPyg/OlwuXGQqKT8oPzpbZUVdWystXT9cZCspPylccyopP1wpJC8scj1zLm1hdGNoKGUpO2lmKHIpe3ZhciBpPXBhcnNlRmxvYXQocls0XSksbj0ocGFyc2VGbG9hdChyWzFdKSUzNjArMzYwKSUzNjAsdD1KKHBhcnNlRmxvYXQoclsyXSksMCwxMDApLGw9SihwYXJzZUZsb2F0KHJbM10pLDAsMTAwKSxjPUooaXNOYU4oaSk/MTppLDAsMSk7cmV0dXJuW24sdCxsLGNdfXJldHVybiBudWxsfSxCLnRvLmhleD1mdW5jdGlvbigpe3ZhciBzPW50KGFyZ3VtZW50cyk7cmV0dXJuIiMiK2h0KHNbMF0pK2h0KHNbMV0pK2h0KHNbMl0pKyhzWzNdPDE/aHQoTWF0aC5yb3VuZChzWzNdKjI1NSkpOiIiKX0sQi50by5yZ2I9ZnVuY3Rpb24oKXt2YXIgcz1udChhcmd1bWVudHMpO3JldHVybiBzLmxlbmd0aDw0fHxzWzNdPT09MT8icmdiKCIrTWF0aC5yb3VuZChzWzBdKSsiLCAiK01hdGgucm91bmQoc1sxXSkrIiwgIitNYXRoLnJvdW5kKHNbMl0pKyIpIjoicmdiYSgiK01hdGgucm91bmQoc1swXSkrIiwgIitNYXRoLnJvdW5kKHNbMV0pKyIsICIrTWF0aC5yb3VuZChzWzJdKSsiLCAiK3NbM10rIikifSxCLnRvLnJnYi5wZXJjZW50PWZ1bmN0aW9uKCl7dmFyIHM9bnQoYXJndW1lbnRzKSxlPU1hdGgucm91bmQoc1swXS8yNTUqMTAwKSxyPU1hdGgucm91bmQoc1sxXS8yNTUqMTAwKSxpPU1hdGgucm91bmQoc1syXS8yNTUqMTAwKTtyZXR1cm4gcy5sZW5ndGg8NHx8c1szXT09PTE/InJnYigiK2UrIiUsICIrcisiJSwgIitpKyIlKSI6InJnYmEoIitlKyIlLCAiK3IrIiUsICIraSsiJSwgIitzWzNdKyIpIn0sQi50by5oc2w9ZnVuY3Rpb24oKXt2YXIgcz1udChhcmd1bWVudHMpO3JldHVybiBzLmxlbmd0aDw0fHxzWzNdPT09MT8iaHNsKCIrc1swXSsiLCAiK3NbMV0rIiUsICIrc1syXSsiJSkiOiJoc2xhKCIrc1swXSsiLCAiK3NbMV0rIiUsICIrc1syXSsiJSwgIitzWzNdKyIpIn0sQi50by5od2I9ZnVuY3Rpb24oKXt2YXIgcz1udChhcmd1bWVudHMpLGU9IiI7cmV0dXJuIHMubGVuZ3RoPj00JiZzWzNdIT09MSYmKGU9IiwgIitzWzNdKSwiaHdiKCIrc1swXSsiLCAiK3NbMV0rIiUsICIrc1syXSsiJSIrZSsiKSJ9LEIudG8ua2V5d29yZD1mdW5jdGlvbihzKXtyZXR1cm4gQnRbcy5zbGljZSgwLDMpXX07ZnVuY3Rpb24gSihzLGUscil7cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGUscykscil9ZnVuY3Rpb24gaHQocyl7dmFyIGU9TWF0aC5yb3VuZChzKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtyZXR1cm4gZS5sZW5ndGg8Mj8iMCIrZTplfXZhciBKZT16dC5leHBvcnRzO2NvbnN0IGF0PUx0LHF0PXt9O2Zvcihjb25zdCBzIG9mIE9iamVjdC5rZXlzKGF0KSlxdFthdFtzXV09cztjb25zdCBtPXtyZ2I6e2NoYW5uZWxzOjMsbGFiZWxzOiJyZ2IifSxoc2w6e2NoYW5uZWxzOjMsbGFiZWxzOiJoc2wifSxoc3Y6e2NoYW5uZWxzOjMsbGFiZWxzOiJoc3YifSxod2I6e2NoYW5uZWxzOjMsbGFiZWxzOiJod2IifSxjbXlrOntjaGFubmVsczo0LGxhYmVsczoiY215ayJ9LHh5ejp7Y2hhbm5lbHM6MyxsYWJlbHM6Inh5eiJ9LGxhYjp7Y2hhbm5lbHM6MyxsYWJlbHM6ImxhYiJ9LGxjaDp7Y2hhbm5lbHM6MyxsYWJlbHM6ImxjaCJ9LGhleDp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJoZXgiXX0sa2V5d29yZDp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJrZXl3b3JkIl19LGFuc2kxNjp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJhbnNpMTYiXX0sYW5zaTI1Njp7Y2hhbm5lbHM6MSxsYWJlbHM6WyJhbnNpMjU2Il19LGhjZzp7Y2hhbm5lbHM6MyxsYWJlbHM6WyJoIiwiYyIsImciXX0sYXBwbGU6e2NoYW5uZWxzOjMsbGFiZWxzOlsicjE2IiwiZzE2IiwiYjE2Il19LGdyYXk6e2NoYW5uZWxzOjEsbGFiZWxzOlsiZ3JheSJdfX07dmFyIF90PW07Zm9yKGNvbnN0IHMgb2YgT2JqZWN0LmtleXMobSkpe2lmKCEoImNoYW5uZWxzImluIG1bc10pKXRocm93IG5ldyBFcnJvcigibWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogIitzKTtpZighKCJsYWJlbHMiaW4gbVtzXSkpdGhyb3cgbmV3IEVycm9yKCJtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiAiK3MpO2lmKG1bc10ubGFiZWxzLmxlbmd0aCE9PW1bc10uY2hhbm5lbHMpdGhyb3cgbmV3IEVycm9yKCJjaGFubmVsIGFuZCBsYWJlbCBjb3VudHMgbWlzbWF0Y2g6ICIrcyk7Y29uc3R7Y2hhbm5lbHM6ZSxsYWJlbHM6cn09bVtzXTtkZWxldGUgbVtzXS5jaGFubmVscyxkZWxldGUgbVtzXS5sYWJlbHMsT2JqZWN0LmRlZmluZVByb3BlcnR5KG1bc10sImNoYW5uZWxzIix7dmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtW3NdLCJsYWJlbHMiLHt2YWx1ZTpyfSl9bS5yZ2IuaHNsPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1swXS8yNTUscj1zWzFdLzI1NSxpPXNbMl0vMjU1LG49TWF0aC5taW4oZSxyLGkpLHQ9TWF0aC5tYXgoZSxyLGkpLGw9dC1uO2xldCBjLGY7dD09PW4/Yz0wOmU9PT10P2M9KHItaSkvbDpyPT09dD9jPTIrKGktZSkvbDppPT09dCYmKGM9NCsoZS1yKS9sKSxjPU1hdGgubWluKGMqNjAsMzYwKSxjPDAmJihjKz0zNjApO2NvbnN0IHc9KG4rdCkvMjtyZXR1cm4gdD09PW4/Zj0wOnc8PS41P2Y9bC8odCtuKTpmPWwvKDItdC1uKSxbYyxmKjEwMCx3KjEwMF19LG0ucmdiLmhzdj1mdW5jdGlvbihzKXtsZXQgZSxyLGksbix0O2NvbnN0IGw9c1swXS8yNTUsYz1zWzFdLzI1NSxmPXNbMl0vMjU1LHc9TWF0aC5tYXgobCxjLGYpLFM9dy1NYXRoLm1pbihsLGMsZiksaz1mdW5jdGlvbih2KXtyZXR1cm4ody12KS82L1MrMS8yfTtyZXR1cm4gUz09PTA/KG49MCx0PTApOih0PVMvdyxlPWsobCkscj1rKGMpLGk9ayhmKSxsPT09dz9uPWktcjpjPT09dz9uPTEvMytlLWk6Zj09PXcmJihuPTIvMytyLWUpLG48MD9uKz0xOm4+MSYmKG4tPTEpKSxbbiozNjAsdCoxMDAsdyoxMDBdfSxtLnJnYi5od2I9ZnVuY3Rpb24ocyl7Y29uc3QgZT1zWzBdLHI9c1sxXTtsZXQgaT1zWzJdO2NvbnN0IG49bS5yZ2IuaHNsKHMpWzBdLHQ9MS8yNTUqTWF0aC5taW4oZSxNYXRoLm1pbihyLGkpKTtyZXR1cm4gaT0xLTEvMjU1Kk1hdGgubWF4KGUsTWF0aC5tYXgocixpKSksW24sdCoxMDAsaSoxMDBdfSxtLnJnYi5jbXlrPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1swXS8yNTUscj1zWzFdLzI1NSxpPXNbMl0vMjU1LG49TWF0aC5taW4oMS1lLDEtciwxLWkpLHQ9KDEtZS1uKS8oMS1uKXx8MCxsPSgxLXItbikvKDEtbil8fDAsYz0oMS1pLW4pLygxLW4pfHwwO3JldHVyblt0KjEwMCxsKjEwMCxjKjEwMCxuKjEwMF19O2Z1bmN0aW9uIFFlKHMsZSl7cmV0dXJuKHNbMF0tZVswXSkqKjIrKHNbMV0tZVsxXSkqKjIrKHNbMl0tZVsyXSkqKjJ9bS5yZ2Iua2V5d29yZD1mdW5jdGlvbihzKXtjb25zdCBlPXF0W3NdO2lmKGUpcmV0dXJuIGU7bGV0IHI9MS8wLGk7Zm9yKGNvbnN0IG4gb2YgT2JqZWN0LmtleXMoYXQpKXtjb25zdCB0PWF0W25dLGw9UWUocyx0KTtsPHImJihyPWwsaT1uKX1yZXR1cm4gaX0sbS5rZXl3b3JkLnJnYj1mdW5jdGlvbihzKXtyZXR1cm4gYXRbc119LG0ucmdiLnh5ej1mdW5jdGlvbihzKXtsZXQgZT1zWzBdLzI1NSxyPXNbMV0vMjU1LGk9c1syXS8yNTU7ZT1lPi4wNDA0NT8oKGUrLjA1NSkvMS4wNTUpKioyLjQ6ZS8xMi45MixyPXI+LjA0MDQ1PygocisuMDU1KS8xLjA1NSkqKjIuNDpyLzEyLjkyLGk9aT4uMDQwNDU/KChpKy4wNTUpLzEuMDU1KSoqMi40OmkvMTIuOTI7Y29uc3Qgbj1lKi40MTI0K3IqLjM1NzYraSouMTgwNSx0PWUqLjIxMjYrciouNzE1MitpKi4wNzIyLGw9ZSouMDE5MytyKi4xMTkyK2kqLjk1MDU7cmV0dXJuW24qMTAwLHQqMTAwLGwqMTAwXX0sbS5yZ2IubGFiPWZ1bmN0aW9uKHMpe2NvbnN0IGU9bS5yZ2IueHl6KHMpO2xldCByPWVbMF0saT1lWzFdLG49ZVsyXTtyLz05NS4wNDcsaS89MTAwLG4vPTEwOC44ODMscj1yPi4wMDg4NTY/cioqKDEvMyk6Ny43ODcqcisxNi8xMTYsaT1pPi4wMDg4NTY/aSoqKDEvMyk6Ny43ODcqaSsxNi8xMTYsbj1uPi4wMDg4NTY/bioqKDEvMyk6Ny43ODcqbisxNi8xMTY7Y29uc3QgdD0xMTYqaS0xNixsPTUwMCooci1pKSxjPTIwMCooaS1uKTtyZXR1cm5bdCxsLGNdfSxtLmhzbC5yZ2I9ZnVuY3Rpb24ocyl7Y29uc3QgZT1zWzBdLzM2MCxyPXNbMV0vMTAwLGk9c1syXS8xMDA7bGV0IG4sdCxsO2lmKHI9PT0wKXJldHVybiBsPWkqMjU1LFtsLGwsbF07aTwuNT9uPWkqKDErcik6bj1pK3ItaSpyO2NvbnN0IGM9MippLW4sZj1bMCwwLDBdO2ZvcihsZXQgdz0wO3c8Mzt3KyspdD1lKzEvMyotKHctMSksdDwwJiZ0KyssdD4xJiZ0LS0sNip0PDE/bD1jKyhuLWMpKjYqdDoyKnQ8MT9sPW46Myp0PDI/bD1jKyhuLWMpKigyLzMtdCkqNjpsPWMsZlt3XT1sKjI1NTtyZXR1cm4gZn0sbS5oc2wuaHN2PWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1swXTtsZXQgcj1zWzFdLzEwMCxpPXNbMl0vMTAwLG49cjtjb25zdCB0PU1hdGgubWF4KGksLjAxKTtpKj0yLHIqPWk8PTE/aToyLWksbio9dDw9MT90OjItdDtjb25zdCBsPShpK3IpLzIsYz1pPT09MD8yKm4vKHQrbik6MipyLyhpK3IpO3JldHVybltlLGMqMTAwLGwqMTAwXX0sbS5oc3YucmdiPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1swXS82MCxyPXNbMV0vMTAwO2xldCBpPXNbMl0vMTAwO2NvbnN0IG49TWF0aC5mbG9vcihlKSU2LHQ9ZS1NYXRoLmZsb29yKGUpLGw9MjU1KmkqKDEtciksYz0yNTUqaSooMS1yKnQpLGY9MjU1KmkqKDEtciooMS10KSk7c3dpdGNoKGkqPTI1NSxuKXtjYXNlIDA6cmV0dXJuW2ksZixsXTtjYXNlIDE6cmV0dXJuW2MsaSxsXTtjYXNlIDI6cmV0dXJuW2wsaSxmXTtjYXNlIDM6cmV0dXJuW2wsYyxpXTtjYXNlIDQ6cmV0dXJuW2YsbCxpXTtjYXNlIDU6cmV0dXJuW2ksbCxjXX19LG0uaHN2LmhzbD1mdW5jdGlvbihzKXtjb25zdCBlPXNbMF0scj1zWzFdLzEwMCxpPXNbMl0vMTAwLG49TWF0aC5tYXgoaSwuMDEpO2xldCB0LGw7bD0oMi1yKSppO2NvbnN0IGM9KDItcikqbjtyZXR1cm4gdD1yKm4sdC89Yzw9MT9jOjItYyx0PXR8fDAsbC89MixbZSx0KjEwMCxsKjEwMF19LG0uaHdiLnJnYj1mdW5jdGlvbihzKXtjb25zdCBlPXNbMF0vMzYwO2xldCByPXNbMV0vMTAwLGk9c1syXS8xMDA7Y29uc3Qgbj1yK2k7bGV0IHQ7bj4xJiYoci89bixpLz1uKTtjb25zdCBsPU1hdGguZmxvb3IoNiplKSxjPTEtaTt0PTYqZS1sLGwmMSYmKHQ9MS10KTtjb25zdCBmPXIrdCooYy1yKTtsZXQgdyxTLGs7c3dpdGNoKGwpe2RlZmF1bHQ6Y2FzZSA2OmNhc2UgMDp3PWMsUz1mLGs9cjticmVhaztjYXNlIDE6dz1mLFM9YyxrPXI7YnJlYWs7Y2FzZSAyOnc9cixTPWMsaz1mO2JyZWFrO2Nhc2UgMzp3PXIsUz1mLGs9YzticmVhaztjYXNlIDQ6dz1mLFM9cixrPWM7YnJlYWs7Y2FzZSA1Onc9YyxTPXIsaz1mO2JyZWFrfXJldHVyblt3KjI1NSxTKjI1NSxrKjI1NV19LG0uY215ay5yZ2I9ZnVuY3Rpb24ocyl7Y29uc3QgZT1zWzBdLzEwMCxyPXNbMV0vMTAwLGk9c1syXS8xMDAsbj1zWzNdLzEwMCx0PTEtTWF0aC5taW4oMSxlKigxLW4pK24pLGw9MS1NYXRoLm1pbigxLHIqKDEtbikrbiksYz0xLU1hdGgubWluKDEsaSooMS1uKStuKTtyZXR1cm5bdCoyNTUsbCoyNTUsYyoyNTVdfSxtLnh5ei5yZ2I9ZnVuY3Rpb24ocyl7Y29uc3QgZT1zWzBdLzEwMCxyPXNbMV0vMTAwLGk9c1syXS8xMDA7bGV0IG4sdCxsO3JldHVybiBuPWUqMy4yNDA2K3IqLTEuNTM3MitpKi0uNDk4Nix0PWUqLS45Njg5K3IqMS44NzU4K2kqLjA0MTUsbD1lKi4wNTU3K3IqLS4yMDQraSoxLjA1NyxuPW4+LjAwMzEzMDg/MS4wNTUqbioqKDEvMi40KS0uMDU1Om4qMTIuOTIsdD10Pi4wMDMxMzA4PzEuMDU1KnQqKigxLzIuNCktLjA1NTp0KjEyLjkyLGw9bD4uMDAzMTMwOD8xLjA1NSpsKiooMS8yLjQpLS4wNTU6bCoxMi45MixuPU1hdGgubWluKE1hdGgubWF4KDAsbiksMSksdD1NYXRoLm1pbihNYXRoLm1heCgwLHQpLDEpLGw9TWF0aC5taW4oTWF0aC5tYXgoMCxsKSwxKSxbbioyNTUsdCoyNTUsbCoyNTVdfSxtLnh5ei5sYWI9ZnVuY3Rpb24ocyl7bGV0IGU9c1swXSxyPXNbMV0saT1zWzJdO2UvPTk1LjA0NyxyLz0xMDAsaS89MTA4Ljg4MyxlPWU+LjAwODg1Nj9lKiooMS8zKTo3Ljc4NyplKzE2LzExNixyPXI+LjAwODg1Nj9yKiooMS8zKTo3Ljc4NypyKzE2LzExNixpPWk+LjAwODg1Nj9pKiooMS8zKTo3Ljc4NyppKzE2LzExNjtjb25zdCBuPTExNipyLTE2LHQ9NTAwKihlLXIpLGw9MjAwKihyLWkpO3JldHVybltuLHQsbF19LG0ubGFiLnh5ej1mdW5jdGlvbihzKXtjb25zdCBlPXNbMF0scj1zWzFdLGk9c1syXTtsZXQgbix0LGw7dD0oZSsxNikvMTE2LG49ci81MDArdCxsPXQtaS8yMDA7Y29uc3QgYz10KiozLGY9bioqMyx3PWwqKjM7cmV0dXJuIHQ9Yz4uMDA4ODU2P2M6KHQtMTYvMTE2KS83Ljc4NyxuPWY+LjAwODg1Nj9mOihuLTE2LzExNikvNy43ODcsbD13Pi4wMDg4NTY/dzoobC0xNi8xMTYpLzcuNzg3LG4qPTk1LjA0Nyx0Kj0xMDAsbCo9MTA4Ljg4Myxbbix0LGxdfSxtLmxhYi5sY2g9ZnVuY3Rpb24ocyl7Y29uc3QgZT1zWzBdLHI9c1sxXSxpPXNbMl07bGV0IG47bj1NYXRoLmF0YW4yKGkscikqMzYwLzIvTWF0aC5QSSxuPDAmJihuKz0zNjApO2NvbnN0IGw9TWF0aC5zcXJ0KHIqcitpKmkpO3JldHVybltlLGwsbl19LG0ubGNoLmxhYj1mdW5jdGlvbihzKXtjb25zdCBlPXNbMF0scj1zWzFdLG49c1syXS8zNjAqMipNYXRoLlBJLHQ9cipNYXRoLmNvcyhuKSxsPXIqTWF0aC5zaW4obik7cmV0dXJuW2UsdCxsXX0sbS5yZ2IuYW5zaTE2PWZ1bmN0aW9uKHMsZT1udWxsKXtjb25zdFtyLGksbl09cztsZXQgdD1lPT09bnVsbD9tLnJnYi5oc3YocylbMl06ZTtpZih0PU1hdGgucm91bmQodC81MCksdD09PTApcmV0dXJuIDMwO2xldCBsPTMwKyhNYXRoLnJvdW5kKG4vMjU1KTw8MnxNYXRoLnJvdW5kKGkvMjU1KTw8MXxNYXRoLnJvdW5kKHIvMjU1KSk7cmV0dXJuIHQ9PT0yJiYobCs9NjApLGx9LG0uaHN2LmFuc2kxNj1mdW5jdGlvbihzKXtyZXR1cm4gbS5yZ2IuYW5zaTE2KG0uaHN2LnJnYihzKSxzWzJdKX0sbS5yZ2IuYW5zaTI1Nj1mdW5jdGlvbihzKXtjb25zdCBlPXNbMF0scj1zWzFdLGk9c1syXTtyZXR1cm4gZT09PXImJnI9PT1pP2U8OD8xNjplPjI0OD8yMzE6TWF0aC5yb3VuZCgoZS04KS8yNDcqMjQpKzIzMjoxNiszNipNYXRoLnJvdW5kKGUvMjU1KjUpKzYqTWF0aC5yb3VuZChyLzI1NSo1KStNYXRoLnJvdW5kKGkvMjU1KjUpfSxtLmFuc2kxNi5yZ2I9ZnVuY3Rpb24ocyl7bGV0IGU9cyUxMDtpZihlPT09MHx8ZT09PTcpcmV0dXJuIHM+NTAmJihlKz0zLjUpLGU9ZS8xMC41KjI1NSxbZSxlLGVdO2NvbnN0IHI9KH5+KHM+NTApKzEpKi41LGk9KGUmMSkqcioyNTUsbj0oZT4+MSYxKSpyKjI1NSx0PShlPj4yJjEpKnIqMjU1O3JldHVybltpLG4sdF19LG0uYW5zaTI1Ni5yZ2I9ZnVuY3Rpb24ocyl7aWYocz49MjMyKXtjb25zdCB0PShzLTIzMikqMTArODtyZXR1cm5bdCx0LHRdfXMtPTE2O2xldCBlO2NvbnN0IHI9TWF0aC5mbG9vcihzLzM2KS81KjI1NSxpPU1hdGguZmxvb3IoKGU9cyUzNikvNikvNSoyNTUsbj1lJTYvNSoyNTU7cmV0dXJuW3IsaSxuXX0sbS5yZ2IuaGV4PWZ1bmN0aW9uKHMpe2NvbnN0IHI9KCgoTWF0aC5yb3VuZChzWzBdKSYyNTUpPDwxNikrKChNYXRoLnJvdW5kKHNbMV0pJjI1NSk8PDgpKyhNYXRoLnJvdW5kKHNbMl0pJjI1NSkpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiIwMDAwMDAiLnN1YnN0cmluZyhyLmxlbmd0aCkrcn0sbS5oZXgucmdiPWZ1bmN0aW9uKHMpe2NvbnN0IGU9cy50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO2lmKCFlKXJldHVyblswLDAsMF07bGV0IHI9ZVswXTtlWzBdLmxlbmd0aD09PTMmJihyPXIuc3BsaXQoIiIpLm1hcChjPT5jK2MpLmpvaW4oIiIpKTtjb25zdCBpPXBhcnNlSW50KHIsMTYpLG49aT4+MTYmMjU1LHQ9aT4+OCYyNTUsbD1pJjI1NTtyZXR1cm5bbix0LGxdfSxtLnJnYi5oY2c9ZnVuY3Rpb24ocyl7Y29uc3QgZT1zWzBdLzI1NSxyPXNbMV0vMjU1LGk9c1syXS8yNTUsbj1NYXRoLm1heChNYXRoLm1heChlLHIpLGkpLHQ9TWF0aC5taW4oTWF0aC5taW4oZSxyKSxpKSxsPW4tdDtsZXQgYyxmO3JldHVybiBsPDE/Yz10LygxLWwpOmM9MCxsPD0wP2Y9MDpuPT09ZT9mPShyLWkpL2wlNjpuPT09cj9mPTIrKGktZSkvbDpmPTQrKGUtcikvbCxmLz02LGYlPTEsW2YqMzYwLGwqMTAwLGMqMTAwXX0sbS5oc2wuaGNnPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1sxXS8xMDAscj1zWzJdLzEwMCxpPXI8LjU/MiplKnI6MiplKigxLXIpO2xldCBuPTA7cmV0dXJuIGk8MSYmKG49KHItLjUqaSkvKDEtaSkpLFtzWzBdLGkqMTAwLG4qMTAwXX0sbS5oc3YuaGNnPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1sxXS8xMDAscj1zWzJdLzEwMCxpPWUqcjtsZXQgbj0wO3JldHVybiBpPDEmJihuPShyLWkpLygxLWkpKSxbc1swXSxpKjEwMCxuKjEwMF19LG0uaGNnLnJnYj1mdW5jdGlvbihzKXtjb25zdCBlPXNbMF0vMzYwLHI9c1sxXS8xMDAsaT1zWzJdLzEwMDtpZihyPT09MClyZXR1cm5baSoyNTUsaSoyNTUsaSoyNTVdO2NvbnN0IG49WzAsMCwwXSx0PWUlMSo2LGw9dCUxLGM9MS1sO2xldCBmPTA7c3dpdGNoKE1hdGguZmxvb3IodCkpe2Nhc2UgMDpuWzBdPTEsblsxXT1sLG5bMl09MDticmVhaztjYXNlIDE6blswXT1jLG5bMV09MSxuWzJdPTA7YnJlYWs7Y2FzZSAyOm5bMF09MCxuWzFdPTEsblsyXT1sO2JyZWFrO2Nhc2UgMzpuWzBdPTAsblsxXT1jLG5bMl09MTticmVhaztjYXNlIDQ6blswXT1sLG5bMV09MCxuWzJdPTE7YnJlYWs7ZGVmYXVsdDpuWzBdPTEsblsxXT0wLG5bMl09Y31yZXR1cm4gZj0oMS1yKSppLFsocipuWzBdK2YpKjI1NSwocipuWzFdK2YpKjI1NSwocipuWzJdK2YpKjI1NV19LG0uaGNnLmhzdj1mdW5jdGlvbihzKXtjb25zdCBlPXNbMV0vMTAwLHI9c1syXS8xMDAsaT1lK3IqKDEtZSk7bGV0IG49MDtyZXR1cm4gaT4wJiYobj1lL2kpLFtzWzBdLG4qMTAwLGkqMTAwXX0sbS5oY2cuaHNsPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1sxXS8xMDAsaT1zWzJdLzEwMCooMS1lKSsuNSplO2xldCBuPTA7cmV0dXJuIGk+MCYmaTwuNT9uPWUvKDIqaSk6aT49LjUmJmk8MSYmKG49ZS8oMiooMS1pKSkpLFtzWzBdLG4qMTAwLGkqMTAwXX0sbS5oY2cuaHdiPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1sxXS8xMDAscj1zWzJdLzEwMCxpPWUrciooMS1lKTtyZXR1cm5bc1swXSwoaS1lKSoxMDAsKDEtaSkqMTAwXX0sbS5od2IuaGNnPWZ1bmN0aW9uKHMpe2NvbnN0IGU9c1sxXS8xMDAsaT0xLXNbMl0vMTAwLG49aS1lO2xldCB0PTA7cmV0dXJuIG48MSYmKHQ9KGktbikvKDEtbikpLFtzWzBdLG4qMTAwLHQqMTAwXX0sbS5hcHBsZS5yZ2I9ZnVuY3Rpb24ocyl7cmV0dXJuW3NbMF0vNjU1MzUqMjU1LHNbMV0vNjU1MzUqMjU1LHNbMl0vNjU1MzUqMjU1XX0sbS5yZ2IuYXBwbGU9ZnVuY3Rpb24ocyl7cmV0dXJuW3NbMF0vMjU1KjY1NTM1LHNbMV0vMjU1KjY1NTM1LHNbMl0vMjU1KjY1NTM1XX0sbS5ncmF5LnJnYj1mdW5jdGlvbihzKXtyZXR1cm5bc1swXS8xMDAqMjU1LHNbMF0vMTAwKjI1NSxzWzBdLzEwMCoyNTVdfSxtLmdyYXkuaHNsPWZ1bmN0aW9uKHMpe3JldHVyblswLDAsc1swXV19LG0uZ3JheS5oc3Y9bS5ncmF5LmhzbCxtLmdyYXkuaHdiPWZ1bmN0aW9uKHMpe3JldHVyblswLDEwMCxzWzBdXX0sbS5ncmF5LmNteWs9ZnVuY3Rpb24ocyl7cmV0dXJuWzAsMCwwLHNbMF1dfSxtLmdyYXkubGFiPWZ1bmN0aW9uKHMpe3JldHVybltzWzBdLDAsMF19LG0uZ3JheS5oZXg9ZnVuY3Rpb24ocyl7Y29uc3QgZT1NYXRoLnJvdW5kKHNbMF0vMTAwKjI1NSkmMjU1LGk9KChlPDwxNikrKGU8PDgpK2UpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO3JldHVybiIwMDAwMDAiLnN1YnN0cmluZyhpLmxlbmd0aCkraX0sbS5yZ2IuZ3JheT1mdW5jdGlvbihzKXtyZXR1cm5bKHNbMF0rc1sxXStzWzJdKS8zLzI1NSoxMDBdfTtjb25zdCBjdD1fdDtmdW5jdGlvbiB0cygpe2NvbnN0IHM9e30sZT1PYmplY3Qua2V5cyhjdCk7Zm9yKGxldCByPWUubGVuZ3RoLGk9MDtpPHI7aSsrKXNbZVtpXV09e2Rpc3RhbmNlOi0xLHBhcmVudDpudWxsfTtyZXR1cm4gc31mdW5jdGlvbiBlcyhzKXtjb25zdCBlPXRzKCkscj1bc107Zm9yKGVbc10uZGlzdGFuY2U9MDtyLmxlbmd0aDspe2NvbnN0IGk9ci5wb3AoKSxuPU9iamVjdC5rZXlzKGN0W2ldKTtmb3IobGV0IHQ9bi5sZW5ndGgsbD0wO2w8dDtsKyspe2NvbnN0IGM9bltsXSxmPWVbY107Zi5kaXN0YW5jZT09PS0xJiYoZi5kaXN0YW5jZT1lW2ldLmRpc3RhbmNlKzEsZi5wYXJlbnQ9aSxyLnVuc2hpZnQoYykpfX1yZXR1cm4gZX1mdW5jdGlvbiBzcyhzLGUpe3JldHVybiBmdW5jdGlvbihyKXtyZXR1cm4gZShzKHIpKX19ZnVuY3Rpb24gcnMocyxlKXtjb25zdCByPVtlW3NdLnBhcmVudCxzXTtsZXQgaT1jdFtlW3NdLnBhcmVudF1bc10sbj1lW3NdLnBhcmVudDtmb3IoO2Vbbl0ucGFyZW50OylyLnVuc2hpZnQoZVtuXS5wYXJlbnQpLGk9c3MoY3RbZVtuXS5wYXJlbnRdW25dLGkpLG49ZVtuXS5wYXJlbnQ7cmV0dXJuIGkuY29udmVyc2lvbj1yLGl9dmFyIGlzPWZ1bmN0aW9uKHMpe2NvbnN0IGU9ZXMocykscj17fSxpPU9iamVjdC5rZXlzKGUpO2ZvcihsZXQgbj1pLmxlbmd0aCx0PTA7dDxuO3QrKyl7Y29uc3QgbD1pW3RdO2VbbF0ucGFyZW50IT09bnVsbCYmKHJbbF09cnMobCxlKSl9cmV0dXJuIHJ9O2NvbnN0IEV0PV90LG5zPWlzLHR0PXt9LGFzPU9iamVjdC5rZXlzKEV0KTtmdW5jdGlvbiBvcyhzKXtjb25zdCBlPWZ1bmN0aW9uKC4uLnIpe2NvbnN0IGk9clswXTtyZXR1cm4gaT09bnVsbD9pOihpLmxlbmd0aD4xJiYocj1pKSxzKHIpKX07cmV0dXJuImNvbnZlcnNpb24iaW4gcyYmKGUuY29udmVyc2lvbj1zLmNvbnZlcnNpb24pLGV9ZnVuY3Rpb24gbHMocyl7Y29uc3QgZT1mdW5jdGlvbiguLi5yKXtjb25zdCBpPXJbMF07aWYoaT09bnVsbClyZXR1cm4gaTtpLmxlbmd0aD4xJiYocj1pKTtjb25zdCBuPXMocik7aWYodHlwZW9mIG49PSJvYmplY3QiKWZvcihsZXQgdD1uLmxlbmd0aCxsPTA7bDx0O2wrKyluW2xdPU1hdGgucm91bmQobltsXSk7cmV0dXJuIG59O3JldHVybiJjb252ZXJzaW9uImluIHMmJihlLmNvbnZlcnNpb249cy5jb252ZXJzaW9uKSxlfWFzLmZvckVhY2gocz0+e3R0W3NdPXt9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dFtzXSwiY2hhbm5lbHMiLHt2YWx1ZTpFdFtzXS5jaGFubmVsc30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dFtzXSwibGFiZWxzIix7dmFsdWU6RXRbc10ubGFiZWxzfSk7Y29uc3QgZT1ucyhzKTtPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGk9Pntjb25zdCBuPWVbaV07dHRbc11baV09bHMobiksdHRbc11baV0ucmF3PW9zKG4pfSl9KTt2YXIgaHM9dHQ7Y29uc3QgZXQ9SmUscT1ocyxIdD1bImtleXdvcmQiLCJncmF5IiwiaGV4Il0sRHQ9e307Zm9yKGNvbnN0IHMgb2YgT2JqZWN0LmtleXMocSkpRHRbWy4uLnFbc10ubGFiZWxzXS5zb3J0KCkuam9pbigiIildPXM7Y29uc3QgdXQ9e307ZnVuY3Rpb24geihzLGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHopKXJldHVybiBuZXcgeihzLGUpO2lmKGUmJmUgaW4gSHQmJihlPW51bGwpLGUmJiEoZSBpbiBxKSl0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gbW9kZWw6ICIrZSk7bGV0IHIsaTtpZihzPT1udWxsKXRoaXMubW9kZWw9InJnYiIsdGhpcy5jb2xvcj1bMCwwLDBdLHRoaXMudmFscGhhPTE7ZWxzZSBpZihzIGluc3RhbmNlb2Ygeil0aGlzLm1vZGVsPXMubW9kZWwsdGhpcy5jb2xvcj1bLi4ucy5jb2xvcl0sdGhpcy52YWxwaGE9cy52YWxwaGE7ZWxzZSBpZih0eXBlb2Ygcz09InN0cmluZyIpe2NvbnN0IG49ZXQuZ2V0KHMpO2lmKG49PT1udWxsKXRocm93IG5ldyBFcnJvcigiVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gc3RyaW5nOiAiK3MpO3RoaXMubW9kZWw9bi5tb2RlbCxpPXFbdGhpcy5tb2RlbF0uY2hhbm5lbHMsdGhpcy5jb2xvcj1uLnZhbHVlLnNsaWNlKDAsaSksdGhpcy52YWxwaGE9dHlwZW9mIG4udmFsdWVbaV09PSJudW1iZXIiP24udmFsdWVbaV06MX1lbHNlIGlmKHMubGVuZ3RoPjApe3RoaXMubW9kZWw9ZXx8InJnYiIsaT1xW3RoaXMubW9kZWxdLmNoYW5uZWxzO2NvbnN0IG49QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocywwLGkpO3RoaXMuY29sb3I9UHQobixpKSx0aGlzLnZhbHBoYT10eXBlb2Ygc1tpXT09Im51bWJlciI/c1tpXToxfWVsc2UgaWYodHlwZW9mIHM9PSJudW1iZXIiKXRoaXMubW9kZWw9InJnYiIsdGhpcy5jb2xvcj1bcz4+MTYmMjU1LHM+PjgmMjU1LHMmMjU1XSx0aGlzLnZhbHBoYT0xO2Vsc2V7dGhpcy52YWxwaGE9MTtjb25zdCBuPU9iamVjdC5rZXlzKHMpOyJhbHBoYSJpbiBzJiYobi5zcGxpY2Uobi5pbmRleE9mKCJhbHBoYSIpLDEpLHRoaXMudmFscGhhPXR5cGVvZiBzLmFscGhhPT0ibnVtYmVyIj9zLmFscGhhOjApO2NvbnN0IHQ9bi5zb3J0KCkuam9pbigiIik7aWYoISh0IGluIER0KSl0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIG9iamVjdDogIitKU09OLnN0cmluZ2lmeShzKSk7dGhpcy5tb2RlbD1EdFt0XTtjb25zdHtsYWJlbHM6bH09cVt0aGlzLm1vZGVsXSxjPVtdO2ZvcihyPTA7cjxsLmxlbmd0aDtyKyspYy5wdXNoKHNbbFtyXV0pO3RoaXMuY29sb3I9UHQoYyl9aWYodXRbdGhpcy5tb2RlbF0pZm9yKGk9cVt0aGlzLm1vZGVsXS5jaGFubmVscyxyPTA7cjxpO3IrKyl7Y29uc3Qgbj11dFt0aGlzLm1vZGVsXVtyXTtuJiYodGhpcy5jb2xvcltyXT1uKHRoaXMuY29sb3Jbcl0pKX10aGlzLnZhbHBoYT1NYXRoLm1heCgwLE1hdGgubWluKDEsdGhpcy52YWxwaGEpKSxPYmplY3QuZnJlZXplJiZPYmplY3QuZnJlZXplKHRoaXMpfXoucHJvdG90eXBlPXt0b1N0cmluZygpe3JldHVybiB0aGlzLnN0cmluZygpfSx0b0pTT04oKXtyZXR1cm4gdGhpc1t0aGlzLm1vZGVsXSgpfSxzdHJpbmcocyl7bGV0IGU9dGhpcy5tb2RlbCBpbiBldC50bz90aGlzOnRoaXMucmdiKCk7ZT1lLnJvdW5kKHR5cGVvZiBzPT0ibnVtYmVyIj9zOjEpO2NvbnN0IHI9ZS52YWxwaGE9PT0xP2UuY29sb3I6Wy4uLmUuY29sb3IsdGhpcy52YWxwaGFdO3JldHVybiBldC50b1tlLm1vZGVsXShyKX0scGVyY2VudFN0cmluZyhzKXtjb25zdCBlPXRoaXMucmdiKCkucm91bmQodHlwZW9mIHM9PSJudW1iZXIiP3M6MSkscj1lLnZhbHBoYT09PTE/ZS5jb2xvcjpbLi4uZS5jb2xvcix0aGlzLnZhbHBoYV07cmV0dXJuIGV0LnRvLnJnYi5wZXJjZW50KHIpfSxhcnJheSgpe3JldHVybiB0aGlzLnZhbHBoYT09PTE/Wy4uLnRoaXMuY29sb3JdOlsuLi50aGlzLmNvbG9yLHRoaXMudmFscGhhXX0sb2JqZWN0KCl7Y29uc3Qgcz17fSx7Y2hhbm5lbHM6ZX09cVt0aGlzLm1vZGVsXSx7bGFiZWxzOnJ9PXFbdGhpcy5tb2RlbF07Zm9yKGxldCBpPTA7aTxlO2krKylzW3JbaV1dPXRoaXMuY29sb3JbaV07cmV0dXJuIHRoaXMudmFscGhhIT09MSYmKHMuYWxwaGE9dGhpcy52YWxwaGEpLHN9LHVuaXRBcnJheSgpe2NvbnN0IHM9dGhpcy5yZ2IoKS5jb2xvcjtyZXR1cm4gc1swXS89MjU1LHNbMV0vPTI1NSxzWzJdLz0yNTUsdGhpcy52YWxwaGEhPT0xJiZzLnB1c2godGhpcy52YWxwaGEpLHN9LHVuaXRPYmplY3QoKXtjb25zdCBzPXRoaXMucmdiKCkub2JqZWN0KCk7cmV0dXJuIHMuci89MjU1LHMuZy89MjU1LHMuYi89MjU1LHRoaXMudmFscGhhIT09MSYmKHMuYWxwaGE9dGhpcy52YWxwaGEpLHN9LHJvdW5kKHMpe3JldHVybiBzPU1hdGgubWF4KHN8fDAsMCksbmV3IHooWy4uLnRoaXMuY29sb3IubWFwKHVzKHMpKSx0aGlzLnZhbHBoYV0sdGhpcy5tb2RlbCl9LGFscGhhKHMpe3JldHVybiBzIT09dm9pZCAwP25ldyB6KFsuLi50aGlzLmNvbG9yLE1hdGgubWF4KDAsTWF0aC5taW4oMSxzKSldLHRoaXMubW9kZWwpOnRoaXMudmFscGhhfSxyZWQ6RigicmdiIiwwLFIoMjU1KSksZ3JlZW46RigicmdiIiwxLFIoMjU1KSksYmx1ZTpGKCJyZ2IiLDIsUigyNTUpKSxodWU6RihbImhzbCIsImhzdiIsImhzbCIsImh3YiIsImhjZyJdLDAscz0+KHMlMzYwKzM2MCklMzYwKSxzYXR1cmF0aW9ubDpGKCJoc2wiLDEsUigxMDApKSxsaWdodG5lc3M6RigiaHNsIiwyLFIoMTAwKSksc2F0dXJhdGlvbnY6RigiaHN2IiwxLFIoMTAwKSksdmFsdWU6RigiaHN2IiwyLFIoMTAwKSksY2hyb21hOkYoImhjZyIsMSxSKDEwMCkpLGdyYXk6RigiaGNnIiwyLFIoMTAwKSksd2hpdGU6RigiaHdiIiwxLFIoMTAwKSksd2JsYWNrOkYoImh3YiIsMixSKDEwMCkpLGN5YW46RigiY215ayIsMCxSKDEwMCkpLG1hZ2VudGE6RigiY215ayIsMSxSKDEwMCkpLHllbGxvdzpGKCJjbXlrIiwyLFIoMTAwKSksYmxhY2s6RigiY215ayIsMyxSKDEwMCkpLHg6RigieHl6IiwwLFIoOTUuMDQ3KSkseTpGKCJ4eXoiLDEsUigxMDApKSx6OkYoInh5eiIsMixSKDEwOC44MzMpKSxsOkYoImxhYiIsMCxSKDEwMCkpLGE6RigibGFiIiwxKSxiOkYoImxhYiIsMiksa2V5d29yZChzKXtyZXR1cm4gcyE9PXZvaWQgMD9uZXcgeihzKTpxW3RoaXMubW9kZWxdLmtleXdvcmQodGhpcy5jb2xvcil9LGhleChzKXtyZXR1cm4gcyE9PXZvaWQgMD9uZXcgeihzKTpldC50by5oZXgodGhpcy5yZ2IoKS5yb3VuZCgpLmNvbG9yKX0saGV4YShzKXtpZihzIT09dm9pZCAwKXJldHVybiBuZXcgeihzKTtjb25zdCBlPXRoaXMucmdiKCkucm91bmQoKS5jb2xvcjtsZXQgcj1NYXRoLnJvdW5kKHRoaXMudmFscGhhKjI1NSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7cmV0dXJuIHIubGVuZ3RoPT09MSYmKHI9IjAiK3IpLGV0LnRvLmhleChlKStyfSxyZ2JOdW1iZXIoKXtjb25zdCBzPXRoaXMucmdiKCkuY29sb3I7cmV0dXJuKHNbMF0mMjU1KTw8MTZ8KHNbMV0mMjU1KTw8OHxzWzJdJjI1NX0sbHVtaW5vc2l0eSgpe2NvbnN0IHM9dGhpcy5yZ2IoKS5jb2xvcixlPVtdO2Zvcihjb25zdFtyLGldb2Ygcy5lbnRyaWVzKCkpe2NvbnN0IG49aS8yNTU7ZVtyXT1uPD0uMDQwNDU/bi8xMi45MjooKG4rLjA1NSkvMS4wNTUpKioyLjR9cmV0dXJuIC4yMTI2KmVbMF0rLjcxNTIqZVsxXSsuMDcyMiplWzJdfSxjb250cmFzdChzKXtjb25zdCBlPXRoaXMubHVtaW5vc2l0eSgpLHI9cy5sdW1pbm9zaXR5KCk7cmV0dXJuIGU+cj8oZSsuMDUpLyhyKy4wNSk6KHIrLjA1KS8oZSsuMDUpfSxsZXZlbChzKXtjb25zdCBlPXRoaXMuY29udHJhc3Qocyk7cmV0dXJuIGU+PTc/IkFBQSI6ZT49NC41PyJBQSI6IiJ9LGlzRGFyaygpe2NvbnN0IHM9dGhpcy5yZ2IoKS5jb2xvcjtyZXR1cm4oc1swXSoyMTI2K3NbMV0qNzE1MitzWzJdKjcyMikvMWU0PDEyOH0saXNMaWdodCgpe3JldHVybiF0aGlzLmlzRGFyaygpfSxuZWdhdGUoKXtjb25zdCBzPXRoaXMucmdiKCk7Zm9yKGxldCBlPTA7ZTwzO2UrKylzLmNvbG9yW2VdPTI1NS1zLmNvbG9yW2VdO3JldHVybiBzfSxsaWdodGVuKHMpe2NvbnN0IGU9dGhpcy5oc2woKTtyZXR1cm4gZS5jb2xvclsyXSs9ZS5jb2xvclsyXSpzLGV9LGRhcmtlbihzKXtjb25zdCBlPXRoaXMuaHNsKCk7cmV0dXJuIGUuY29sb3JbMl0tPWUuY29sb3JbMl0qcyxlfSxzYXR1cmF0ZShzKXtjb25zdCBlPXRoaXMuaHNsKCk7cmV0dXJuIGUuY29sb3JbMV0rPWUuY29sb3JbMV0qcyxlfSxkZXNhdHVyYXRlKHMpe2NvbnN0IGU9dGhpcy5oc2woKTtyZXR1cm4gZS5jb2xvclsxXS09ZS5jb2xvclsxXSpzLGV9LHdoaXRlbihzKXtjb25zdCBlPXRoaXMuaHdiKCk7cmV0dXJuIGUuY29sb3JbMV0rPWUuY29sb3JbMV0qcyxlfSxibGFja2VuKHMpe2NvbnN0IGU9dGhpcy5od2IoKTtyZXR1cm4gZS5jb2xvclsyXSs9ZS5jb2xvclsyXSpzLGV9LGdyYXlzY2FsZSgpe2NvbnN0IHM9dGhpcy5yZ2IoKS5jb2xvcixlPXNbMF0qLjMrc1sxXSouNTkrc1syXSouMTE7cmV0dXJuIHoucmdiKGUsZSxlKX0sZmFkZShzKXtyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYS10aGlzLnZhbHBoYSpzKX0sb3BhcXVlcihzKXtyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSt0aGlzLnZhbHBoYSpzKX0scm90YXRlKHMpe2NvbnN0IGU9dGhpcy5oc2woKTtsZXQgcj1lLmNvbG9yWzBdO3JldHVybiByPShyK3MpJTM2MCxyPXI8MD8zNjArcjpyLGUuY29sb3JbMF09cixlfSxtaXgocyxlKXtpZighc3x8IXMucmdiKXRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gIm1peCIgd2FzIG5vdCBhIENvbG9yIGluc3RhbmNlLCBidXQgcmF0aGVyIGFuIGluc3RhbmNlIG9mICcrdHlwZW9mIHMpO2NvbnN0IHI9cy5yZ2IoKSxpPXRoaXMucmdiKCksbj1lPT09dm9pZCAwPy41OmUsdD0yKm4tMSxsPXIuYWxwaGEoKS1pLmFscGhhKCksYz0oKHQqbD09PS0xP3Q6KHQrbCkvKDErdCpsKSkrMSkvMixmPTEtYztyZXR1cm4gei5yZ2IoYypyLnJlZCgpK2YqaS5yZWQoKSxjKnIuZ3JlZW4oKStmKmkuZ3JlZW4oKSxjKnIuYmx1ZSgpK2YqaS5ibHVlKCksci5hbHBoYSgpKm4raS5hbHBoYSgpKigxLW4pKX19O2Zvcihjb25zdCBzIG9mIE9iamVjdC5rZXlzKHEpKXtpZihIdC5pbmNsdWRlcyhzKSljb250aW51ZTtjb25zdHtjaGFubmVsczplfT1xW3NdO3oucHJvdG90eXBlW3NdPWZ1bmN0aW9uKC4uLnIpe3JldHVybiB0aGlzLm1vZGVsPT09cz9uZXcgeih0aGlzKTpyLmxlbmd0aD4wP25ldyB6KHIscyk6bmV3IHooWy4uLmZzKHFbdGhpcy5tb2RlbF1bc10ucmF3KHRoaXMuY29sb3IpKSx0aGlzLnZhbHBoYV0scyl9LHpbc109ZnVuY3Rpb24oLi4ucil7bGV0IGk9clswXTtyZXR1cm4gdHlwZW9mIGk9PSJudW1iZXIiJiYoaT1QdChyLGUpKSxuZXcgeihpLHMpfX1mdW5jdGlvbiBjcyhzLGUpe3JldHVybiBOdW1iZXIocy50b0ZpeGVkKGUpKX1mdW5jdGlvbiB1cyhzKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGNzKGUscyl9fWZ1bmN0aW9uIEYocyxlLHIpe3M9QXJyYXkuaXNBcnJheShzKT9zOltzXTtmb3IoY29uc3QgaSBvZiBzKSh1dFtpXXx8KHV0W2ldPVtdKSlbZV09cjtyZXR1cm4gcz1zWzBdLGZ1bmN0aW9uKGkpe2xldCBuO3JldHVybiBpIT09dm9pZCAwPyhyJiYoaT1yKGkpKSxuPXRoaXNbc10oKSxuLmNvbG9yW2VdPWksbik6KG49dGhpc1tzXSgpLmNvbG9yW2VdLHImJihuPXIobikpLG4pfX1mdW5jdGlvbiBSKHMpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5tYXgoMCxNYXRoLm1pbihzLGUpKX19ZnVuY3Rpb24gZnMocyl7cmV0dXJuIEFycmF5LmlzQXJyYXkocyk/czpbc119ZnVuY3Rpb24gUHQocyxlKXtmb3IobGV0IHI9MDtyPGU7cisrKXR5cGVvZiBzW3JdIT0ibnVtYmVyIiYmKHNbcl09MCk7cmV0dXJuIHN9dmFyIGdzPXosc3Q9R2UoZ3MpO2NvbnN0IEd0PXN0KCIjY2NjY2NjIiksVnQ9c3QoIiMwMGZmMDAiKSxXdD1zdCgiI2ZmZmYwMCIpLHBzPXN0KCIjMDA4ODg4IiksVz1zdCgiI2ZmMDAwMCIpLGt0PXN0KCIjZjAwMDAwIik7Y2xhc3MgZHN7Y29uc3RydWN0b3IoZSxyLGksbix0KXt0aGlzLnhTdGFydE1tPWUsdGhpcy55U3RhcnRNbT1yLHRoaXMueERlbHRhTW09aSx0aGlzLnlEZWx0YU1tPW4sdGhpcy5jdXRBcmVhTW1TcT10fXRvU3RyaW5nKCl7cmV0dXJuYCR7dGhpcy54RGVsdGFNbX0sJHt0aGlzLnlEZWx0YU1tfToke3RoaXMuY3V0QXJlYU1tU3F9YH10b0NvbnN0cnVjdG9yU3RyaW5nKCl7cmV0dXJuYG5ldyBNb3ZlKCR7dGhpcy54U3RhcnRNbX0sICR7dGhpcy55U3RhcnRNbX0sICR7dGhpcy54RGVsdGFNbX0sICR7dGhpcy55RGVsdGFNbX0sICR7dGhpcy5jdXRBcmVhTW1TcX0pYH1pc0VtcHR5KCl7cmV0dXJuIXRoaXMueERlbHRhTW0mJiF0aGlzLnlEZWx0YU1tfWlzQmFzaWMoKXtyZXR1cm4gTWF0aC5hYnModGhpcy54RGVsdGFNbSk8PS4wMSYmTWF0aC5hYnModGhpcy55RGVsdGFNbSk8PS4wMX10b0xhdGhlQ29kZSgpe2lmKCF0aGlzLnhEZWx0YU1tKXJldHVybiIiO2NvbnN0IGU9cj0+TWF0aC5hYnMocikudG9GaXhlZCgzKTtyZXR1cm4gdGhpcy55RGVsdGFNbT9gTCR7ZSh0aGlzLnhEZWx0YU1tKX0gUlMke2UodGhpcy55U3RhcnRNbSl9IFJFJHtlKHRoaXMueVN0YXJ0TW0rdGhpcy55RGVsdGFNbSl9YDpgTCR7ZSh0aGlzLnhEZWx0YU1tKX0gUiR7ZSh0aGlzLnlTdGFydE1tKX1gfX1jbGFzcyBLdHtjb25zdHJ1Y3RvcihlLHIpe3RoaXMueD1lLHRoaXMueT1yfXRvU3RyaW5nKCl7cmV0dXJuYCR7dGhpcy54fSwke3RoaXMueX1gfX1jbGFzcyBMe2NvbnN0cnVjdG9yKGUscixpLG4sdCxsKXt0aGlzLnhTdGFydD1lLHRoaXMueVN0YXJ0PXIsdGhpcy54RGVsdGE9aSx0aGlzLnlEZWx0YT1uLHRoaXMuY3V0QXJlYT10LHRoaXMuY3V0UGl4ZWxzPWx9c3RhdGljIHdpdGhvdXRDdXQoZSxyLGksbil7cmV0dXJuIG5ldyBMKGUscixpLG4sMCxbXSl9dG9TdHJpbmcoKXtyZXR1cm5gJHt0aGlzLnhEZWx0YX0sJHt0aGlzLnlEZWx0YX06JHt0aGlzLmN1dEFyZWF9YH10b0NvbnN0cnVjdG9yU3RyaW5nKCl7cmV0dXJuYG5ldyBQaXhlbE1vdmUoJHt0aGlzLnhTdGFydH0sICR7dGhpcy55U3RhcnR9LCAke3RoaXMueERlbHRhfSwgJHt0aGlzLnlEZWx0YX0sICR7dGhpcy5jdXRBcmVhfSwgW10pYH10b01vdmUoZSl7cmV0dXJuIG5ldyBkcygtdGhpcy54U3RhcnQvZSwtdGhpcy55U3RhcnQvZSwtdGhpcy54RGVsdGEvZSwtdGhpcy55RGVsdGEvZSx0aGlzLmN1dEFyZWEvZS9lKX1pc0VtcHR5KCl7cmV0dXJuIXRoaXMueERlbHRhJiYhdGhpcy55RGVsdGF9aXNCYXNpYygpe3JldHVybih0aGlzLnhEZWx0YT09PTF8fHRoaXMueERlbHRhPT09MHx8dGhpcy54RGVsdGE9PT0tMSkmJih0aGlzLnlEZWx0YT09PTF8fHRoaXMueURlbHRhPT09MHx8dGhpcy55RGVsdGE9PT0tMSl9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLnhEZWx0YSp0aGlzLnhEZWx0YSt0aGlzLnlEZWx0YSp0aGlzLnlEZWx0YSl9aXNIb3Jpem9udGFsT3JWZXJ0aWNhbCgpe3JldHVybiB0aGlzLnhEZWx0YSp0aGlzLnlEZWx0YT09PTAmJiF0aGlzLmlzRW1wdHkoKX1nZXRBbmdsZURlZ3JlZXMoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO2xldCBlPU1hdGguYXRhbjIodGhpcy55RGVsdGEsdGhpcy54RGVsdGEpKjE4MC9NYXRoLlBJO3JldHVybiBlPDAmJihlKz0zNjApLGV9Z2V0QW5nbGVUb0RlZ3JlZXMoZSl7bGV0IHI9TWF0aC5hYnModGhpcy5nZXRBbmdsZURlZ3JlZXMoKS1lLmdldEFuZ2xlRGVncmVlcygpKTtyZXR1cm4gMzYwLXI8cj8zNjAtcjpyfW1lcmdlKGUpe2lmKHRoaXMueFN0YXJ0K3RoaXMueERlbHRhIT09ZS54U3RhcnR8fHRoaXMueVN0YXJ0K3RoaXMueURlbHRhIT09ZS55U3RhcnQpdGhyb3cgbmV3IEVycm9yKGBtZXJnZSBlcnJvcjogJHt0aGlzfSArICR7ZX1gKTtyZXR1cm4gbmV3IEwodGhpcy54U3RhcnQsdGhpcy55U3RhcnQsdGhpcy54RGVsdGErZS54RGVsdGEsdGhpcy55RGVsdGErZS55RGVsdGEsdGhpcy5jdXRBcmVhK2UuY3V0QXJlYSx0aGlzLmN1dFBpeGVscy5jb25jYXQoZS5jdXRQaXhlbHMpKX1nZXRDdXQoKXtpZighdGhpcy5jdXRBcmVhKXJldHVybnt3aWR0aDowLGhlaWdodDowfTtsZXQgZT0xLzAscj0tMS8wLGk9MS8wLG49LTEvMDtmb3IobGV0IHQgb2YgdGhpcy5jdXRQaXhlbHMpdC54PGUmJihlPXQueCksdC54PnImJihyPXQueCksdC55PGkmJihpPXQueSksdC55Pm4mJihuPXQueSk7cmV0dXJue3dpZHRoOnItZSsxLGhlaWdodDpuLWkrMX19fWNvbnN0IGp0PTI7ZnVuY3Rpb24gbXMocyl7Y29uc3QgZT1zLmdldENvbnRleHQoIjJkIikuZ2V0SW1hZ2VEYXRhKDAsMCxzLndpZHRoLHMuaGVpZ2h0KS5kYXRhLHI9bmV3IFNldCxpPVtdLG49KHQsbCk9Pntjb25zdCBjPW5ldyBLdCh0LGwpO3IuaGFzKGMudG9TdHJpbmcoKSl8fChpLnB1c2goYyksci5hZGQoYy50b1N0cmluZygpKSl9O2ZvcihsZXQgdD0wO3Q8cy5oZWlnaHQ7dCsrKXtsZXQgbD0wO2ZvcihsZXQgYz0wO2M8cy53aWR0aDtjKyspe2NvbnN0IGY9KHQqcy53aWR0aCtjKSo0O2lmKE1hdGguYWJzKGVbZl0tVy5yZWQoKSk8PTEmJk1hdGguYWJzKGVbZisxXS1XLmdyZWVuKCkpPD0xJiZNYXRoLmFicyhlW2YrMl0tVy5ibHVlKCkpPD0xJiZlW2YrM10+MjUwJiYobihjLHQpLCsrbD5qdCkpYnJlYWt9fWZvcihsZXQgdD0wO3Q8cy53aWR0aDt0Kyspe2xldCBsPTA7Zm9yKGxldCBjPTA7YzxzLmhlaWdodDtjKyspe2NvbnN0IGY9KGMqcy53aWR0aCt0KSo0O2lmKE1hdGguYWJzKGVbZl0tVy5yZWQoKSk8PTEmJk1hdGguYWJzKGVbZisxXS1XLmdyZWVuKCkpPD0xJiZNYXRoLmFicyhlW2YrMl0tVy5ibHVlKCkpPD0xJiZlW2YrM10+MjUwJiYobih0LGMpLCsrbD5qdCkpYnJlYWt9fXJldHVybiBpfWNvbnN0IHlzPS4wNSx3cz0uOTtmdW5jdGlvbiBicyhzLGUscil7Y29uc3Qgbj1zLm1lcmdlKGUpLmdldEFuZ2xlVG9EZWdyZWVzKHMpO3JldHVybiBuPT09MTgwPyExOk1hdGguc2luKG4vMTgwKk1hdGguUEkpKnMubGVuZ3RoKCk8PXJ9ZnVuY3Rpb24gWnQocyxlKXtjb25zdCByPVtdO2xldCBpPTA7Zm9yKDtpPHMubGVuZ3RoOyl7bGV0IG49c1tpXTtpZihpKzE8cy5sZW5ndGgmJmJzKHNbaV0sc1tpKzFdLGUpKXtyLnB1c2goc1tpXS5tZXJnZShzW2krMV0pKSxpKz0yO2NvbnRpbnVlfXIucHVzaChuKSxpKyt9cmV0dXJuIHIubGVuZ3RoPHMubGVuZ3RoP1p0KHIsZSk6cn1mdW5jdGlvbiBKdChzLGUpe2NvbnN0IHI9W107bGV0IGk9MDtmb3IoO2k8cy5sZW5ndGg7KXtsZXQgbj1zW2ldO2lmKG4uaXNFbXB0eSgpKXtpKys7Y29udGludWV9aWYoIW4uY3V0QXJlYSl7Y29uc3QgbD12cyhzLGkpO2lmKGwubGVuZ3RoPjEmJmwubW92ZXMubGVuZ3RoPGwubGVuZ3RoKXtyLnB1c2goLi4ubC5tb3ZlcyksaSs9bC5sZW5ndGg7Y29udGludWV9fWNvbnN0IHQ9TXMocyxpKTtpZih0Lmxlbmd0aD4xKXtyLnB1c2godC5tb3ZlKSxpKz10Lmxlbmd0aDtjb250aW51ZX1pZihpKzE8cy5sZW5ndGgmJnNbaV0uaXNCYXNpYygpJiZzW2krMV0uaXNIb3Jpem9udGFsT3JWZXJ0aWNhbCgpKXtsZXQgbD0xO2Zvcig7aSsxK2wqMjxzLmxlbmd0aDspe2NvbnN0IGM9aStsKjI7aWYoc1tjXS5pc0Jhc2ljKCkmJnNbYysxXS5pc0hvcml6b250YWxPclZlcnRpY2FsKCkmJnNbYy0yXS5tZXJnZShzW2MtMV0pLmdldEFuZ2xlVG9EZWdyZWVzKHNbY10ubWVyZ2Uoc1tjKzFdKSk8eXMpbCsrO2Vsc2UgYnJlYWt9aWYobD4xKXtyLnB1c2goJHMocyxpLDIqbCkpLGkrPTIqbDtjb250aW51ZX19ci5wdXNoKG4pLGkrK31yZXR1cm4gci5sZW5ndGg8cy5sZW5ndGg/SnQocik6WnQocix3cyl9ZnVuY3Rpb24gdnMocyxlKXtpZihzW2VdLmN1dEFyZWEpdGhyb3cgbmV3IEVycm9yKCJleHBlY3RpbmcgYSB0cmF2ZWwgbW92ZSIpO2xldCByPWU7Zm9yKDtyPHMubGVuZ3RoLTEmJiFzW3IrMV0uY3V0QXJlYTspcisrO3JldHVybnttb3Zlczp4cyhzLnNsaWNlKGUscisxKSksbGVuZ3RoOnItZSsxfX1mdW5jdGlvbiB4cyhzKXtjb25zdCBlPVtdLHI9c1swXSxpPU1hdGgubWF4LmFwcGx5KG51bGwscy5tYXAoZj0+Zi55U3RhcnQrZi55RGVsdGEpKSxuPXMuYXQoLTEpLHQ9bi54U3RhcnQrbi54RGVsdGEsbD1uLnlTdGFydCtuLnlEZWx0YTtsZXQgYz1yLnlTdGFydDtyZXR1cm4gdCE9ci54U3RhcnQmJihyLnlTdGFydCE9PWkmJihlLnB1c2goTC53aXRob3V0Q3V0KHIueFN0YXJ0LHIueVN0YXJ0LDAsaS1yLnlTdGFydCkpLGM9aSksZS5wdXNoKEwud2l0aG91dEN1dChyLnhTdGFydCxpLHQtci54U3RhcnQsMCkpKSxsIT1jJiZlLnB1c2goTC53aXRob3V0Q3V0KHQsYywwLGwtYykpLGV9ZnVuY3Rpb24gTXMocyxlKXtsZXQgcj1zW2VdLGk9MTtmb3IoO2U8cy5sZW5ndGgtMTspe2NvbnN0IG49c1tlKzFdO2lmKCFuLmdldEFuZ2xlVG9EZWdyZWVzKHIpKXI9ci5tZXJnZShuKSxpKyssZSsrO2Vsc2UgYnJlYWt9cmV0dXJue21vdmU6cixsZW5ndGg6aX19ZnVuY3Rpb24gJHMocyxlLHIpe2xldCBpPXNbZV07Zm9yKGxldCBuPTE7bjxyO24rKylpPWkubWVyZ2Uoc1tlK25dKTtyZXR1cm4gaX1jbGFzcyBDc3tjb25zdHJ1Y3RvcihlLHIpe3RoaXMubGF0aGVDb2RlPWUsdGhpcy5weFBlck1tPXJ9Y3JlYXRlVG9vbCgpe2NvbnN0IGU9dGhpcy5sYXRoZUNvZGUuZ2V0VG9vbCgpO2lmKGUudHlwZT09PSJSRUNUIil7Y29uc3Qgcj1lLndpZHRoTW0qdGhpcy5weFBlck1tLGk9ZS5oZWlnaHRNbSp0aGlzLnB4UGVyTW0sbj1lLmNvcm5lclJhZGl1c01tKnRoaXMucHhQZXJNbSx0PW5ldyBPZmZzY3JlZW5DYW52YXMocixpKSxsPXQuZ2V0Q29udGV4dCgiMmQiKTtyZXR1cm4gbC5zdHJva2VTdHlsZT1XLmhleCgpLGwuZmlsbFN0eWxlPWt0LmhleCgpLGwubGluZVdpZHRoPTIsbC5iZWdpblBhdGgoKSxsLm1vdmVUbyhuLDApLGwubGluZVRvKHItbiwwKSxsLmFyY1RvKHIsMCxyLG4sbiksbC5saW5lVG8ocixpLW4pLGwuYXJjVG8ocixpLHItbixpLG4pLGwubGluZVRvKG4saSksbC5hcmNUbygwLGksMCxpLW4sbiksbC5saW5lVG8oMCxuKSxsLmFyY1RvKDAsMCxuLDAsbiksbC5jbG9zZVBhdGgoKSxsLmZpbGwoKSxsLnN0cm9rZSgpLHR9aWYoZS50eXBlPT09IlJPVU5EIil7Y29uc3Qgcj1lLmNvcm5lclJhZGl1c01tKjIqdGhpcy5weFBlck1tLGk9ZS5jb3JuZXJSYWRpdXNNbSoyKnRoaXMucHhQZXJNbSxuPWUuY29ybmVyUmFkaXVzTW0qdGhpcy5weFBlck1tLHQ9bmV3IE9mZnNjcmVlbkNhbnZhcyhyLGkpLGw9dC5nZXRDb250ZXh0KCIyZCIpO3JldHVybiBsLnN0cm9rZVN0eWxlPVcuaGV4KCksbC5maWxsU3R5bGU9a3QuaGV4KCksbC5saW5lV2lkdGg9MixsLmJlZ2luUGF0aCgpLGwubW92ZVRvKG4sMCksbC5hcmNUbyhyLDAscixuLG4pLGwuYXJjVG8ocixpLHItbixpLG4pLGwuYXJjVG8oMCxpLDAsaS1uLG4pLGwuYXJjVG8oMCwwLG4sMCxuKSxsLmNsb3NlUGF0aCgpLGwuZmlsbCgpLGwuc3Ryb2tlKCksdH1pZihlLnR5cGU9PT0iQU5HIil7Y29uc3Qgcj1lLndpZHRoTW0saT0oZS5jb3JuZXJSYWRpdXNNbStyKSoyKnRoaXMucHhQZXJNbSxuPWUuY29ybmVyUmFkaXVzTW0qdGhpcy5weFBlck1tLHQ9bmV3IE9mZnNjcmVlbkNhbnZhcyhpLGkpLGw9dC5nZXRDb250ZXh0KCIyZCIpO2wuc3Ryb2tlU3R5bGU9Vy5oZXgoKSxsLmZpbGxTdHlsZT1rdC5oZXgoKSxsLmxpbmVXaWR0aD0yLGwuYmVnaW5QYXRoKCksbC5hcmMoaS8yLGkvMixuLDAsMipNYXRoLlBJKSxsLmZpbGwoKSxsLnN0cm9rZSgpLGwuY2xvc2VQYXRoKCk7Y29uc3QgYz1lLm5vc2VBbmdsZURlZz8/MCxmPWUuYW5nbGVEZWc/PzAsdz1mdChuLDE4MC1jLzIrZik7dy54Kz1pLzIsdy55Kz1pLzI7Y29uc3QgUz1mdChyKnRoaXMucHhQZXJNbSwyNzAtYy8yK2YpO1MueCs9dy54LFMueSs9dy55O2NvbnN0IGs9ZnQobixjLzIrZik7ay54Kz1pLzIsay55Kz1pLzI7Y29uc3Qgdj1mdChyKnRoaXMucHhQZXJNbSwyNzArYy8yK2YpO3JldHVybiB2LngrPWsueCx2LnkrPWsueSxsLmJlZ2luUGF0aCgpLGwubW92ZVRvKHcueCx3LnkpLGwubGluZVRvKFMueCxTLnkpLGwubGluZVRvKHYueCx2LnkpLGwubGluZVRvKGsueCxrLnkpLGwubGluZVRvKHcueCx3LnkpLGwuZmlsbCgpLGwuc3Ryb2tlKCksbC5jbG9zZVBhdGgoKSxTcyh0KX10aHJvdyBuZXcgRXJyb3IoYHRvb2wgb2YgdHlwZSAke2UudHlwZX0gbm90IGltcGxlbWVudGVkYCl9Y3JlYXRlQ2FudmFzKCl7Y29uc3QgZT10aGlzLmxhdGhlQ29kZS5nZXRTdG9jaygpO2lmKCFlKXRocm93IG5ldyBFcnJvcigiRXJyb3I6IHNwZWNpZnkgc3RvY2siKTtpZihlLmRpYW1ldGVyPT0wKXRocm93IG5ldyBFcnJvcigiRXJyb3I6IHN0b2NrIGRpYW1ldGVyIGlzIDAiKTtpZihlLmxlbmd0aD09MCl0aHJvdyBuZXcgRXJyb3IoIkVycm9yOiBzdG9jayBsZW5ndGggaXMgMCIpO2NvbnN0IHI9dGhpcy5sYXRoZUNvZGUuZ2V0SW5zaWRlU2VnbWVudHMoKSxpPXRoaXMubGF0aGVDb2RlLmdldE91dHNpZGVTZWdtZW50cygpO2lmKHIubGVuZ3RoJiZpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoIkVycm9yOiBpbnNpZGUgYW5kIG91dHNpZGUgbm90IHN1cHBvcnRlZCB5ZXQiKTtpZighci5sZW5ndGgmJiFpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoIkVycm9yOiBubyBzZWdtZW50cyIpO2NvbnN0IG49bmV3IE9mZnNjcmVlbkNhbnZhcyhlLmxlbmd0aCp0aGlzLnB4UGVyTW0sZS5kaWFtZXRlci8yKnRoaXMucHhQZXJNbSksdD1uLmdldENvbnRleHQoIjJkIiksbD1yLmxlbmd0aD9yOmksYz10aGlzLmxhdGhlQ29kZS5nZXREZXB0aCgpLmZpbmlzaE1tKihyLmxlbmd0aD8tMToxKTtyZXR1cm4gdGhpcy5maWxsU2VnbWVudHModCxlLmdldFNlZ21lbnRzKCksVnQuaGV4KCkpLGMhPT0wJiZ0aGlzLmZpbGxTZWdtZW50cyh0LGwubWFwKGY9PmYub2Zmc2V0QnkoYywwKSksV3QuaGV4KCkpLHRoaXMuZmlsbFNlZ21lbnRzKHQsbCxHdC5oZXgoKSksbn1maWxsU2VnbWVudHMoZSxyLGkpe2UuYmVnaW5QYXRoKCksZS5tb3ZlVG8odGhpcy56VG9YKHJbMF0uc3RhcnQueiksdGhpcy54VG9ZKHJbMF0uc3RhcnQueCkpO2ZvcihsZXQgbiBvZiByKXtjb25zdCB0PShuLnR5cGU9PT0iQ09OViJ8fG4udHlwZT09PSJDT05DIikmJm4uc3RhcnQueD09PW4uZW5kLng7aWYobi50eXBlPT09IkxJTkUifHx0KWUubGluZVRvKHRoaXMuelRvWChuLmVuZC56KSx0aGlzLnhUb1kobi5lbmQueCkpO2Vsc2UgaWYobi50eXBlPT09IkNPTlYifHxuLnR5cGU9PT0iQ09OQyIpdGhpcy5lbGxpcHNlKGUsbixuLnR5cGU9PT0iQ09OViIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gcGFpbnQgc2VnbWVudCBvZiB0eXBlICIrbi50eXBlKX1lLmNsb3NlUGF0aCgpLGUuZmlsbFN0eWxlPWksZS5maWxsKCl9ZWxsaXBzZShlLHIsaSl7Y29uc3Qgbj1yLmVuZC54PnIuc3RhcnQueCx0PW49PT1pP25ldyBEKHIuc3RhcnQueCxyLmVuZC56KTpuZXcgRChyLmVuZC54LHIuc3RhcnQueik7bGV0IGw9MCxjPTAsZj0hMTtuJiZpPyhsPTAsYz1NYXRoLlBJLzIpOm4mJiFpPyhsPU1hdGguUEkqMy8yLGM9TWF0aC5QSSxmPSEwKTohbiYmaT8obD1NYXRoLlBJLzIsYz1NYXRoLlBJKTohbiYmIWkmJihsPU1hdGguUEkqMixjPU1hdGguUEkqMy8yLGY9ITApLGUuZWxsaXBzZSh0aGlzLnpUb1godC56KSx0aGlzLnhUb1kodC54KSxNYXRoLmFicyhyLmVuZC56LXIuc3RhcnQueikqdGhpcy5weFBlck1tLE1hdGguYWJzKHIuZW5kLngtci5zdGFydC54KSp0aGlzLnB4UGVyTW0sMCxsLGMsZil9eFRvWShlKXtyZXR1cm4gZSp0aGlzLnB4UGVyTW19elRvWChlKXtyZXR1cm4gdGhpcy5sYXRoZUNvZGUuZ2V0U3RvY2soKS5sZW5ndGgqdGhpcy5weFBlck1tLWUqdGhpcy5weFBlck1tfX1mdW5jdGlvbiBTcyhzKXtjb25zdCBlPXMuZ2V0Q29udGV4dCgiMmQiKS5nZXRJbWFnZURhdGEoMCwwLHMud2lkdGgscy5oZWlnaHQpLHtkYXRhOnIsd2lkdGg6aSxoZWlnaHQ6bn09ZTtsZXQgdD1pLGw9bixjPTAsZj0wO2ZvcihsZXQgdj0wO3Y8ci5sZW5ndGg7dis9NCl7Y29uc3QgQz12LzQlaSxPPU1hdGguZmxvb3Iodi80L2kpO3JbdiszXT4wJiYodD1NYXRoLm1pbih0LEMpLGw9TWF0aC5taW4obCxPKSxjPU1hdGgubWF4KGMsQyksZj1NYXRoLm1heChmLE8pKX1jb25zdCB3PWMtdCsxLFM9Zi1sKzEsaz1uZXcgT2Zmc2NyZWVuQ2FudmFzKHcsUyk7cmV0dXJuIGsuZ2V0Q29udGV4dCgiMmQiKS5kcmF3SW1hZ2Uocyx0LGwsdyxTLDAsMCx3LFMpLGt9ZnVuY3Rpb24gZnQocyxlKXtjb25zdCByPWUqTWF0aC5QSS8xODA7cmV0dXJue3g6cypNYXRoLmNvcyhyKSx5Oi1zKk1hdGguc2luKHIpfX1jb25zdCBFcz1wcy5yZ2JOdW1iZXIoKSxEcz1WdC5yZ2JOdW1iZXIoKSxQcz1HdC5yZ2JOdW1iZXIoKSxRdD1XdC5yZ2JOdW1iZXIoKTtjbGFzcyBndHtjb25zdHJ1Y3RvcihlLHIpe3RoaXMueD1lLHRoaXMuZmluaXNoQWZ0ZXI9cn19Y2xhc3Mga3N7Y29uc3RydWN0b3IoZSxyKXtUKHRoaXMsInBhaW50ZXIiKTtUKHRoaXMsImNhbnZhcyIpO1QodGhpcywiY2FudmFzQ3R4Iik7VCh0aGlzLCJ0b29sIik7VCh0aGlzLCJ0b29sQ3V0dGluZ0VkZ2VzIik7VCh0aGlzLCJ0b29sT3ZlcnNob290WCIpO1QodGhpcywidG9vbE92ZXJzaG9vdFkiKTtUKHRoaXMsInRvb2xYIik7VCh0aGlzLCJ0b29sWSIpO1QodGhpcywibW9kZSIpO1QodGhpcywicGFzc2VzIik7VCh0aGlzLCJwcmV2aW91c0ZpbmlzaFBhc3MiLG51bGwpO1QodGhpcywibW92ZXMiLFtdKTtUKHRoaXMsInBhcnRCaXRtYXAiLFtdKTtUKHRoaXMsInVwQWxsb3dlZCIsITApO1QodGhpcywiaXNGaW5pc2hQYXNzIiwhMSk7dmFyIGwsYzt0aGlzLmxhdGhlQ29kZT1lLHRoaXMucHhQZXJNbT1yLHRoaXMucGFpbnRlcj1uZXcgQ3MoZSxyKSx0aGlzLmNhbnZhcz10aGlzLnBhaW50ZXIuY3JlYXRlQ2FudmFzKCksdGhpcy5jYW52YXNDdHg9dGhpcy5jYW52YXMuZ2V0Q29udGV4dCgiMmQiKSx0aGlzLnRvb2w9dGhpcy5wYWludGVyLmNyZWF0ZVRvb2woKSx0aGlzLnRvb2xDdXR0aW5nRWRnZXM9bXModGhpcy50b29sKSx0aGlzLnRvb2xPdmVyc2hvb3RYPSgobD10aGlzLnRvb2xDdXR0aW5nRWRnZXMuZmlsdGVyKGY9PmYueT09PTApWzBdKT09bnVsbD92b2lkIDA6bC54KXx8MCx0aGlzLnRvb2xPdmVyc2hvb3RZPSgoYz10aGlzLnRvb2xDdXR0aW5nRWRnZXMuZmlsdGVyKGY9PmYueD09PTApWzBdKT09bnVsbD92b2lkIDA6Yy55KXx8MCx0aGlzLnRvb2xYPXRoaXMuY2FudmFzLndpZHRoLHRoaXMudG9vbFk9dGhpcy5jYW52YXMuaGVpZ2h0LHRoaXMubW9kZT10aGlzLmxhdGhlQ29kZS5nZXRNb2RlKCksdGhpcy5wYXJ0Qml0bWFwPXRoaXMuY3JlYXRlUGFydEJpdG1hcCgpO2NvbnN0IGk9dGhpcy5sYXRoZUNvZGUuZ2V0Q3V0b2ZmU3RhcnRzKCkubWFwKGY9PnRoaXMuY2FudmFzLndpZHRoLWYqdGhpcy5weFBlck1tLXRoaXMudG9vbC53aWR0aCsxKTt0aGlzLnBhc3Nlcz1pLm1hcChmPT5uZXcgZ3QoZiwhMCkpO2xldCBuPXRoaXMucGFzc2VzLmxlbmd0aD4wO2lmKHRoaXMubW9kZT09PSJGQUNFIil7bGV0IGY9dGhpcy5jYW52YXMud2lkdGg7Zm9yKDtmLT10aGlzLmdldERlcHRoT2ZDdXRQeCgpLGkuaW5jbHVkZXMoZil8fHRoaXMucGFzc2VzLnB1c2gobmV3IGd0KE1hdGgubWF4KDAsZiksZjw9MCYmIW4pKSwhKGY8PTApOyk7fWVsc2UgdGhpcy5tb2RlPT09IlRVUk4iJiYodGhpcy5wYXNzZXMucHVzaCguLi50aGlzLmxhdGhlQ29kZS5nZXRDdXRvZmZTdGFydHMoKS5tYXAoZj0+bmV3IGd0KHRoaXMuY2FudmFzLndpZHRoLWYqdGhpcy5weFBlck1tLXRoaXMudG9vbC53aWR0aCwhMSkpKSx0aGlzLnBhc3Nlcy5sZW5ndGh8fHRoaXMucGFzc2VzLnB1c2gobmV3IGd0KDAsITApKSk7dGhpcy5wYXNzZXMuc29ydCgoZix3KT0+dy54LWYueCk7dHJ5e2lmKHRoaXMubW9kZT09PSJGQUNFIil0aGlzLm1vZGVGYWNlKCk7ZWxzZSBpZih0aGlzLm1vZGU9PT0iVFVSTiIpdGhpcy5tb2RlVHVybigpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJ1bnN1cHBvcnRlZCBtb2RlICIrdGhpcy5tb2RlKX1jYXRjaChmKXtwb3N0TWVzc2FnZSh7cHJvZ3Jlc3NNZXNzYWdlOmBNb2RlIGZhaWx1cmU6ICR7Zn1gfSl9dGhpcy5hZGRNb3ZlKEwud2l0aG91dEN1dCh0aGlzLnRvb2xYLHRoaXMudG9vbFksMCx0aGlzLmNhbnZhcy5oZWlnaHQtdGhpcy50b29sWSkpLHRoaXMuYWRkTW92ZShMLndpdGhvdXRDdXQodGhpcy50b29sWCx0aGlzLnRvb2xZLHRoaXMuY2FudmFzLndpZHRoLXRoaXMudG9vbFgsMCkpLHRoaXMucG9zdFByb2dyZXNzKCkscG9zdE1lc3NhZ2Uoe3Byb2dyZXNzTWVzc2FnZTpgT3B0aW1pemluZyAke3RoaXMubW92ZXMubGVuZ3RofSBtb3Zlcy4uLmB9KTtjb25zdCB0PUp0KHRoaXMubW92ZXMpO3Bvc3RNZXNzYWdlKHtwcm9ncmVzc01lc3NhZ2U6YFNob3dpbmcgJHt0Lmxlbmd0aH0gbW92ZXMuLi5gfSkscG9zdE1lc3NhZ2Uoe21vdmVzOnR9KX1tb2RlRmFjZSgpe3ZhciBlO3Bvc3RNZXNzYWdlKHtwcm9ncmVzc01lc3NhZ2U6IlN0YXJ0aW5nIGZpcnN0IHBhc3MuLi4ifSksdGhpcy5wb3N0UHJvZ3Jlc3MoKTtmb3IobGV0IHI9MDtyPHRoaXMucGFzc2VzLmxlbmd0aDtyKyspe2NvbnN0IGk9dGhpcy5wYXNzZXNbcl0ueDt0aGlzLmFkZE1vdmUoTC53aXRob3V0Q3V0KHRoaXMudG9vbFgsdGhpcy50b29sWSxpLXRoaXMudG9vbFgsMCkpO2NvbnN0IG49cj09PTA/dGhpcy5jYW52YXMud2lkdGg6dGhpcy5wYXNzZXNbci0xXS54O3RoaXMucG9zdFByb2dyZXNzV2hpbGUoKCk9PnRoaXMuY3JlZXAodGhpcy50b29sWDxuLCExKSksdGhpcy5hZGRNb3ZlKEwud2l0aG91dEN1dCh0aGlzLnRvb2xYLHRoaXMudG9vbFksMCx0aGlzLmNhbnZhcy5oZWlnaHQtdGhpcy50b29sWSkpLHRoaXMudXBBbGxvd2VkPSEwLHRoaXMucGFzc2VzW3JdLmZpbmlzaEFmdGVyJiYocG9zdE1lc3NhZ2Uoe3Byb2dyZXNzTWVzc2FnZToiRmluaXNoaW5nIHByZXZpb3VzbHkgY3V0IGFyZWEifSksdGhpcy5hZGRNb3ZlKEwud2l0aG91dEN1dCh0aGlzLnRvb2xYLHRoaXMudG9vbFksKCgoZT10aGlzLnByZXZpb3VzRmluaXNoUGFzcyk9PW51bGw/dm9pZCAwOmUueCk/P3RoaXMuY2FudmFzLndpZHRoKS10aGlzLnRvb2xYLDApKSx0aGlzLmlzRmluaXNoUGFzcz0hMCx0aGlzLnBvc3RQcm9ncmVzc1doaWxlKCgpPT50aGlzLmNyZWVwKCExLHRoaXMudG9vbFg+aSkpLHRoaXMuaXNGaW5pc2hQYXNzPSExLHRoaXMudXBBbGxvd2VkPSEwLHRoaXMuYWRkTW92ZShMLndpdGhvdXRDdXQodGhpcy50b29sWCx0aGlzLnRvb2xZLDAsdGhpcy5jYW52YXMuaGVpZ2h0LXRoaXMudG9vbFkpKSx0aGlzLnByZXZpb3VzRmluaXNoUGFzcz10aGlzLnBhc3Nlc1tyXSkscG9zdE1lc3NhZ2Uoe3Byb2dyZXNzTWVzc2FnZTpgQ29tcGxldGVkIHBhc3MgJHtyfWB9KX19bW9kZVR1cm4oKXt2YXIgZTtwb3N0TWVzc2FnZSh7cHJvZ3Jlc3NNZXNzYWdlOiJTdGFydGluZyBmaXJzdCBwYXNzLi4uIn0pLHRoaXMucG9zdFByb2dyZXNzKCk7Zm9yKGxldCByPTA7cjx0aGlzLnBhc3Nlcy5sZW5ndGg7cisrKXtjb25zdCBpPXRoaXMucGFzc2VzW3JdLngsbj1yPT09MD90aGlzLmNhbnZhcy53aWR0aC0xOnRoaXMucGFzc2VzW3ItMV0ueDtmb3IobGV0IHQ9dGhpcy5jYW52YXMuaGVpZ2h0O3Q+PTA7dC09dGhpcy5nZXREZXB0aE9mQ3V0UHgoKSl7cG9zdE1lc3NhZ2Uoe3Byb2dyZXNzTWVzc2FnZTpgU3RhcnRpbmcgc3VicGFzcyAke3R9YH0pO2NvbnN0IGw9dGhpcy5wYXNzZXNbcl0uZmluaXNoQWZ0ZXI/TWF0aC5tYXgoMCx0LXRoaXMuZ2V0RGVwdGhPZkN1dFB4KCkpOi10aGlzLnRvb2xPdmVyc2hvb3RZO3RoaXMuYWRkTW92ZShMLndpdGhvdXRDdXQodGhpcy50b29sWCx0aGlzLnRvb2xZLG4tdGhpcy50b29sWCx0LXRoaXMudG9vbFkpKSx0aGlzLnBvc3RQcm9ncmVzc1doaWxlKCgpPT50aGlzLmNyZWVwKCExLHRoaXMudG9vbFg+aSx0aGlzLnRvb2xZPmwpKSx0aGlzLmFkZE1vdmUoTC53aXRob3V0Q3V0KHRoaXMudG9vbFgsdGhpcy50b29sWSwwLHRoaXMuY2FudmFzLmhlaWdodC10aGlzLnRvb2xZKSksdGhpcy5hZGRNb3ZlKEwud2l0aG91dEN1dCh0aGlzLnRvb2xYLHRoaXMudG9vbFksbi10aGlzLnRvb2xYLDApKSx0aGlzLnVwQWxsb3dlZD0hMH10aGlzLnBhc3Nlc1tyXS5maW5pc2hBZnRlciYmKHBvc3RNZXNzYWdlKHtwcm9ncmVzc01lc3NhZ2U6IkZpbmlzaGluZyBwcmV2aW91c2x5IGN1dCBhcmVhIn0pLHRoaXMuYWRkTW92ZShMLndpdGhvdXRDdXQodGhpcy50b29sWCx0aGlzLnRvb2xZLCgoKGU9dGhpcy5wcmV2aW91c0ZpbmlzaFBhc3MpPT1udWxsP3ZvaWQgMDplLngpPz90aGlzLmNhbnZhcy53aWR0aCktdGhpcy50b29sWCwwKSksdGhpcy5pc0ZpbmlzaFBhc3M9ITAsdGhpcy5wb3N0UHJvZ3Jlc3NXaGlsZSgoKT0+dGhpcy5jcmVlcCghMSx0aGlzLnRvb2xYPmkpKSx0aGlzLmlzRmluaXNoUGFzcz0hMSx0aGlzLnVwQWxsb3dlZD0hMCx0aGlzLmFkZE1vdmUoTC53aXRob3V0Q3V0KHRoaXMudG9vbFgsdGhpcy50b29sWSwwLHRoaXMuY2FudmFzLmhlaWdodC10aGlzLnRvb2xZKSksdGhpcy5wcmV2aW91c0ZpbmlzaFBhc3M9dGhpcy5wYXNzZXNbcl0pLHBvc3RNZXNzYWdlKHtwcm9ncmVzc01lc3NhZ2U6YENvbXBsZXRlZCBwYXNzICR7cn1gfSl9fXBvc3RQcm9ncmVzcygpe2NvbnN0IGU9dGhpcy5jYW52YXMud2lkdGgqdGhpcy5jYW52YXMuaGVpZ2h0PDJlNjtlJiZ0aGlzLmZsdXNoQml0bWFwKCkscG9zdE1lc3NhZ2Uoe2NhbnZhczplP3t3aWR0aDp0aGlzLmNhbnZhcy53aWR0aCxoZWlnaHQ6dGhpcy5jYW52YXMuaGVpZ2h0LGRhdGE6dGhpcy5jYW52YXMuZ2V0Q29udGV4dCgiMmQiKS5nZXRJbWFnZURhdGEoMCwwLHRoaXMuY2FudmFzLndpZHRoLHRoaXMuY2FudmFzLmhlaWdodCkuZGF0YX06dm9pZCAwLHRvb2w6ZT97d2lkdGg6dGhpcy50b29sLndpZHRoLGhlaWdodDp0aGlzLnRvb2wuaGVpZ2h0LGRhdGE6dGhpcy50b29sLmdldENvbnRleHQoIjJkIikuZ2V0SW1hZ2VEYXRhKDAsMCx0aGlzLnRvb2wud2lkdGgsdGhpcy50b29sLmhlaWdodCkuZGF0YSx4OnRoaXMudG9vbFgseTp0aGlzLnRvb2xZfTp2b2lkIDB9KX1wb3N0UHJvZ3Jlc3NXaGlsZShlKXtsZXQgcj1EYXRlLm5vdygpO2Zvcih0aGlzLnBvc3RQcm9ncmVzcygpO2UoKTspRGF0ZS5ub3coKT5yKzFlMyYmKHRoaXMucG9zdFByb2dyZXNzKCkscj1EYXRlLm5vdygpKX1jcmVhdGVQYXJ0Qml0bWFwKCl7Y29uc3QgZT1bXSxyPXRoaXMuY2FudmFzQ3R4LmdldEltYWdlRGF0YSgwLDAsdGhpcy5jYW52YXMud2lkdGgsdGhpcy5jYW52YXMuaGVpZ2h0KS5kYXRhO2ZvcihsZXQgaT0wO2k8dGhpcy5jYW52YXMud2lkdGg7aSsrKXtlW2ldPVtdO2ZvcihsZXQgbj0wO248dGhpcy5jYW52YXMuaGVpZ2h0O24rKyl7Y29uc3QgdD0obip0aGlzLmNhbnZhcy53aWR0aCtpKSo0O2VbaV1bbl09clt0XTw8MTZ8clt0KzFdPDw4fHJbdCsyXX19cmV0dXJuIGV9Z2V0Qml0bWFwKGUscil7cmV0dXJuIHRoaXMucGFydEJpdG1hcFtlXSYmdGhpcy5wYXJ0Qml0bWFwW2VdW3JdfHwwfXNldEJpdG1hcChlLHIsaSl7dGhpcy5wYXJ0Qml0bWFwW2VdW3JdPWl9Zmx1c2hCaXRtYXAoKXtjb25zdCBlPXRoaXMuY2FudmFzQ3R4LmNyZWF0ZUltYWdlRGF0YSh0aGlzLmNhbnZhcy53aWR0aCx0aGlzLmNhbnZhcy5oZWlnaHQpLHI9ZS5kYXRhO2ZvcihsZXQgaT0wO2k8dGhpcy5jYW52YXMud2lkdGg7aSsrKWZvcihsZXQgbj0wO248dGhpcy5jYW52YXMuaGVpZ2h0O24rKyl7Y29uc3QgdD0obip0aGlzLmNhbnZhcy53aWR0aCtpKSo0LGw9dGhpcy5wYXJ0Qml0bWFwW2ldW25dO3JbdF09bD4+MTYmMjU1LHJbdCsxXT1sPj44JjI1NSxyW3QrMl09bCYyNTUsclt0KzNdPTI1NX10aGlzLmNhbnZhc0N0eC5wdXRJbWFnZURhdGEoZSwwLDApfWNyZWVwKGUscixpPSEwKXtjb25zdCBuPXRoaXMudXBBbGxvd2VkJiZpO3JldHVybiBuJiZ0aGlzLnRyeU1vdmUoMCwtMSl8fGUmJm4mJnRoaXMudHJ5TW92ZSgxLC0xKXx8ZSYmdGhpcy50cnlNb3ZlKDEsMCk/ITA6ZSYmdGhpcy50cnlNb3ZlKDEsMSk/KHRoaXMudXBBbGxvd2VkPSEwLCEwKTpyJiZuJiZ0aGlzLnRyeU1vdmUoLTEsLTEpfHxyJiZ0aGlzLnRyeU1vdmUoLTEsMCk/ITA6ciYmdGhpcy50cnlNb3ZlKC0xLDEpPyh0aGlzLnVwQWxsb3dlZD0hMCwhMCk6dGhpcy50cnlNb3ZlKDAsMSk/KHRoaXMudXBBbGxvd2VkPSExLCEwKTohMX1nZXREZXB0aE9mQ3V0UHgoKXtyZXR1cm4gdGhpcy5sYXRoZUNvZGUuZ2V0RGVwdGgoKS5jdXRNbSp0aGlzLnB4UGVyTW19dHJ5TW92ZShlLHIpe2NvbnN0IGk9dGhpcy5jYWxjdWxhdGVNb3ZlKGUscik7cmV0dXJuIGk/KHRoaXMuYWRkTW92ZShpKSwhMCk6ITF9YWRkTW92ZShlKXt0aGlzLm1vdmVzLnB1c2goZSksdGhpcy5kcmF3TW92ZShlKSx0aGlzLnRvb2xYKz1lLnhEZWx0YSx0aGlzLnRvb2xZKz1lLnlEZWx0YX1kcmF3TW92ZShlKXtmb3IobGV0IHIgb2YgZS5jdXRQaXhlbHMpdGhpcy5zZXRCaXRtYXAoci54LHIueSxFcyl9Y2FsY3VsYXRlTW92ZShlLHIpe2NvbnN0IGk9dGhpcy50b29sWCtlLG49dGhpcy50b29sWStyO2lmKG48LXRoaXMudG9vbE92ZXJzaG9vdFl8fGk8LXRoaXMudG9vbE92ZXJzaG9vdFh8fGk+dGhpcy5jYW52YXMud2lkdGh8fG4+dGhpcy5jYW52YXMuaGVpZ2h0KXJldHVybiBudWxsO2xldCB0PVtdO2ZvcihsZXQgYyBvZiB0aGlzLnRvb2xDdXR0aW5nRWRnZXMpe2NvbnN0IGY9dGhpcy5nZXRCaXRtYXAoaStjLngsbitjLnkpO2lmKGY9PT1Ec3x8Zj09PVF0JiZ0aGlzLmlzRmluaXNoUGFzcyl0LnB1c2gobmV3IEt0KGkrYy54LG4rYy55KSk7ZWxzZXtpZihmPT09UHMpcmV0dXJuIG51bGw7aWYoZj09PVF0KXJldHVybiBudWxsfX1jb25zdCBsPU1hdGgubWF4KHRoaXMuaXNGaW5pc2hQYXNzJiZ0aGlzLnRvb2xYPHRoaXMuY2FudmFzLndpZHRoPzE6MCx0Lmxlbmd0aCk7cmV0dXJuIG5ldyBMKHRoaXMudG9vbFgsdGhpcy50b29sWSxlLHIsbCx0KX19c2VsZi5vbm1lc3NhZ2U9cz0+e2NvbnN0IGU9cy5kYXRhLHI9ZS5sYXRoZUNvZGU7aWYocil7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsTnQucHJvdG90eXBlKTt0cnl7bmV3IGtzKG5ldyBOdChyLmdldFRleHQoKSksZS5weFBlck1tfHwxMDApfWNhdGNoKGkpe3Bvc3RNZXNzYWdlKHtlcnJvcjppIGluc3RhbmNlb2YgRXJyb3I/aS5tZXNzYWdlOlN0cmluZyhpKX0pfX19fSkoKTsK",mr=typeof window<"u"&&window.Blob&&new Blob([atob(el)],{type:"text/javascript;charset=utf-8"});function Bm(){let s;try{if(s=mr&&(window.URL||window.webkitURL).createObjectURL(mr),!s)throw"";return new Worker(s)}catch{return new Worker("data:application/javascript;base64,"+el)}finally{s&&(window.URL||window.webkitURL).revokeObjectURL(s)}}const br=100,fr=500;class Om extends EventTarget{constructor(e){super();Tt(this,"latheCode",null);Tt(this,"moves",null);Tt(this,"canvasContainer",null);Tt(this,"generationProgressMessage",null);Tt(this,"canvas",null);Tt(this,"tool",null);Tt(this,"worker",null);this.container=e,e.style.display="none"}setLatheCode(e){if(this.latheCode&&(this.worker&&(this.worker.onmessage=null,this.worker.terminate(),this.worker=null),this.container.replaceChildren(),this.canvasContainer=null,this.canvas=null,this.tool=null),this.latheCode=e,this.latheCode){this.container.insertAdjacentHTML("beforeend","<h2>Planner</h2>"),this.worker=new Bm,this.worker.onmessage=a=>{this.handleMessage(a.data)};const n={latheCode:this.latheCode,pxPerMm:br};this.worker.postMessage(n),this.handleMessage({progressMessage:"Initializing worker..."})}this.container.style.display=this.latheCode?"block":"none"}getMoves(){return this.moves}handleMessage(e){var n,a;if(e.error&&(this.container.innerText=e.error),e.moves&&((n=this.generationProgressMessage)==null||n.remove(),this.generationProgressMessage=null,this.moves=e.moves.map(i=>(Object.setPrototypeOf(i,Ti.prototype),i.toMove(br))),this.drawMoves(this.moves),this.dispatchEvent(new Event("change"))),(e.canvas||e.tool)&&!this.canvasContainer&&(this.canvasContainer=document.createElement("div"),this.canvasContainer.className="canvasContainer",this.container.appendChild(this.canvasContainer)),e.canvas){if(!this.canvas){this.canvas=document.createElement("canvas"),this.canvas.className="part",this.canvas.width=e.canvas.width,this.canvas.height=e.canvas.height,this.canvasContainer.appendChild(this.canvas),this.canvasContainer.style.transform=`scale(${Math.min(1,500/e.canvas.width,500/e.canvas.height/2)})`;const i=document.createElement("div");i.innerHTML="&nbsp;",i.style.height=`${this.canvasContainer.getBoundingClientRect().height}px`,i.scrollIntoView({behavior:"smooth"}),this.container.appendChild(i)}this.canvas.getContext("2d").putImageData(new ImageData(e.canvas.data,e.canvas.width),0,0)}e.tool&&(this.tool||(this.tool=document.createElement("canvas"),this.tool.className="tool",this.tool.width=e.tool.width,this.tool.height=e.tool.height,(a=this.canvasContainer)==null||a.appendChild(this.tool)),this.tool.getContext("2d").putImageData(new ImageData(e.tool.data,e.tool.width),0,0),this.tool.style.left=`${e.tool.x}px`,this.tool.style.top=`${e.tool.y}px`),e.progressMessage&&(this.generationProgressMessage||(this.generationProgressMessage=document.createElement("div"),this.generationProgressMessage.className="generationProgressMessage",this.container.appendChild(this.generationProgressMessage)),this.generationProgressMessage.innerText=e.progressMessage)}drawMoves(e){this.container.insertAdjacentHTML("beforeend","<h3>Toolpath</h3>"),this.container.appendChild(yr(e,fr,fr/2));const n=document.createElement("button");n.innerText="Zoom in",n.addEventListener("click",()=>{tl(yr(e,window.visualViewport.width-100,window.visualViewport.height-200),"Toolpath")}),this.container.appendChild(n)}}function yr(s,t,e){let n=1/0,a=-1/0,i=1/0,r=-1/0;s.forEach(y=>{n=Math.min(y.xStartMm,y.xStartMm+y.xDeltaMm,n),a=Math.max(y.xStartMm,y.xStartMm+y.xDeltaMm,a),i=Math.min(y.yStartMm,y.yStartMm+y.yDeltaMm,i),r=Math.max(y.yStartMm,y.yStartMm+y.yDeltaMm,r)});const o=Math.min(t/(a-n),e/(r-i)),l=y=>(a-y)*o,c=y=>(r-y)*o,h=document.createElement("canvas");h.className="moves",h.width=t,h.height=Math.ceil(o*(r-i));const p=h.getContext("2d");p.lineWidth=1;const u=y=>{p.beginPath(),p.strokeStyle=y.cutAreaMmSq?"red":"green";const m=y.cutAreaMmSq?0:1;p.moveTo(l(y.xStartMm)+m,c(y.yStartMm)),p.lineTo(l(y.xStartMm+y.xDeltaMm)+m,c(y.yStartMm+y.yDeltaMm)),p.stroke()},b=jm(),x=(y,m)=>{if(m<y.length){u(y[m]);const d=()=>x(y,m+1);b?setTimeout(d,b):d()}};return x(s,0),h}function jm(){const t=new URLSearchParams(window.location.search).get("moveTimeout");return t?Number(t):50}const nl=new jr(document.getElementById("sceneContainer")),Jn=new Dm(document.getElementById("editorContainer")),Ts=new Om(document.getElementById("plannerContainer")),Za=new Hm(document.getElementById("gcodeContainer"));function il(){nl.setLatheCode(Jn.getLatheCode()),Ts.setLatheCode(null),Za.hide()}il();Jn.addEventListener("change",()=>il());Jn.addEventListener("stl",()=>{const s=nl.getLatheMesh(),t=Jn.getLatheCode();if(!s||!t)return;const e=zm(s,t.getTitle());e.click(),URL.revokeObjectURL(e.href)});Jn.addEventListener("plan",()=>{Ts.setLatheCode(Jn.getLatheCode())});Ts.addEventListener("change",()=>{const s=Jn.getLatheCode(),t=Ts.getMoves();s&&t&&t.length?Za.show(s,t):Za.hide()});

</script>
  <style>
body{font-family:Roboto;padding:0 20px}.vcont{display:grid;grid-template-columns:repeat(auto-fit,500px);grid-auto-rows:auto;grid-gap:20px}.vcont pre{padding:16px;overflow:auto;background-color:#f5f5f5;border-radius:6px}.inputContainer{width:100%;height:400px;display:flex;flex-direction:column;position:relative}.latheCodeInput{width:100%;height:100%;box-sizing:border-box}.errorContainer:not(:empty){position:absolute;bottom:0;left:10px;right:10px;margin-bottom:10px;padding:10px;background-color:#ff4c4c;color:#fff;font-size:14px;border-radius:0}#sceneContainer{width:500px;height:500px}.selectorContainer{display:flex;flex-direction:row;flex-wrap:wrap}.selectorScene{margin:6px;padding:6px;width:500px;height:500px;cursor:pointer;overflow:hidden;box-sizing:border-box}.selectorScene:hover{border:1px solid #000}#gcodeContainer{margin:12px 0}#plannerContainer .canvasContainer{position:absolute;transform-origin:0 0;overflow:hidden;padding-bottom:12px}#plannerContainer .canvasContainer .tool{position:absolute}#plannerContainer .generationProgressMessage{margin-bottom:8px}#gcodeContainer textarea{box-sizing:border-box;height:400px;width:100%}button{display:inline-block;padding:12px 24px;margin:8px 4px 8px 0;font-size:16px;text-align:center;text-decoration:none;color:#000;background-color:#ffd500;border-radius:0;border:none;cursor:pointer;transition:background-color .3s ease}button:hover{background-color:#ff0}progress{display:block}.senderError{margin:10px 0;padding:10px;background-color:#ff4c4c;color:#fff;font-size:14px}.whatLink{padding:12px 24px;margin:8px 4px 8px 0}.save-group,.load-group,.import-export-group{display:flex;flex-direction:row;align-items:center;gap:10px}.save-group .saveNameInput,.load-group .loadSelect{flex-grow:1}.toolbar input[type=text],.toolbar select{max-width:200px;width:100%;box-sizing:border-box;border:1px solid #ccc;margin:0;padding:.375rem .75rem;font-size:1rem;line-height:1.5}.toolbar .button-like{display:inline-block;padding:12px 24px;margin:8px 4px 8px 0;font-size:16px;text-align:center;text-decoration:none;color:#000;background-color:#ffd500;border-radius:0;border:none;cursor:pointer;transition:background-color .3s ease}#moreOptions{display:none}#moreOptions.expanded{display:block}

</style>
</head>

<body>
  <div class="vcont">
    <div id="editorContainer">
      <h2>Editor</h2>
      <p>Visualizes lathecode and generates GCode - more on <a
          href="https://github.com/kachurovskiy/lathecode">GitHub</a></p>
      <div class="inputContainer">
        <textarea class="latheCodeInput">; Lines starting with ";" are comments

; UNITS IN ; you can use inches
STOCK D5
; STOCK R2.5 ; diameter or radius can be used

TOOL RECT R0.2 L2
; TOOL ROUND R8 ; round tool is also supported
; TOOL ANG R0.2 L7.75 A30 NA55 ; L - edge length, NA - nose angle, A - tool rotation

DEPTH CUT1 ; default depth of cut is 0.5mm
; FEED MOVE200 PASS50 PART10 ; speeds mm/min
; MODE TURN ; for classic style of material removal
; AXES RIGHT DOWN ; for non-NanoEls controllers

L1 D2
L3 D3
L4 DS3 DE5
L3</textarea>
        <div class="errorContainer"></div>
      </div>
      <div class="toolbar">
        <button class="imageButton" title="Generate lathecode from a PNG image file">From image or STL</button>
        <button class="stlButton" title="Download STL file">To STL</button>
        <button class="planButton" title="Generate GCode from current lathecode">To GCode</button>
        <button class="expandCollapseButton" title="See more options">...</button>
      </div>
      <div id="moreOptions" class="toolbar">
        <hr />
        <div class="load-group">
          <button class="saveButton" title="Save to local browser storage">Save</button>
          <select class="loadSelect"></select>
          <button class="loadButton" title="Load from storage">Load</button>
          <button class="deleteButton" title="Delete from storage">Delete</button>
        </div>
        <hr />
        <div class="import-export-group">
          <button class="exportButton" title="Export all to JSON">Export</button>
          <input type="file" id="importFile" style="display: none;" />
          <label for="importFile" class="importButton button-like">Import</label>
        </div>
      </div>
    </div>
    <div id="sceneContainer">
      <h2>3D rendering</h2>
    </div>
    <div id="plannerContainer"></div>
    <div id="gcodeContainer">
      <h2>GCode</h2>
      <textarea id="gcodeTextarea"></textarea>
      <div class="senderError" style="display: none;"></div>
      <progress max="1" style="display: none;"></progress>
      <button class="sendButton">Run on H4</button>
      <button class="saveGcodeButton">Save to H4</button>
      <button class="stopButton" style="display: none;">Stop</button>
      <a class="whatLink" href="https://github.com/kachurovskiy/nanoels/tree/main/h4" target="_blank">What is NanoEls
        H4?</a>
    </div>
  </div>
  
</body>

</html>
